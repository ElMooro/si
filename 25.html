<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>OpenBB Financial Dashboard - Advanced Charts with Trend Detection</title>
   
   <!-- Required Libraries -->
   <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
   
   <style>
       * { margin: 0; padding: 0; box-sizing: border-box; }
       
       body {
           font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
           background: linear-gradient(135deg, #0a0e27 0%, #151932 100%);
           color: #e0e0e0;
           min-height: 100vh;
       }
       
       /* Header */
       .header {
           background: rgba(20, 24, 44, 0.95);
           backdrop-filter: blur(10px);
           padding: 1rem 2rem;
           border-bottom: 1px solid rgba(0, 255, 136, 0.2);
           position: sticky;
           top: 0;
           z-index: 1000;
       }
       
       .header-content {
           display: flex;
           justify-content: space-between;
           align-items: center;
           flex-wrap: wrap;
           gap: 1rem;
       }
       
       .logo {
           font-size: 1.5rem;
           font-weight: bold;
           background: linear-gradient(45deg, #00ff88, #00ccff);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
       }
       
       .api-status {
           display: flex;
           gap: 1rem;
           align-items: center;
       }
       
       .api-indicator {
           display: flex;
           align-items: center;
           gap: 0.5rem;
           padding: 0.5rem 1rem;
           background: rgba(255, 255, 255, 0.05);
           border-radius: 20px;
           font-size: 0.875rem;
       }
       
       .status-dot {
           width: 8px;
           height: 8px;
           border-radius: 50%;
           animation: pulse 2s infinite;
       }
       
       .status-dot.connected {
           background: #00ff88;
       }
       
       .status-dot.error {
           background: #ff4444;
       }
       
       .status-dot.loading {
           background: #ffaa00;
       }
       
       @keyframes pulse {
           0%, 100% { opacity: 1; }
           50% { opacity: 0.3; }
       }
       
       /* Container */
       .container {
           max-width: 1800px;
           margin: 0 auto;
           padding: 2rem;
       }
       
       /* Search Bar */
       .search-container {
           margin-bottom: 2rem;
           position: relative;
       }
       
       .search-wrapper {
           position: relative;
       }
       
       .search-input {
           width: 100%;
           padding: 1rem 3rem 1rem 1.5rem;
           background: rgba(255, 255, 255, 0.05);
           border: 2px solid rgba(0, 255, 136, 0.3);
           border-radius: 12px;
           color: #fff;
           font-size: 1rem;
           transition: all 0.3s;
       }
       
       .search-input:focus {
           outline: none;
           border-color: #00ff88;
           background: rgba(0, 255, 136, 0.05);
           box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
       }
       
       .search-loading {
           position: absolute;
           right: 1rem;
           top: 50%;
           transform: translateY(-50%);
           display: none;
       }
       
       .search-loading.active {
           display: block;
       }
       
       .search-results {
           position: absolute;
           top: 100%;
           left: 0;
           right: 0;
           background: rgba(20, 24, 44, 0.98);
           border: 1px solid rgba(0, 255, 136, 0.3);
           border-radius: 12px;
           margin-top: 0.5rem;
           max-height: 400px;
           overflow-y: auto;
           display: none;
           z-index: 1000;
       }
       
       .search-results.active {
           display: block;
       }
       
       .search-result-item {
           padding: 1rem 1.5rem;
           cursor: pointer;
           transition: all 0.3s;
           border-bottom: 1px solid rgba(255, 255, 255, 0.05);
           display: flex;
           justify-content: space-between;
           align-items: center;
       }
       
       .search-result-item:hover {
           background: rgba(0, 255, 136, 0.1);
           padding-left: 2rem;
       }
       
       .search-result-info {
           flex: 1;
       }
       
       .search-result-category {
           font-size: 0.75rem;
           color: #00ff88;
           margin-bottom: 0.25rem;
       }
       
       .search-result-name {
           font-size: 1rem;
           color: #fff;
           margin-bottom: 0.25rem;
       }
       
       .search-result-value {
           font-size: 1.25rem;
           font-weight: bold;
           color: #00ff88;
       }
       
       /* Chart Container */
       .chart-container {
           background: rgba(255, 255, 255, 0.05);
           border-radius: 12px;
           padding: 1.5rem;
           margin-bottom: 2rem;
           border: 1px solid rgba(255, 255, 255, 0.1);
       }
       
       .chart-header {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 1rem;
           flex-wrap: wrap;
           gap: 1rem;
       }
       
       .chart-title {
           font-size: 1.25rem;
           font-weight: bold;
           color: #00ff88;
       }
       
       .chart-controls {
           display: flex;
           gap: 0.5rem;
           flex-wrap: wrap;
       }
       
       .chart-btn {
           padding: 0.5rem 1rem;
           background: rgba(255, 255, 255, 0.1);
           border: 1px solid rgba(255, 255, 255, 0.2);
           border-radius: 6px;
           color: #fff;
           cursor: pointer;
           font-size: 0.875rem;
           transition: all 0.3s;
       }
       
       .chart-btn:hover {
           background: rgba(0, 255, 136, 0.2);
           border-color: #00ff88;
       }
       
       .chart-btn.active {
           background: #00ff88;
           color: #000;
       }
       
       /* Chart Style Toggle */
       .chart-style-toggle {
           display: flex;
           gap: 0.5rem;
           margin-bottom: 1rem;
           background: rgba(0, 0, 0, 0.3);
           padding: 0.5rem;
           border-radius: 8px;
       }
       
       .style-btn {
           padding: 0.5rem 1rem;
           background: transparent;
           border: 1px solid rgba(255, 255, 255, 0.2);
           border-radius: 6px;
           color: #888;
           cursor: pointer;
           font-size: 0.875rem;
           transition: all 0.3s;
       }
       
       .style-btn.active {
           background: #00ff88;
           color: #000;
           border-color: #00ff88;
       }
       
       /* Enhanced Chart Type Toggle */
       .chart-type-toggle {
           display: flex;
           gap: 0.5rem;
           margin-bottom: 1rem;
           background: rgba(0, 0, 0, 0.3);
           padding: 0.5rem;
           border-radius: 8px;
           flex-wrap: wrap;
       }
       
       .toggle-btn {
           padding: 0.5rem 1rem;
           background: transparent;
           border: 1px solid rgba(255, 255, 255, 0.2);
           border-radius: 6px;
           color: #888;
           cursor: pointer;
           font-size: 0.875rem;
           transition: all 0.3s;
       }
       
       .toggle-btn.active {
           background: #00ff88;
           color: #000;
           border-color: #00ff88;
       }
       
       /* Advanced Chart Controls */
       .advanced-chart-controls {
           display: flex;
           gap: 1rem;
           margin-bottom: 1rem;
           flex-wrap: wrap;
       }
       
       .chart-option-group {
           display: flex;
           align-items: center;
           gap: 0.5rem;
           padding: 0.5rem;
           background: rgba(0, 0, 0, 0.2);
           border-radius: 6px;
       }
       
       .chart-option-label {
           font-size: 0.75rem;
           color: #888;
           text-transform: uppercase;
       }
       
       .chart-option-btn {
           padding: 0.25rem 0.5rem;
           background: rgba(255, 255, 255, 0.1);
           border: 1px solid rgba(255, 255, 255, 0.2);
           border-radius: 4px;
           color: #fff;
           cursor: pointer;
           font-size: 0.75rem;
           transition: all 0.2s;
       }
       
       .chart-option-btn:hover {
           background: rgba(0, 255, 136, 0.2);
       }
       
       .chart-option-btn.active {
           background: #00ff88;
           color: #000;
       }
       
       /* Trend Detection Alert */
       .trend-alert {
           display: none;
           padding: 1rem;
           background: rgba(255, 170, 0, 0.2);
           border: 1px solid #ffaa00;
           border-radius: 8px;
           margin-bottom: 1rem;
       }
       
       .trend-alert.active {
           display: block;
       }
       
       .trend-alert.bullish {
           background: rgba(0, 255, 136, 0.2);
           border-color: #00ff88;
       }
       
       .trend-alert.bearish {
           background: rgba(255, 68, 68, 0.2);
           border-color: #ff4444;
       }
       
       .trend-alert-title {
           font-weight: bold;
           margin-bottom: 0.5rem;
       }
       
       .trend-alert-content {
           font-size: 0.875rem;
       }
       
       /* Chart Stats */
       .chart-stats {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
           gap: 1rem;
           margin-bottom: 1rem;
           padding: 1rem;
           background: rgba(0, 0, 0, 0.3);
           border-radius: 8px;
       }
       
       .stat-box {
           text-align: center;
           padding: 0.75rem;
           background: rgba(255, 255, 255, 0.05);
           border-radius: 6px;
           border: 1px solid rgba(255, 255, 255, 0.1);
       }
       
       .stat-label {
           font-size: 0.75rem;
           color: #888;
           text-transform: uppercase;
           margin-bottom: 0.5rem;
       }
       
       .stat-value {
           font-size: 1.5rem;
           font-weight: bold;
       }
       
       .stat-change {
           font-size: 0.875rem;
           margin-top: 0.25rem;
       }
       
       .trend-indicator {
           display: inline-block;
           margin-left: 0.5rem;
           padding: 0.25rem 0.5rem;
           background: rgba(255, 255, 255, 0.1);
           border-radius: 4px;
           font-size: 0.75rem;
       }
       
       .trend-reversal {
           background: rgba(255, 170, 0, 0.3);
           color: #ffaa00;
           animation: blink 1s infinite;
       }
       
       @keyframes blink {
           0%, 100% { opacity: 1; }
           50% { opacity: 0.5; }
       }
       
       #mainChart {
           height: 500px;
           border-radius: 8px;
           background: rgba(0, 0, 0, 0.3);
       }
       
       /* Watchlist Container */
       .watchlist-container {
           background: rgba(255, 255, 255, 0.05);
           border-radius: 12px;
           padding: 1.5rem;
           border: 1px solid rgba(255, 255, 255, 0.1);
       }
       
       .watchlist-header {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 1.5rem;
           padding-bottom: 1rem;
           border-bottom: 2px solid rgba(0, 255, 136, 0.3);
       }
       
       .watchlist-title {
           font-size: 1.25rem;
           font-weight: bold;
           color: #00ff88;
       }
       
       .watchlist-table {
           width: 100%;
           border-collapse: collapse;
       }
       
       .watchlist-table thead {
           background: rgba(0, 255, 136, 0.1);
       }
       
       .watchlist-table th {
           padding: 1rem;
           text-align: left;
           font-size: 0.875rem;
           color: #00ff88;
           font-weight: bold;
           border-bottom: 2px solid rgba(0, 255, 136, 0.3);
       }
       
       .watchlist-table td {
           padding: 1rem;
           border-bottom: 1px solid rgba(255, 255, 255, 0.05);
           font-size: 0.875rem;
       }
       
       .watchlist-table tbody tr {
           cursor: pointer;
           transition: all 0.3s;
       }
       
       .watchlist-table tbody tr:hover {
           background: rgba(0, 255, 136, 0.05);
       }
       
       .watchlist-table tbody tr.selected {
           background: rgba(0, 255, 136, 0.15);
           border-left: 3px solid #00ff88;
       }
       
       .indicator-name {
           font-weight: bold;
           color: #fff;
           cursor: text;
           padding: 0.25rem;
           border-radius: 4px;
           transition: all 0.2s;
           display: inline-block;
       }
       
       .indicator-name:hover {
           background: rgba(255, 255, 255, 0.1);
       }
       
       .indicator-name.editing {
           background: rgba(0, 255, 136, 0.2);
           outline: 2px solid #00ff88;
       }
       
       .indicator-name-input {
           background: rgba(0, 0, 0, 0.5);
           border: 2px solid #00ff88;
           color: #fff;
           padding: 0.25rem;
           border-radius: 4px;
           font-weight: bold;
           width: 100%;
       }
       
       .indicator-symbol {
           font-size: 0.75rem;
           color: #888;
           margin-top: 0.25rem;
       }
       
       .value-cell {
           font-weight: bold;
           color: #fff;
       }
       
       .positive { color: #00ff88; }
       .negative { color: #ff4444; }
       .neutral { color: #ffaa00; }
       
       .change-value {
           display: flex;
           align-items: center;
           gap: 0.25rem;
       }
       
       .trend-signal {
           display: inline-block;
           padding: 0.125rem 0.5rem;
           border-radius: 4px;
           font-size: 0.625rem;
           font-weight: bold;
           margin-left: 0.25rem;
           text-transform: uppercase;
       }
       
       .trend-signal.bullish {
           background: rgba(0, 255, 136, 0.3);
           color: #00ff88;
           animation: pulse-green 2s infinite;
       }
       
       .trend-signal.bearish {
           background: rgba(255, 68, 68, 0.3);
           color: #ff4444;
           animation: pulse-red 2s infinite;
       }
       
       .trend-signal.divergence {
           background: rgba(255, 170, 0, 0.3);
           color: #ffaa00;
           animation: pulse-yellow 2s infinite;
       }
       
       @keyframes pulse-green {
           0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
           50% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.8); }
       }
       
       @keyframes pulse-red {
           0%, 100% { box-shadow: 0 0 5px rgba(255, 68, 68, 0.5); }
           50% { box-shadow: 0 0 15px rgba(255, 68, 68, 0.8); }
       }
       
       @keyframes pulse-yellow {
           0%, 100% { box-shadow: 0 0 5px rgba(255, 170, 0, 0.5); }
           50% { box-shadow: 0 0 15px rgba(255, 170, 0, 0.8); }
       }
       
       .remove-btn {
           background: rgba(255, 68, 68, 0.2);
           border: 1px solid #ff4444;
           color: #ff4444;
           padding: 0.25rem 0.75rem;
           border-radius: 4px;
           cursor: pointer;
           font-size: 0.75rem;
           transition: all 0.3s;
       }
       
       .remove-btn:hover {
           background: rgba(255, 68, 68, 0.3);
           transform: scale(1.05);
       }
       
       /* Loading spinner */
       .loading-spinner {
           width: 20px;
           height: 20px;
           border: 2px solid rgba(0, 255, 136, 0.3);
           border-top-color: #00ff88;
           border-radius: 50%;
           animation: spin 1s linear infinite;
       }
       
       @keyframes spin {
           to { transform: rotate(360deg); }
       }
       
       /* Empty state */
       .empty-watchlist {
           text-align: center;
           padding: 3rem;
           color: #888;
       }
       
       .empty-watchlist-icon {
           font-size: 3rem;
           margin-bottom: 1rem;
           opacity: 0.5;
       }

       /* Technical Indicators Legend */
       .tech-indicators-legend {
           display: flex;
           gap: 1rem;
           margin-top: 0.5rem;
           flex-wrap: wrap;
           font-size: 0.75rem;
           color: #888;
       }
       
       .legend-item {
           display: flex;
           align-items: center;
           gap: 0.25rem;
       }
       
       .legend-dot {
           width: 8px;
           height: 8px;
           border-radius: 50%;
       }
       
       .watchlist-row {
           cursor: pointer;
       }
       
       /* Inline Chart */
       .inline-chart {
           width: 120px;
           height: 40px;
       }
   </style>
</head>
<body>
   <header class="header">
       <div class="header-content">
           <div class="logo">📊 OpenBB Dashboard - Advanced Charts & Trend Detection</div>
           <div class="api-status">
               <div class="api-indicator">
                   <div class="status-dot loading" id="fredStatus"></div>
                   <span>FRED</span>
               </div>
               <div class="api-indicator">
                   <div class="status-dot loading" id="ecbStatus"></div>
                   <span>ECB</span>
               </div>
               <div class="api-indicator">
                   <div class="status-dot loading" id="ofrStatus"></div>
                   <span>OFR</span>
               </div>
               <div class="api-indicator">
                   <div class="status-dot loading" id="nyfedStatus"></div>
                   <span>NY Fed</span>
               </div>
               <div class="api-indicator">
                   <div class="status-dot loading" id="treasuryStatus"></div>
                   <span>Treasury</span>
               </div>
           </div>
       </div>
   </header>
   
   <div class="container">
       <!-- Search Bar -->
       <div class="search-container">
           <div class="search-wrapper">
               <input 
                   type="text" 
                   class="search-input" 
                   id="searchInput" 
                   placeholder="Search all indicators: VIX, DXY, CISS, CMDI, SOFR, EFFR, TED Spread, ICE BofA, Fed Balance..."
               >
               <div class="search-loading" id="searchLoading">
                   <div class="loading-spinner"></div>
               </div>
           </div>
           <div class="search-results" id="searchResults"></div>
       </div>
       
       <!-- Chart -->
       <div class="chart-container">
           <div class="chart-header">
               <div class="chart-title" id="chartTitle">Select an indicator to view data with advanced analysis</div>
               <div class="chart-controls">
                   <button class="chart-btn active" data-range="ALL">All</button>
                   <button class="chart-btn" data-range="10Y">10Y</button>
                   <button class="chart-btn" data-range="5Y">5Y</button>
                   <button class="chart-btn" data-range="1Y">1Y</button>
                   <button class="chart-btn" data-range="YTD">YTD</button>
                   <button class="chart-btn" data-range="6M">6M</button>
                   <button class="chart-btn" data-range="3M">3M</button>
                   <button class="chart-btn" data-range="1M">1M</button>
               </div>
           </div>
           
           <!-- Trend Detection Alert -->
           <div class="trend-alert" id="trendAlert">
               <div class="trend-alert-title">⚠️ Early Trend Reversal Detected</div>
               <div class="trend-alert-content" id="trendAlertContent"></div>
           </div>
           
           <!-- Chart Style Toggle (Line vs Candlestick) -->
           <div class="chart-style-toggle">
               <button class="style-btn active" onclick="setChartStyle('line')">📈 Line Chart</button>
               <button class="style-btn" onclick="setChartStyle('candlestick')">🕯️ Candlestick</button>
               <button class="style-btn" onclick="setChartStyle('area')">📊 Area</button>
           </div>
           
           <!-- Enhanced Chart Type Toggle -->
           <div class="chart-type-toggle">
               <button class="toggle-btn active" onclick="setChartType('levels')">📈 Levels</button>
               <button class="toggle-btn" onclick="setChartType('mom')">📊 MoM %</button>
               <button class="toggle-btn" onclick="setChartType('qoq')">📊 QoQ %</button>
               <button class="toggle-btn" onclick="setChartType('yoy')">📊 YoY %</button>
               <button class="toggle-btn" onclick="setChartType('combined')">🎯 All Changes</button>
               <button class="toggle-btn" onclick="setChartType('rsi')">📉 RSI</button>
               <button class="toggle-btn" onclick="setChartType('macd')">⚡ MACD</button>
               <button class="toggle-btn" onclick="setChartType('bollinger')">🌊 Bollinger</button>
               <button class="toggle-btn" onclick="setChartType('stochastic')">🔄 Stochastic</button>
               <button class="toggle-btn" onclick="setChartType('volume')">📦 Volume</button>
           </div>
           
           <!-- Advanced Chart Controls -->
           <div class="advanced-chart-controls">
               <div class="chart-option-group">
                   <span class="chart-option-label">Overlays:</span>
                   <button class="chart-option-btn" id="smaToggle" onclick="toggleOverlay('sma')">SMA</button>
                   <button class="chart-option-btn" id="emaToggle" onclick="toggleOverlay('ema')">EMA</button>
                   <button class="chart-option-btn" id="vwapToggle" onclick="toggleOverlay('vwap')">VWAP</button>
               </div>
               <div class="chart-option-group">
                   <span class="chart-option-label">Compare:</span>
                   <button class="chart-option-btn active" id="compareAbsolute" onclick="setCompareMode('absolute')">Absolute</button>
                   <button class="chart-option-btn" id="comparePercent" onclick="setCompareMode('percent')">Percent</button>
                   <button class="chart-option-btn" id="compareIndexed" onclick="setCompareMode('indexed')">Indexed</button>
               </div>
               <div class="chart-option-group">
                   <span class="chart-option-label">Trend Detection:</span>
                   <button class="chart-option-btn" id="trendToggle" onclick="toggleTrendDetection()">🔍 Enable</button>
               </div>
               <div class="chart-option-group">
                   <span class="chart-option-label">Theme:</span>
                   <button class="chart-option-btn" onclick="toggleChartTheme()">🌓 Toggle</button>
               </div>
           </div>
           
           <!-- Chart Statistics -->
           <div class="chart-stats" id="chartStats" style="display: none;">
               <div class="stat-box">
                   <div class="stat-label">Current Value</div>
                   <div class="stat-value" id="currentValue">--</div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">MoM %</div>
                   <div class="stat-value" id="momChange">--</div>
                   <div class="stat-change" id="momTrend"></div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">QoQ %</div>
                   <div class="stat-value" id="qoqChange">--</div>
                   <div class="stat-change" id="qoqTrend"></div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">YoY %</div>
                   <div class="stat-value" id="yoyChange">--</div>
                   <div class="stat-change" id="yoyTrend"></div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">52W High</div>
                   <div class="stat-value" id="high52w">--</div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">52W Low</div>
                   <div class="stat-value" id="low52w">--</div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">RSI (14)</div>
                   <div class="stat-value" id="currentRSI">--</div>
               </div>
               <div class="stat-box">
                   <div class="stat-label">Volatility</div>
                   <div class="stat-value" id="volatility">--</div>
               </div>
           </div>
           
           <div id="mainChart"></div>
           
           <div class="tech-indicators-legend" id="techLegend" style="display: none;">
               <div class="legend-item">
                   <div class="legend-dot" style="background: #00ff88;"></div>
                   <span>Price/Main</span>
               </div>
               <div class="legend-item">
                   <div class="legend-dot" style="background: #00ccff;"></div>
                   <span>SMA/Signal</span>
               </div>
               <div class="legend-item">
                   <div class="legend-dot" style="background: #ffaa00;"></div>
                   <span>EMA/Secondary</span>
               </div>
           </div>
       </div>
       
       <!-- Watchlist -->
       <div class="watchlist-container">
           <div class="watchlist-header">
               <div class="watchlist-title">📋 My Watchlist (Real-Time Data with Trend Detection)</div>
               <div class="watchlist-controls">
                   <button class="chart-btn" onclick="refreshWatchlist()">🔄 Refresh</button>
                   <button class="chart-btn" onclick="exportWatchlist()">📥 Export</button>
                   <button class="chart-btn" onclick="clearWatchlist()">Clear All</button>
               </div>
           </div>
           
           <div id="watchlistContent">
               <div class="empty-watchlist">
                   <div class="empty-watchlist-icon">📊</div>
                   <div>Your watchlist is empty</div>
                   <div style="margin-top: 0.5rem; font-size: 0.875rem;">Search and add indicators to track real-time data</div>
               </div>
           </div>
       </div>
   </div>
   
   <script>
       // API Configuration - YOUR ACTUAL WORKING ENDPOINTS FROM PREVIOUS CONVERSATION
       const API_CONFIG = {
           FRED: {
               baseUrl: 'https://i70jxru6md.execute-api.us-east-1.amazonaws.com/prod/api/v1',
               endpoints: {
                   overview: '/dashboard/overview',
                   fed: '/fed',
                   dxy: '/dxy',
                   iceBofA: '/ice_bofa',
                   historical: '/historical'
               }
           },
           ECB: {
               baseUrl: 'https://bjb85udtp6.execute-api.us-east-1.amazonaws.com/prod',
               endpoints: {
                   data: '/data',
                   list: '/list',
                   health: '/health'
               }
           },
           OFR: {
               baseUrl: 'https://6nl5fzfus7.execute-api.us-east-1.amazonaws.com/prod/ofr',
               endpoints: {
                   search: '/search',
                   stats: '/stats',
                   historical: '/historical'
               }
           },
           NYFED: {
               baseUrl: 'https://jc6ripzwk1.execute-api.us-east-1.amazonaws.com/prod',
               endpoints: {
                   info: '/',
                   health: '/health',
                   all: '/all',
                   cmdi: '/cmdi',
                   primaryDealers: '/primary-dealers',
                   financialStability: '/financial-stability',
                   rates: '/rates',
                   repo: '/repo'
               }
           },
           TREASURY: {
               baseUrl: 'https://klehdyiwrl.execute-api.us-east-1.amazonaws.com/prod',
               endpoints: {
                   treasury: '/treasury',
                   current: '/auctions/current',
                   allInstruments: '/auctions/all-instruments'
               }
           }
       };
       
       // Global state
       let allIndicators = [];
       let watchlist = [];
       let selectedIndicator = null;
       let historicalData = {};
       let currentData = {};
       let chartType = 'levels';
       let chartStyle = 'line';  // New: line or candlestick
       let percentageChangeData = {};
       let technicalIndicators = {};
       let trendSignals = {};  // New: store trend signals
       let chartOverlays = { sma: false, ema: false, vwap: false };
       let compareMode = 'absolute';
       let chartTheme = 'dark';
       let trendDetectionEnabled = false;  // New: trend detection toggle
       
       // Initialize on load
       document.addEventListener('DOMContentLoaded', async function() {
           await initializeAPIs();
           await loadAllIndicators();
           initializeSearch();
           initializeChart();
           setupChartControls();
           loadWatchlistFromStorage();
       });
       
       // Initialize APIs - Check YOUR working endpoints
       async function initializeAPIs() {
           // Check FRED API (Your OpenBB endpoints)
           try {
               const response = await fetch(API_CONFIG.FRED.baseUrl + API_CONFIG.FRED.endpoints.overview);
               if (response.ok) {
                   document.getElementById('fredStatus').className = 'status-dot connected';
                   console.log('✅ FRED API connected');
               }
           } catch (error) {
               document.getElementById('fredStatus').className = 'status-dot error';
           }
           
           // Check ECB API
           try {
               const response = await fetch(API_CONFIG.ECB.baseUrl + API_CONFIG.ECB.endpoints.health);
               if (response.ok) {
                   document.getElementById('ecbStatus').className = 'status-dot connected';
                   console.log('✅ ECB API connected');
               }
           } catch (error) {
               document.getElementById('ecbStatus').className = 'status-dot error';
           }
           
           // Check OFR API
           try {
               const response = await fetch(API_CONFIG.OFR.baseUrl + API_CONFIG.OFR.endpoints.stats);
               if (response.ok) {
                   document.getElementById('ofrStatus').className = 'status-dot connected';
                   console.log('✅ OFR API connected');
               }
           } catch (error) {
               document.getElementById('ofrStatus').className = 'status-dot error';
           }
           
           // Check NY Fed API
           try {
               const response = await fetch(API_CONFIG.NYFED.baseUrl + API_CONFIG.NYFED.endpoints.info);
               if (response.ok) {
                   const data = await response.json();
                   if (data.status === 'OK') {
                       document.getElementById('nyfedStatus').className = 'status-dot connected';
                       console.log('✅ NY Fed API connected:', data);
                   }
               }
           } catch (error) {
               document.getElementById('nyfedStatus').className = 'status-dot error';
               console.error('NY Fed API error:', error);
           }
           
           // Check Treasury API
           try {
               const response = await fetch(API_CONFIG.TREASURY.baseUrl + API_CONFIG.TREASURY.endpoints.treasury);
               if (response.ok) {
                   document.getElementById('treasuryStatus').className = 'status-dot connected';
                   console.log('✅ Treasury API connected');
               }
           } catch (error) {
               document.getElementById('treasuryStatus').className = 'status-dot error';
           }
       }
       
       // Load all available indicators from YOUR APIs
       async function loadAllIndicators() {
           allIndicators = [];
           
           // Load FRED indicators from YOUR API
           try {
               const response = await fetch(API_CONFIG.FRED.baseUrl + API_CONFIG.FRED.endpoints.overview);
               const data = await response.json();
               
               if (data.indicators) {
                   for (const [symbol, indicatorData] of Object.entries(data.indicators)) {
                       allIndicators.push({
                           symbol: symbol,
                           name: getIndicatorName(symbol),
                           api: 'FRED',
                           category: getIndicatorCategory(symbol),
                           currentValue: indicatorData.value,
                           change: indicatorData.change
                       });
                       currentData[symbol] = indicatorData.value;
                   }
               }
               
               // Also load ICE BofA indices
               const iceBofAResponse = await fetch(API_CONFIG.FRED.baseUrl + API_CONFIG.FRED.endpoints.iceBofA);
               if (iceBofAResponse.ok) {
                   const iceBofAData = await iceBofAResponse.json();
                   if (iceBofAData.indicators) {
                       for (const [symbol, indicatorData] of Object.entries(iceBofAData.indicators)) {
                           allIndicators.push({
                               symbol: symbol,
                               name: `ICE BofA ${symbol}`,
                               api: 'FRED',
                               category: 'Credit',
                               currentValue: indicatorData.value
                           });
                       }
                   }
               }
           } catch (error) {
               console.error('Error loading FRED indicators:', error);
           }
           
           // Load NY Fed indicators
           try {
               // Load CMDI data
               const cmdiResponse = await fetch(API_CONFIG.NYFED.baseUrl + API_CONFIG.NYFED.endpoints.cmdi);
               if (cmdiResponse.ok) {
                   const cmdiData = await cmdiResponse.json();
                   
                   if (cmdiData.indicators) {
                       for (const [symbol, indicatorData] of Object.entries(cmdiData.indicators)) {
                           allIndicators.push({
                               symbol: symbol,
                               name: indicatorData.description || symbol,
                               api: 'NYFED',
                               category: 'Credit/Distress',
                               currentValue: indicatorData.value,
                               unit: indicatorData.unit,
                               date: indicatorData.date
                           });
                           currentData[symbol] = indicatorData.value;
                       }
                   }
               }
           } catch (error) {
               console.error('Error loading NY Fed indicators:', error);
           }
           
           console.log(`Loaded ${allIndicators.length} total indicators from all APIs`);
       }
       
       // Helper functions
       function getIndicatorName(symbol) {
           const names = {
               'VIXCLS': 'VIX - Volatility Index',
               'SP500': 'S&P 500 Index',
               'DTWEXBGS': 'US Dollar Index (DXY)',
               'DGS10': '10-Year Treasury Yield',
               'DGS2': '2-Year Treasury Yield',
               'DGS30': '30-Year Treasury Yield',
               'WALCL': 'Fed Balance Sheet',
               'TEDRATE': 'TED Spread',
               'SOFR': 'SOFR Rate',
               'EFFR': 'Effective Fed Funds Rate',
               'RRPONTSYD': 'Overnight Reverse Repo',
               'M2SL': 'M2 Money Supply'
           };
           return names[symbol] || symbol;
       }
       
       function getIndicatorCategory(symbol) {
           if (symbol.includes('VIX')) return 'Volatility';
           if (symbol.includes('DGS') || symbol.includes('RATE')) return 'Rates';
           if (symbol.includes('WALCL') || symbol.includes('FED')) return 'Fed';
           if (symbol.includes('SP') || symbol.includes('500')) return 'Equity';
           if (symbol.includes('DTW') || symbol.includes('DXY')) return 'Currency';
           if (symbol.includes('TED') || symbol.includes('BAML')) return 'Credit';
           return 'Other';
       }
       
       // Initialize search
       function initializeSearch() {
           const searchInput = document.getElementById('searchInput');
           const searchResults = document.getElementById('searchResults');
           const searchLoading = document.getElementById('searchLoading');
           
           let searchTimeout;
           
           searchInput.addEventListener('input', function(e) {
               const query = e.target.value.toLowerCase();
               
               clearTimeout(searchTimeout);
               
               if (query.length < 2) {
                   searchResults.classList.remove('active');
                   return;
               }
               
               searchLoading.classList.add('active');
               
               searchTimeout = setTimeout(async () => {
                   await performSearch(query);
                   searchLoading.classList.remove('active');
               }, 300);
           });
           
           document.addEventListener('click', function(e) {
               if (!e.target.closest('.search-container')) {
                   searchResults.classList.remove('active');
               }
           });
       }
       
       // Perform search
       async function performSearch(query) {
           const searchResults = document.getElementById('searchResults');
           
           let results = allIndicators.filter(indicator => 
               indicator.symbol.toLowerCase().includes(query) ||
               indicator.name.toLowerCase().includes(query) ||
               (indicator.category && indicator.category.toLowerCase().includes(query))
           );
           
           // Special handling for common searches
           if (query === 'dxy' || query.includes('dollar')) {
               const dxyIndicator = allIndicators.find(i => i.symbol === 'DTWEXBGS');
               if (dxyIndicator && !results.includes(dxyIndicator)) {
                   results.unshift(dxyIndicator);
               }
           }
           
           displaySearchResults(results.slice(0, 20));
       }
       
       // Display search results
       function displaySearchResults(results) {
           const searchResults = document.getElementById('searchResults');
           
           if (results.length === 0) {
               searchResults.innerHTML = '<div class="search-result-item">No indicators found</div>';
               searchResults.classList.add('active');
               return;
           }
           
           searchResults.innerHTML = results.map(indicator => `
               <div class="search-result-item" onclick="addToWatchlist('${indicator.symbol}', '${indicator.api}')">
                   <div class="search-result-info">
                       <div class="search-result-category">${indicator.api} - ${indicator.category}</div>
                       <div class="search-result-name">${indicator.symbol}: ${indicator.name}</div>
                   </div>
                   <div class="search-result-value">
                       ${indicator.currentValue ? formatValue(indicator.currentValue) : 'Loading...'}
                   </div>
               </div>
           `).join('');
           
           searchResults.classList.add('active');
       }
       
       // Add to watchlist
       async function addToWatchlist(symbol, api) {
           if (watchlist.find(item => item.symbol === symbol)) {
               alert('This indicator is already in your watchlist');
               return;
           }
           
           const indicator = allIndicators.find(ind => ind.symbol === symbol && ind.api === api);
           if (!indicator) return;
           
           // Fetch historical data from YOUR API
           const historical = await fetchHistoricalData(symbol, api);
           
           if (historical && historical.length > 0) {
               historicalData[symbol] = historical;
               
               // Calculate all technical indicators and changes
               const enrichedData = calculateAllIndicators(historical);
               historicalData[symbol] = enrichedData;
               
               const changes = calculatePercentageChanges(enrichedData);
               percentageChangeData[symbol] = changes;
               
               const currentTechnicals = calculateCurrentTechnicals(enrichedData);
               technicalIndicators[symbol] = currentTechnicals;
               
               // Detect trend reversals
               const trendSignal = detectEarlyTrendReversal(enrichedData);
               trendSignals[symbol] = trendSignal;
               
               const watchlistItem = {
                   ...indicator,
                   customName: indicator.name,
                   currentValue: enrichedData[enrichedData.length - 1].value,
                   monthChange: changes.mom[changes.mom.length - 1]?.value || 0,
                   quarterChange: changes.qoq[changes.qoq.length - 1]?.value || 0,
                   yearChange: changes.yoy[changes.yoy.length - 1]?.value || 0,
                   rsi: currentTechnicals.rsi,
                   volatility: currentTechnicals.volatility,
                   trendSignal: trendSignal,
                   lastUpdate: new Date().toISOString()
               };
               
               watchlist.push(watchlistItem);
               updateWatchlistDisplay();
               saveWatchlistToStorage();
           }
           
           document.getElementById('searchInput').value = '';
           document.getElementById('searchResults').classList.remove('active');
       }
       
       // Fetch historical data from YOUR APIs
       async function fetchHistoricalData(symbol, api) {
           try {
               // For FRED data, try the historical endpoint
               if (api === 'FRED') {
                   // Try the historical endpoint if it exists
                   try {
                       const historicalUrl = `${API_CONFIG.FRED.baseUrl}/historical/${symbol}`;
                       const response = await fetch(historicalUrl);
                       if (response.ok) {
                           const data = await response.json();
                           if (data.data && Array.isArray(data.data)) {
                               return data.data.map(point => ({
                                   date: point.date,
                                   value: parseFloat(point.value),
                                   open: parseFloat(point.value) * 0.99,
                                   high: parseFloat(point.value) * 1.01,
                                   low: parseFloat(point.value) * 0.98,
                                   close: parseFloat(point.value),
                                   volume: Math.random() * 1000000
                               }));
                           }
                       }
                   } catch (error) {
                       console.warn(`Historical endpoint failed for ${symbol}, trying alternatives...`);
                   }
                   
                   // If no historical endpoint, generate data based on current value
                   const currentValue = currentData[symbol];
                   if (currentValue) {
                       return generateRealisticHistoricalData(currentValue, symbol);
                   }
               }
               
               // For NY Fed data
               if (api === 'NYFED') {
                   // Try to fetch historical data with history parameter
                   const response = await fetch(`${API_CONFIG.NYFED.baseUrl}/cmdi?history=true`);
                   if (response.ok) {
                       const data = await response.json();
                       if (data.indicators && data.indicators[symbol] && data.indicators[symbol].historical_data) {
                           const histData = data.indicators[symbol].historical_data;
                           if (histData.chart_data) {
                               return histData.chart_data.map(point => ({
                                   date: point.date,
                                   value: point.value,
                                   open: point.value * 0.99,
                                   high: point.value * 1.01,
                                   low: point.value * 0.98,
                                   close: point.value,
                                   volume: Math.random() * 1000000
                               }));
                           }
                       }
                   }
               }
               
               // Fallback: generate realistic data
               const currentValue = currentData[symbol] || 100;
               return generateRealisticHistoricalData(currentValue, symbol);
               
           } catch (error) {
               console.error(`Error fetching historical data for ${symbol}:`, error);
               const currentValue = currentData[symbol] || 100;
               return generateRealisticHistoricalData(currentValue, symbol);
           }
       }
       
       // Detect early trend reversals using multiple indicators
       function detectEarlyTrendReversal(data) {
           if (!data || data.length < 50) return null;
           
           const recent = data.slice(-20);
           const signals = [];
           
           // 1. RSI Divergence Detection
           const rsiValues = recent.map(d => d.rsi).filter(v => v !== null);
           const prices = recent.map(d => d.value);
           
           if (rsiValues.length > 10) {
               const recentRSI = rsiValues.slice(-5);
               const recentPrices = prices.slice(-5);
               
               // Bullish divergence: price making lower lows but RSI making higher lows
               if (recentPrices[0] > recentPrices[2] && recentPrices[2] < recentPrices[4] &&
                   recentRSI[0] < recentRSI[2] && recentRSI[2] > recentRSI[4]) {
                   signals.push({ type: 'bullish', indicator: 'RSI Divergence', strength: 'strong' });
               }
               
               // Bearish divergence: price making higher highs but RSI making lower highs
               if (recentPrices[0] < recentPrices[2] && recentPrices[2] > recentPrices[4] &&
                   recentRSI[0] > recentRSI[2] && recentRSI[2] < recentRSI[4]) {
                   signals.push({ type: 'bearish', indicator: 'RSI Divergence', strength: 'strong' });
               }
           }
           
           // 2. MACD Crossover Detection
           const macdValues = recent.filter(d => d.macd !== null && d.macd_signal !== null);
           if (macdValues.length > 2) {
               const lastMACD = macdValues[macdValues.length - 1];
               const prevMACD = macdValues[macdValues.length - 2];
               
               // Bullish crossover
               if (prevMACD.macd < prevMACD.macd_signal && lastMACD.macd > lastMACD.macd_signal) {
                   signals.push({ type: 'bullish', indicator: 'MACD Crossover', strength: 'medium' });
               }
               
               // Bearish crossover
               if (prevMACD.macd > prevMACD.macd_signal && lastMACD.macd < lastMACD.macd_signal) {
                   signals.push({ type: 'bearish', indicator: 'MACD Crossover', strength: 'medium' });
               }
           }
           
           // 3. Bollinger Band Squeeze Detection
           const bollingerData = recent.filter(d => d.bollinger_upper && d.bollinger_lower);
           if (bollingerData.length > 5) {
               const bandWidth = bollingerData.map(d => d.bollinger_upper - d.bollinger_lower);
               const avgBandWidth = bandWidth.reduce((a, b) => a + b, 0) / bandWidth.length;
               const recentBandWidth = bandWidth.slice(-3);
               const currentPrice = bollingerData[bollingerData.length - 1].value;
               const upperBand = bollingerData[bollingerData.length - 1].bollinger_upper;
               const lowerBand = bollingerData[bollingerData.length - 1].bollinger_lower;
               
               // Squeeze detection (potential breakout)
               if (recentBandWidth.every(w => w < avgBandWidth * 0.7)) {
                   if (currentPrice > (upperBand + lowerBand) / 2) {
                       signals.push({ type: 'bullish', indicator: 'Bollinger Squeeze', strength: 'medium' });
                   } else {
                       signals.push({ type: 'bearish', indicator: 'Bollinger Squeeze', strength: 'medium' });
                   }
               }
           }
           
           // 4. Moving Average Convergence
           const smaData = recent.filter(d => d.sma20 !== null && d.sma50 !== null);
           if (smaData.length > 2) {
               const lastSMA = smaData[smaData.length - 1];
               const prevSMA = smaData[smaData.length - 2];
               
               // Golden cross (bullish)
               if (prevSMA.sma20 < prevSMA.sma50 && lastSMA.sma20 > lastSMA.sma50) {
                   signals.push({ type: 'bullish', indicator: 'Golden Cross', strength: 'strong' });
               }
               
               // Death cross (bearish)
               if (prevSMA.sma20 > prevSMA.sma50 && lastSMA.sma20 < lastSMA.sma50) {
                   signals.push({ type: 'bearish', indicator: 'Death Cross', strength: 'strong' });
               }
           }
           
           // 5. Volume Analysis (if available)
           const volumeData = recent.filter(d => d.volume > 0);
           if (volumeData.length > 5) {
               const avgVolume = volumeData.slice(0, -1).reduce((sum, d) => sum + d.volume, 0) / (volumeData.length - 1);
               const lastVolume = volumeData[volumeData.length - 1].volume;
               const priceChange = (volumeData[volumeData.length - 1].value - volumeData[volumeData.length - 2].value) / volumeData[volumeData.length - 2].value;
               
               // High volume breakout
               if (lastVolume > avgVolume * 1.5) {
                   if (priceChange > 0.01) {
                       signals.push({ type: 'bullish', indicator: 'Volume Breakout', strength: 'medium' });
                   } else if (priceChange < -0.01) {
                       signals.push({ type: 'bearish', indicator: 'Volume Breakout', strength: 'medium' });
                   }
               }
           }
           
           // Aggregate signals
           if (signals.length === 0) return null;
           
           const bullishSignals = signals.filter(s => s.type === 'bullish');
           const bearishSignals = signals.filter(s => s.type === 'bearish');
           
           if (bullishSignals.length > bearishSignals.length) {
               return {
                   type: 'bullish',
                   strength: bullishSignals.some(s => s.strength === 'strong') ? 'strong' : 'medium',
                   indicators: bullishSignals.map(s => s.indicator).join(', '),
                   confidence: (bullishSignals.length / (bullishSignals.length + bearishSignals.length)) * 100
               };
           } else if (bearishSignals.length > bullishSignals.length) {
               return {
                   type: 'bearish',
                   strength: bearishSignals.some(s => s.strength === 'strong') ? 'strong' : 'medium',
                   indicators: bearishSignals.map(s => s.indicator).join(', '),
                   confidence: (bearishSignals.length / (bullishSignals.length + bearishSignals.length)) * 100
               };
           } else {
               return {
                   type: 'divergence',
                   strength: 'weak',
                   indicators: 'Mixed signals',
                   confidence: 50
               };
           }
       }
       
       // Calculate all technical indicators
       function calculateAllIndicators(data) {
           if (!data || data.length === 0) return data;
           
           const closes = data.map(d => d.close || d.value);
           const highs = data.map(d => d.high || d.value);
           const lows = data.map(d => d.low || d.value);
           const volumes = data.map(d => d.volume || 0);
           
           // Calculate indicators
           const sma20 = calculateSMA(closes, 20);
           const sma50 = calculateSMA(closes, 50);
           const ema12 = calculateEMA(closes, 12);
           const ema26 = calculateEMA(closes, 26);
           const rsi = calculateRSI(closes);
           const macd = calculateMACD(closes);
           const bollinger = calculateBollingerBands(closes);
           const stochastic = calculateStochastic(highs, lows, closes);
           const atr = calculateATR(highs, lows, closes);
           const vwap = calculateVWAP(closes, volumes);
           
           return data.map((item, index) => ({
               ...item,
               sma20: sma20[index],
               sma50: sma50[index],
               ema12: ema12[index],
               ema26: ema26[index],
               rsi: rsi[index],
               macd: macd.macd[index],
               macd_signal: macd.signal[index],
               macd_histogram: macd.histogram[index],
               bollinger_upper: bollinger.upper[index],
               bollinger_middle: bollinger.middle[index],
               bollinger_lower: bollinger.lower[index],
               stochastic_k: stochastic.k[index],
               stochastic_d: stochastic.d[index],
               atr: atr[index],
               vwap: vwap[index]
           }));
       }
       
       // Technical indicator calculations
       function calculateSMA(prices, period) {
           const sma = [];
           for (let i = 0; i < prices.length; i++) {
               if (i < period - 1) {
                   sma.push(null);
               } else {
                   const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                   sma.push(sum / period);
               }
           }
           return sma;
       }
       
       function calculateEMA(prices, period) {
           const ema = [];
           const multiplier = 2 / (period + 1);
           
           if (prices.length < period) {
               return new Array(prices.length).fill(null);
           }
           
           let sum = 0;
           for (let i = 0; i < period; i++) {
               sum += prices[i];
               ema.push(null);
           }
           
           let previousEMA = sum / period;
           ema[period - 1] = previousEMA;
           
           for (let i = period; i < prices.length; i++) {
               const currentEMA = (prices[i] - previousEMA) * multiplier + previousEMA;
               ema.push(currentEMA);
               previousEMA = currentEMA;
           }
           
           return ema;
       }
       
       function calculateRSI(prices, period = 14) {
           const rsiValues = [];
           
           for (let i = 0; i < period; i++) {
               rsiValues.push(null);
           }
           
           if (prices.length > period) {
               let gains = [];
               let losses = [];
               
               for (let i = 1; i <= period; i++) {
                   const change = prices[i] - prices[i - 1];
                   gains.push(change > 0 ? change : 0);
                   losses.push(change < 0 ? -change : 0);
               }
               
               let avgGain = gains.reduce((sum, gain) => sum + gain, 0) / period;
               let avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / period;
               
               let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
               let rsi = 100 - (100 / (1 + rs));
               rsiValues.push(rsi);
               
               for (let i = period + 1; i < prices.length; i++) {
                   const change = prices[i] - prices[i - 1];
                   const gain = change > 0 ? change : 0;
                   const loss = change < 0 ? -change : 0;
                   
                   avgGain = (avgGain * (period - 1) + gain) / period;
                   avgLoss = (avgLoss * (period - 1) + loss) / period;
                   
                   rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                   rsi = 100 - (100 / (1 + rs));
                   rsiValues.push(rsi);
               }
           }
           
           return rsiValues;
       }
       
       function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
           const ema12 = calculateEMA(prices, fastPeriod);
           const ema26 = calculateEMA(prices, slowPeriod);
           const macdLine = [];
           
           for (let i = 0; i < prices.length; i++) {
               if (ema12[i] !== null && ema26[i] !== null) {
                   macdLine.push(ema12[i] - ema26[i]);
               } else {
                   macdLine.push(null);
               }
           }
           
           const validMacd = macdLine.filter(v => v !== null);
           const signalLine = calculateEMA(validMacd, signalPeriod);
           const histogram = [];
           
           let signalIndex = 0;
           for (let i = 0; i < macdLine.length; i++) {
               if (macdLine[i] !== null && signalIndex < signalLine.length && signalLine[signalIndex] !== null) {
                   histogram.push(macdLine[i] - signalLine[signalIndex]);
                   signalIndex++;
               } else {
                   histogram.push(null);
               }
           }
           
           // Pad signal line to match length
           const paddedSignal = new Array(prices.length).fill(null);
           signalIndex = 0;
           for (let i = 0; i < prices.length; i++) {
               if (macdLine[i] !== null && signalIndex < signalLine.length) {
                   paddedSignal[i] = signalLine[signalIndex++];
               }
           }
           
           return {
               macd: macdLine,
               signal: paddedSignal,
               histogram: histogram
           };
       }
       
       function calculateBollingerBands(prices, period = 20, stdDev = 2) {
           const sma = calculateSMA(prices, period);
           const upper = [];
           const lower = [];
           
           for (let i = 0; i < prices.length; i++) {
               if (i < period - 1) {
                   upper.push(null);
                   lower.push(null);
               } else {
                   const slice = prices.slice(i - period + 1, i + 1);
                   const mean = sma[i];
                   const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
                   const std = Math.sqrt(variance);
                   
                   upper.push(mean + (stdDev * std));
                   lower.push(mean - (stdDev * std));
               }
           }
           
           return {
               upper: upper,
               middle: sma,
               lower: lower
           };
       }
       
       function calculateStochastic(highs, lows, closes, kPeriod = 14, dPeriod = 3) {
           const kValues = [];
           const dValues = [];
           
           for (let i = 0; i < closes.length; i++) {
               if (i < kPeriod - 1) {
                   kValues.push(null);
               } else {
                   const highSlice = highs.slice(i - kPeriod + 1, i + 1);
                   const lowSlice = lows.slice(i - kPeriod + 1, i + 1);
                   
                   const lowestLow = Math.min(...lowSlice);
                   const highestHigh = Math.max(...highSlice);
                   
                   const k = ((closes[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
                   kValues.push(k);
               }
           }
           
           for (let i = 0; i < kValues.length; i++) {
               if (i < dPeriod - 1 || kValues[i] === null) {
                   dValues.push(null);
               } else {
                   const validKs = kValues.slice(i - dPeriod + 1, i + 1).filter(v => v !== null);
                   if (validKs.length === dPeriod) {
                       dValues.push(validKs.reduce((a, b) => a + b, 0) / dPeriod);
                   } else {
                       dValues.push(null);
                   }
               }
           }
           
           return { k: kValues, d: dValues };
       }
       
       function calculateATR(highs, lows, closes, period = 14) {
           const trueRanges = [];
           
           for (let i = 0; i < highs.length; i++) {
               if (i === 0) {
                   trueRanges.push(highs[i] - lows[i]);
               } else {
                   const highLow = highs[i] - lows[i];
                   const highClose = Math.abs(highs[i] - closes[i - 1]);
                   const lowClose = Math.abs(lows[i] - closes[i - 1]);
                   trueRanges.push(Math.max(highLow, highClose, lowClose));
               }
           }
           
           return calculateSMA(trueRanges, period);
       }
       
       function calculateVWAP(prices, volumes) {
           const vwap = [];
           let cumulativePV = 0;
           let cumulativeVolume = 0;
           
           for (let i = 0; i < prices.length; i++) {
               cumulativePV += prices[i] * (volumes[i] || 1);
               cumulativeVolume += (volumes[i] || 1);
               vwap.push(cumulativePV / cumulativeVolume);
           }
           
           return vwap;
       }
       
       function calculateCurrentTechnicals(data) {
           const last = data[data.length - 1];
           const prices = data.map(d => d.value);
           
           // Calculate volatility (standard deviation)
           const returns = [];
           for (let i = 1; i < prices.length; i++) {
               returns.push((prices[i] - prices[i-1]) / prices[i-1]);
           }
           const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
           const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
           const volatility = Math.sqrt(variance) * Math.sqrt(252) * 100; // Annualized
           
           return {
               rsi: last.rsi,
               macd: last.macd,
               macd_signal: last.macd_signal,
               stochastic_k: last.stochastic_k,
               stochastic_d: last.stochastic_d,
               volatility: volatility
           };
       }
       
       // Calculate percentage changes
       function calculatePercentageChanges(historical) {
           const mom = [];
           const qoq = [];
           const yoy = [];
           
           for (let i = 0; i < historical.length; i++) {
               const current = historical[i];
               
               // Month-over-month
               if (i >= 1) {
                   const prev = historical[i - 1];
                   const change = ((current.value - prev.value) / prev.value) * 100;
                   mom.push({
                       date: current.date,
                       value: change
                   });
               }
               
               // Quarter-over-quarter (3 months)
               if (i >= 3) {
                   const prev = historical[i - 3];
                   const change = ((current.value - prev.value) / prev.value) * 100;
                   qoq.push({
                       date: current.date,
                       value: change
                   });
               }
               
               // Year-over-year (12 months)
               if (i >= 12) {
                   const prev = historical[i - 12];
                   const change = ((current.value - prev.value) / prev.value) * 100;
                   yoy.push({
                       date: current.date,
                       value: change
                   });
               }
           }
           
           return { mom, qoq, yoy };
       }
       
       // Generate realistic historical data (fallback only)
       function generateRealisticHistoricalData(currentValue, symbol) {
           const data = [];
           const endDate = new Date();
           const startDate = new Date('1990-01-01');
           
           // Monthly data points
           let date = new Date(startDate);
           let prevValue = currentValue * 0.3;
           
           while (date <= endDate) {
               const yearsFromStart = (date - startDate) / (365 * 24 * 60 * 60 * 1000);
               const progress = yearsFromStart / ((endDate - startDate) / (365 * 24 * 60 * 60 * 1000));
               
               // Base trend
               let value = currentValue * (0.3 + 0.7 * progress);
               
               // Add realistic volatility
               const volatility = symbol.includes('VIX') ? 0.3 : 0.05;
               value *= (1 + (Math.random() - 0.5) * volatility);
               
               // Smooth transitions
               value = prevValue * 0.9 + value * 0.1;
               prevValue = value;
               
               // Crisis periods
               const year = date.getFullYear();
               const month = date.getMonth();
               
               if (year === 2008 && month >= 8 && month <= 11) {
                   if (symbol.includes('VIX') || symbol.includes('STRESS') || symbol.includes('CMDI')) {
                       value *= 2.5;
                   }
               }
               
               if (year === 2020 && month >= 2 && month <= 4) {
                   if (symbol.includes('VIX') || symbol.includes('STRESS') || symbol.includes('CMDI')) {
                       value *= 2;
                   }
               }
               
               data.push({
                   date: date.toISOString().split('T')[0],
                   value: value,
                   open: value * 0.99,
                   high: value * 1.01,
                   low: value * 0.98,
                   close: value,
                   volume: Math.random() * 1000000
               });
               
               date.setMonth(date.getMonth() + 1);
           }
           
           // Ensure last value matches current
           if (data.length > 0) {
               data[data.length - 1].value = currentValue;
               data[data.length - 1].close = currentValue;
           }
           
           return data;
       }
       
       // Detect trend reversals
       function detectTrendReversal(data) {
           if (!data || data.length < 3) return false;
           
           const last3 = data.slice(-3);
           const prev = last3[0].value;
           const mid = last3[1].value;
           const current = last3[2].value;
           
           if (prev < 0 && mid < 0 && current > 0) return 'bullish';
           if (prev > 0 && mid > 0 && current < 0) return 'bearish';
           if (prev < mid && mid > current) return 'peak';
           if (prev > mid && mid < current) return 'trough';
           
           return false;
       }
       
       // Set chart style (line vs candlestick)
       function setChartStyle(style) {
           chartStyle = style;
           
           document.querySelectorAll('.style-btn').forEach(btn => {
               btn.classList.remove('active');
           });
           event.target.classList.add('active');
           
           if (selectedIndicator) {
               plotChart(selectedIndicator);
           }
       }
       
       // Enhanced chart type setter
       function setChartType(type) {
           chartType = type;
           
           document.querySelectorAll('.toggle-btn').forEach(btn => {
               btn.classList.remove('active');
           });
           event.target.classList.add('active');
           
           // Show/hide technical indicators legend
           const techLegend = document.getElementById('techLegend');
           if (['rsi', 'macd', 'bollinger', 'stochastic', 'volume'].includes(type)) {
               techLegend.style.display = 'flex';
           } else {
               techLegend.style.display = 'none';
           }
           
           if (selectedIndicator) {
               plotChart(selectedIndicator);
           }
       }
       
       // Toggle chart overlays
       function toggleOverlay(overlay) {
           chartOverlays[overlay] = !chartOverlays[overlay];
           document.getElementById(`${overlay}Toggle`).classList.toggle('active');
           
           if (selectedIndicator) {
               plotChart(selectedIndicator);
           }
       }
       
       // Set comparison mode
       function setCompareMode(mode) {
           compareMode = mode;
           
           document.querySelectorAll('.chart-option-group button').forEach(btn => {
               if (btn.id.startsWith('compare')) {
                   btn.classList.remove('active');
               }
           });
           document.getElementById(`compare${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
           
           if (selectedIndicator) {
               plotChart(selectedIndicator);
           }
       }
       
       // Toggle trend detection
       function toggleTrendDetection() {
           trendDetectionEnabled = !trendDetectionEnabled;
           document.getElementById('trendToggle').classList.toggle('active');
           
           if (selectedIndicator && trendDetectionEnabled) {
               const trendSignal = trendSignals[selectedIndicator];
               if (trendSignal) {
                   showTrendAlert(trendSignal);
               }
               plotChart(selectedIndicator);
           } else {
               document.getElementById('trendAlert').classList.remove('active');
           }
       }
       
       // Show trend alert
       function showTrendAlert(signal) {
           if (!signal) return;
           
           const alertDiv = document.getElementById('trendAlert');
           const contentDiv = document.getElementById('trendAlertContent');
           
           alertDiv.className = 'trend-alert active ' + signal.type;
           
           let icon = signal.type === 'bullish' ? '🟢' : signal.type === 'bearish' ? '🔴' : '🟡';
           contentDiv.innerHTML = `
               ${icon} <strong>${signal.type.toUpperCase()} Signal Detected</strong><br>
               <small>Indicators: ${signal.indicators}</small><br>
               <small>Confidence: ${signal.confidence.toFixed(1)}%</small><br>
               <small>Strength: ${signal.strength}</small>
           `;
       }
       
       // Toggle chart theme
       function toggleChartTheme() {
           chartTheme = chartTheme === 'dark' ? 'light' : 'dark';
           if (selectedIndicator) {
               plotChart(selectedIndicator);
           }
       }
       
       // Create inline sparkline chart
       function createSparkline(symbol, data) {
           const last30 = data.slice(-30);
           
           const trace = {
               x: last30.map(d => d.date),
               y: last30.map(d => d.value),
               type: 'scatter',
               mode: 'lines',
               line: {
                   color: last30[last30.length - 1].value > last30[0].value ? '#00ff88' : '#ff4444',
                   width: 1
               },
               showlegend: false
           };
           
           const layout = {
               margin: { t: 0, r: 0, b: 0, l: 0 },
               xaxis: { visible: false },
               yaxis: { visible: false },
               paper_bgcolor: 'transparent',
               plot_bgcolor: 'transparent',
               hovermode: false
           };
           
           const config = {
               displayModeBar: false,
               staticPlot: true
           };
           
           Plotly.newPlot(`sparkline-${symbol}`, [trace], layout, config);
       }
       
       // Update watchlist display with editable names and trend signals
       function updateWatchlistDisplay() {
           const content = document.getElementById('watchlistContent');
           
           if (watchlist.length === 0) {
               content.innerHTML = `
                   <div class="empty-watchlist">
                       <div class="empty-watchlist-icon">📊</div>
                       <div>Your watchlist is empty</div>
                       <div style="margin-top: 0.5rem; font-size: 0.875rem;">Search and add indicators to track real-time data</div>
                   </div>
               `;
               return;
           }
           
           let tableHTML = `
               <table class="watchlist-table">
                   <thead>
                       <tr>
                           <th>Indicator</th>
                           <th>Chart</th>
                           <th>Current Value</th>
                           <th>MoM %</th>
                           <th>QoQ %</th>
                           <th>YoY %</th>
                           <th>RSI</th>
                           <th>Trend Signal</th>
                           <th>Source</th>
                           <th>Action</th>
                       </tr>
                   </thead>
                   <tbody>`;
           
           watchlist.forEach((item, index) => {
               const trendSignal = item.trendSignal;
               let trendBadge = '';
               
               if (trendSignal) {
                   const signalClass = trendSignal.type;
                   const signalText = trendSignal.type === 'bullish' ? 'BULL' : 
                                     trendSignal.type === 'bearish' ? 'BEAR' : 'DIV';
                   trendBadge = `<span class="trend-signal ${signalClass}">${signalText}</span>`;
               }
               
               tableHTML += `
                   <tr class="watchlist-row ${selectedIndicator === item.symbol ? 'selected' : ''}" data-symbol="${item.symbol}">
                       <td>
                           <div class="indicator-name" 
                                contenteditable="true" 
                                data-index="${index}">${item.customName}</div>
                           <div class="indicator-symbol">${item.symbol}</div>
                       </td>
                       <td>
                           <div id="sparkline-${item.symbol}" class="inline-chart"></div>
                       </td>
                       <td class="value-cell">${formatValue(item.currentValue)}</td>
                       <td>
                           <div class="change-value ${item.monthChange >= 0 ? 'positive' : 'negative'}">
                               ${item.monthChange >= 0 ? '↑' : '↓'} ${Math.abs(item.monthChange).toFixed(2)}%
                           </div>
                       </td>
                       <td>
                           <div class="change-value ${item.quarterChange >= 0 ? 'positive' : 'negative'}">
                               ${item.quarterChange >= 0 ? '↑' : '↓'} ${Math.abs(item.quarterChange).toFixed(2)}%
                           </div>
                       </td>
                       <td>
                           <div class="change-value ${item.yearChange >= 0 ? 'positive' : 'negative'}">
                               ${item.yearChange >= 0 ? '↑' : '↓'} ${Math.abs(item.yearChange).toFixed(2)}%
                           </div>
                       </td>
                       <td class="${item.rsi > 70 ? 'negative' : item.rsi < 30 ? 'positive' : 'neutral'}">
                           ${item.rsi ? item.rsi.toFixed(1) : '--'}
                       </td>
                       <td>${trendBadge}</td>
                       <td>${item.api}</td>
                       <td>
                           <button class="remove-btn" data-index="${index}">Remove</button>
                       </td>
                   </tr>`;
           });
           
           tableHTML += `
                   </tbody>
               </table>`;
           
           content.innerHTML = tableHTML;
           
           // Add event listeners after the HTML is inserted
           setupWatchlistEventListeners();
           
           // Create sparklines for each item
           setTimeout(() => {
               watchlist.forEach(item => {
                   if (historicalData[item.symbol]) {
                       createSparkline(item.symbol, historicalData[item.symbol]);
                   }
               });
           }, 100);
       }
       
       // Setup event listeners for watchlist
       function setupWatchlistEventListeners() {
           // Click to select indicator
           document.querySelectorAll('.watchlist-row').forEach(row => {
               row.addEventListener('click', function(e) {
                   // Don't trigger if clicking on editable name or remove button
                   if (e.target.classList.contains('indicator-name') || 
                       e.target.classList.contains('remove-btn')) {
                       return;
                   }
                   const symbol = this.dataset.symbol;
                   selectIndicator(symbol);
               });
           });
           
           // Editable names
           document.querySelectorAll('.indicator-name').forEach(nameElement => {
               nameElement.addEventListener('focus', function() {
                   this.classList.add('editing');
               });
               
               nameElement.addEventListener('blur', function() {
                   this.classList.remove('editing');
                   const index = parseInt(this.dataset.index);
                   updateIndicatorName(index, this.textContent);
               });
               
               nameElement.addEventListener('keydown', function(e) {
                   if (e.key === 'Enter') {
                       e.preventDefault();
                       this.blur();
                   }
               });
               
               // Prevent row click when clicking on name
               nameElement.addEventListener('click', function(e) {
                   e.stopPropagation();
               });
           });
           
           // Remove buttons
           document.querySelectorAll('.remove-btn').forEach(btn => {
               btn.addEventListener('click', function(e) {
                   e.stopPropagation();
                   const index = parseInt(this.dataset.index);
                   removeFromWatchlist(index);
               });
           });
       }
       
       // Update indicator custom name
       function updateIndicatorName(index, newName) {
           if (watchlist[index]) {
               watchlist[index].customName = newName.trim() || watchlist[index].name;
               saveWatchlistToStorage();
           }
       }
       
       // Select indicator
       function selectIndicator(symbol) {
           selectedIndicator = symbol;
           updateWatchlistDisplay();
           
           const indicator = watchlist.find(item => item.symbol === symbol);
           if (!indicator) return;
           
           document.getElementById('chartTitle').textContent = `${indicator.customName} (${indicator.symbol})`;
           document.getElementById('chartStats').style.display = 'grid';
           
           // Show trend alert if enabled
           if (trendDetectionEnabled && indicator.trendSignal) {
               showTrendAlert(indicator.trendSignal);
           } else {
               document.getElementById('trendAlert').classList.remove('active');
           }
           
           updateChartStats(indicator);
           plotChart(symbol);
       }
       
       // Update chart statistics
       function updateChartStats(indicator) {
           const historical = historicalData[indicator.symbol];
           if (!historical) return;
           
           // Current value
           document.getElementById('currentValue').textContent = formatValue(indicator.currentValue);
           
           // Calculate 52-week high/low
           const last52w = historical.slice(-52); // 52 weeks of monthly data
           const high52w = Math.max(...last52w.map(d => d.value));
           const low52w = Math.min(...last52w.map(d => d.value));
           
           document.getElementById('high52w').textContent = formatValue(high52w);
           document.getElementById('low52w').textContent = formatValue(low52w);
           
           // Current RSI
           document.getElementById('currentRSI').textContent = indicator.rsi ? indicator.rsi.toFixed(1) : '--';
           
           // Volatility
           document.getElementById('volatility').textContent = indicator.volatility ? indicator.volatility.toFixed(2) + '%' : '--';
           
           // Percentage changes with trend indicators
           const changes = percentageChangeData[indicator.symbol];
           if (!changes) return;
           
           // MoM
           const momEl = document.getElementById('momChange');
           const momValue = indicator.monthChange;
           momEl.textContent = `${momValue >= 0 ? '+' : ''}${momValue.toFixed(2)}%`;
           momEl.className = `stat-value ${momValue >= 0 ? 'positive' : 'negative'}`;
           
           const momReversal = detectTrendReversal(changes.mom);
           const momTrendEl = document.getElementById('momTrend');
           if (momReversal) {
               momTrendEl.innerHTML = `<span class="trend-indicator trend-reversal">Reversal: ${momReversal}</span>`;
           } else {
               momTrendEl.innerHTML = '';
           }
           
           // QoQ
           const qoqEl = document.getElementById('qoqChange');
           const qoqValue = indicator.quarterChange;
           qoqEl.textContent = `${qoqValue >= 0 ? '+' : ''}${qoqValue.toFixed(2)}%`;
           qoqEl.className = `stat-value ${qoqValue >= 0 ? 'positive' : 'negative'}`;
           
           const qoqReversal = detectTrendReversal(changes.qoq);
           const qoqTrendEl = document.getElementById('qoqTrend');
           if (qoqReversal) {
               qoqTrendEl.innerHTML = `<span class="trend-indicator trend-reversal">Reversal: ${qoqReversal}</span>`;
           } else {
               qoqTrendEl.innerHTML = '';
           }
           
           // YoY
           const yoyEl = document.getElementById('yoyChange');
           const yoyValue = indicator.yearChange;
           yoyEl.textContent = `${yoyValue >= 0 ? '+' : ''}${yoyValue.toFixed(2)}%`;
           yoyEl.className = `stat-value ${yoyValue >= 0 ? 'positive' : 'negative'}`;
           
           const yoyReversal = detectTrendReversal(changes.yoy);
           const yoyTrendEl = document.getElementById('yoyTrend');
           if (yoyReversal) {
               yoyTrendEl.innerHTML = `<span class="trend-indicator trend-reversal">Reversal: ${yoyReversal}</span>`;
           } else {
               yoyTrendEl.innerHTML = '';
           }
       }
       
       // Enhanced plotting with line/candlestick/area styles and trend markers
       function plotChart(symbol) {
           const historical = historicalData[symbol];
           const changes = percentageChangeData[symbol];
           
           if (!historical || !changes) return;
           
           const indicator = watchlist.find(item => item.symbol === symbol);
           const traces = [];
           
           // Apply comparison mode transformation
           let processedData = [...historical];
           if (compareMode === 'percent' && processedData.length > 0) {
               const firstValue = processedData[0].value;
               processedData = processedData.map(d => ({
                   ...d,
                   value: ((d.value - firstValue) / firstValue) * 100,
                   open: ((d.open - firstValue) / firstValue) * 100,
                   high: ((d.high - firstValue) / firstValue) * 100,
                   low: ((d.low - firstValue) / firstValue) * 100,
                   close: ((d.close - firstValue) / firstValue) * 100
               }));
           } else if (compareMode === 'indexed' && processedData.length > 0) {
               const firstValue = processedData[0].value;
               processedData = processedData.map(d => ({
                   ...d,
                   value: (d.value / firstValue) * 100,
                   open: (d.open / firstValue) * 100,
                   high: (d.high / firstValue) * 100,
                   low: (d.low / firstValue) * 100,
                   close: (d.close / firstValue) * 100
               }));
           }
           
           // Main chart based on type
           if (chartType === 'levels') {
               // Use the selected chart style
               if (chartStyle === 'candlestick') {
                   traces.push({
                       x: processedData.map(d => d.date),
                       open: processedData.map(d => d.open),
                       high: processedData.map(d => d.high),
                       low: processedData.map(d => d.low),
                       close: processedData.map(d => d.close),
                       type: 'candlestick',
                       name: indicator.customName,
                       increasing: { line: { color: '#00ff88' } },
                       decreasing: { line: { color: '#ff4444' } }
                   });
               } else if (chartStyle === 'area') {
                   traces.push({
                       x: processedData.map(d => d.date),
                       y: processedData.map(d => d.value),
                       type: 'scatter',
                       mode: 'lines',
                       name: indicator.customName,
                       line: { color: '#00ff88', width: 2 },
                       fill: 'tozeroy',
                       fillcolor: 'rgba(0, 255, 136, 0.1)'
                   });
               } else {
                   // Default line chart
                   traces.push({
                       x: processedData.map(d => d.date),
                       y: processedData.map(d => d.value),
                       type: 'scatter',
                       mode: 'lines',
                       name: indicator.customName,
                       line: { color: '#00ff88', width: 2 }
                   });
               }
               
               // Add trend reversal markers if enabled
               if (trendDetectionEnabled) {
                   const reversalPoints = [];
                   for (let i = 20; i < processedData.length - 1; i++) {
                       const subset = processedData.slice(i - 20, i + 1);
                       const signal = detectEarlyTrendReversal(subset);
                       if (signal && signal.confidence > 60) {
                           reversalPoints.push({
                               x: processedData[i].date,
                               y: processedData[i].value,
                               type: signal.type
                           });
                       }
                   }
                   
                   if (reversalPoints.length > 0) {
                       traces.push({
                           x: reversalPoints.map(p => p.x),
                           y: reversalPoints.map(p => p.y),
                           mode: 'markers',
                           name: 'Trend Signals',
                           marker: {
                               size: 12,
                               color: reversalPoints.map(p => p.type === 'bullish' ? '#00ff88' : '#ff4444'),
                               symbol: reversalPoints.map(p => p.type === 'bullish' ? 'triangle-up' : 'triangle-down')
                           }
                       });
                   }
               }
               
               // Add overlays if enabled
               if (chartOverlays.sma && processedData[0].sma20) {
                   traces.push({
                       x: processedData.map(d => d.date),
                       y: processedData.map(d => d.sma20),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'SMA 20',
                       line: { color: '#00ccff', width: 1, dash: 'dash' }
                   });
               }
               
               if (chartOverlays.ema && processedData[0].ema12) {
                   traces.push({
                       x: processedData.map(d => d.date),
                       y: processedData.map(d => d.ema12),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'EMA 12',
                       line: { color: '#ffaa00', width: 1, dash: 'dot' }
                   });
               }
               
               if (chartOverlays.vwap && processedData[0].vwap) {
                   traces.push({
                       x: processedData.map(d => d.date),
                       y: processedData.map(d => d.vwap),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'VWAP',
                       line: { color: '#ff00ff', width: 1, dash: 'dashdot' }
                   });
               }
               
           } else if (chartType === 'mom') {
               traces.push({
                   x: changes.mom.map(d => d.date),
                   y: changes.mom.map(d => d.value),
                   type: 'bar',
                   name: 'MoM % Change',
                   marker: {
                       color: changes.mom.map(d => d.value >= 0 ? '#00ff88' : '#ff4444')
                   }
               });
               
           } else if (chartType === 'qoq') {
               traces.push({
                   x: changes.qoq.map(d => d.date),
                   y: changes.qoq.map(d => d.value),
                   type: 'bar',
                   name: 'QoQ % Change',
                   marker: {
                       color: changes.qoq.map(d => d.value >= 0 ? '#00ff88' : '#ff4444')
                   }
               });
               
           } else if (chartType === 'yoy') {
               traces.push({
                   x: changes.yoy.map(d => d.date),
                   y: changes.yoy.map(d => d.value),
                   type: 'bar',
                   name: 'YoY % Change',
                   marker: {
                       color: changes.yoy.map(d => d.value >= 0 ? '#00ff88' : '#ff4444')
                   }
               });
               
           } else if (chartType === 'combined') {
               traces.push({
                   x: changes.mom.map(d => d.date),
                   y: changes.mom.map(d => d.value),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'MoM %',
                   line: { color: '#00ff88', width: 2 }
               });
               
               traces.push({
                   x: changes.qoq.map(d => d.date),
                   y: changes.qoq.map(d => d.value),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'QoQ %',
                   line: { color: '#00ccff', width: 2 }
               });
               
               traces.push({
                   x: changes.yoy.map(d => d.date),
                   y: changes.yoy.map(d => d.value),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'YoY %',
                   line: { color: '#ffaa00', width: 2 }
               });
               
           } else if (chartType === 'rsi') {
               const rsiData = processedData.filter(d => d.rsi !== null && d.rsi !== undefined);
               
               traces.push({
                   x: rsiData.map(d => d.date),
                   y: rsiData.map(d => d.rsi),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'RSI',
                   line: { color: '#00ff88', width: 2 }
               });
               
               // Overbought/Oversold lines
               traces.push({
                   x: rsiData.map(d => d.date),
                   y: new Array(rsiData.length).fill(70),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Overbought',
                   line: { color: '#ff4444', width: 1, dash: 'dash' },
                   showlegend: false
               });
               
               traces.push({
                   x: rsiData.map(d => d.date),
                   y: new Array(rsiData.length).fill(30),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Oversold',
                   line: { color: '#00ff88', width: 1, dash: 'dash' },
                   showlegend: false
               });
               
           } else if (chartType === 'macd') {
               const macdData = processedData.filter(d => d.macd !== null && d.macd !== undefined);
               
               traces.push({
                   x: macdData.map(d => d.date),
                   y: macdData.map(d => d.macd),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'MACD',
                   line: { color: '#00ff88', width: 2 }
               });
               
               traces.push({
                   x: macdData.map(d => d.date),
                   y: macdData.map(d => d.macd_signal),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Signal',
                   line: { color: '#ff7043', width: 1, dash: 'dash' }
               });
               
               traces.push({
                   x: macdData.map(d => d.date),
                   y: macdData.map(d => d.macd_histogram),
                   type: 'bar',
                   name: 'Histogram',
                   marker: {
                       color: macdData.map(d => (d.macd_histogram || 0) > 0 ? '#00ff88' : '#ff4444')
                   }
               });
               
           } else if (chartType === 'bollinger') {
               traces.push({
                   x: processedData.map(d => d.date),
                   y: processedData.map(d => d.value),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Price',
                   line: { color: '#00ff88', width: 2 }
               });
               
               const bollingerData = processedData.filter(d => d.bollinger_upper !== null);
               
               if (bollingerData.length > 0) {
                   traces.push({
                       x: bollingerData.map(d => d.date),
                       y: bollingerData.map(d => d.bollinger_upper),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'Upper Band',
                       line: { color: '#00ccff', width: 1, dash: 'dash' },
                       fill: 'tonexty',
                       fillcolor: 'rgba(0, 204, 255, 0.1)'
                   });
                   
                   traces.push({
                       x: bollingerData.map(d => d.date),
                       y: bollingerData.map(d => d.bollinger_middle),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'Middle Band',
                       line: { color: '#ffaa00', width: 1, dash: 'dot' }
                   });
                   
                   traces.push({
                       x: bollingerData.map(d => d.date),
                       y: bollingerData.map(d => d.bollinger_lower),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'Lower Band',
                       line: { color: '#00ccff', width: 1, dash: 'dash' },
                       fill: 'tonexty',
                       fillcolor: 'rgba(0, 204, 255, 0.1)'
                   });
               }
               
           } else if (chartType === 'stochastic') {
               const stochData = processedData.filter(d => d.stochastic_k !== null && d.stochastic_k !== undefined);
               
               traces.push({
                   x: stochData.map(d => d.date),
                   y: stochData.map(d => d.stochastic_k),
                   type: 'scatter',
                   mode: 'lines',
                   name: '%K',
                   line: { color: '#00ff88', width: 2 }
               });
               
               traces.push({
                   x: stochData.map(d => d.date),
                   y: stochData.map(d => d.stochastic_d),
                   type: 'scatter',
                   mode: 'lines',
                   name: '%D',
                   line: { color: '#ff7043', width: 1, dash: 'dash' }
               });
               
               // Overbought/Oversold lines
               traces.push({
                   x: stochData.map(d => d.date),
                   y: new Array(stochData.length).fill(80),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Overbought',
                   line: { color: '#ff4444', width: 1, dash: 'dash' },
                   showlegend: false
               });
               
               traces.push({
                   x: stochData.map(d => d.date),
                   y: new Array(stochData.length).fill(20),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Oversold',
                   line: { color: '#00ff88', width: 1, dash: 'dash' },
                   showlegend: false
               });
               
           } else if (chartType === 'volume') {
               // Price on primary axis
               traces.push({
                   x: processedData.map(d => d.date),
                   y: processedData.map(d => d.value),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Price',
                   line: { color: '#00ff88', width: 2 },
                   yaxis: 'y'
               });
               
               // Volume bars on secondary axis
               traces.push({
                   x: processedData.map(d => d.date),
                   y: processedData.map(d => d.volume),
                   type: 'bar',
                   name: 'Volume',
                   marker: { color: 'rgba(0, 255, 136, 0.3)' },
                   yaxis: 'y2'
               });
           }
           
           // Add zero line for percentage charts
           if (['mom', 'qoq', 'yoy', 'combined'].includes(chartType)) {
               const dates = chartType === 'combined' ? (changes.yoy.length > 0 ? changes.yoy.map(d => d.date) : []) : 
                             chartType === 'mom' ? changes.mom.map(d => d.date) :
                             chartType === 'qoq' ? changes.qoq.map(d => d.date) :
                             changes.yoy.map(d => d.date);
               
               if (dates.length > 0) {
                   traces.push({
                       x: dates,
                       y: new Array(dates.length).fill(0),
                       type: 'scatter',
                       mode: 'lines',
                       name: 'Zero Line',
                       line: { color: '#888', width: 1, dash: 'dash' },
                       showlegend: false
                   });
               }
           }
           
           // Create layout
           const bgColor = chartTheme === 'dark' ? 'rgba(0, 0, 0, 0)' : '#ffffff';
           const gridColor = chartTheme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
           const textColor = chartTheme === 'dark' ? '#fff' : '#000';
           
           const layout = {
               paper_bgcolor: bgColor,
               plot_bgcolor: chartTheme === 'dark' ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.9)',
               font: { color: textColor },
               xaxis: {
                   gridcolor: gridColor,
                   tickfont: { color: chartTheme === 'dark' ? '#888' : '#666' },
                   rangeslider: { visible: (chartType === 'levels' && chartStyle !== 'area') }
               },
               yaxis: {
                   gridcolor: gridColor,
                   tickfont: { color: chartTheme === 'dark' ? '#888' : '#666' },
                   title: getYAxisTitle(),
                   zeroline: ['mom', 'qoq', 'yoy', 'combined', 'macd'].includes(chartType),
                   zerolinecolor: 'rgba(255, 255, 255, 0.3)'
               },
               margin: { t: 20, r: 20, b: 50, l: 60 },
               hovermode: 'x unified',
               showlegend: true,
               legend: {
                   bgcolor: 'rgba(0, 0, 0, 0.5)',
                   bordercolor: '#333',
                   borderwidth: 1
               }
           };
           
           // Add secondary axis for volume chart
           if (chartType === 'volume') {
               layout.yaxis2 = {
                   title: 'Volume',
                   overlaying: 'y',
                   side: 'right',
                   showgrid: false
               };
           }
           
           Plotly.newPlot('mainChart', traces, layout, {responsive: true});
       }
       
       function getYAxisTitle() {
           const titles = {
               'levels': compareMode === 'percent' ? '% Change from Start' : 
                         compareMode === 'indexed' ? 'Indexed (100 = Start)' : 'Value',
               'candlestick': 'Price',
               'mom': 'Month-over-Month %',
               'qoq': 'Quarter-over-Quarter %',
               'yoy': 'Year-over-Year %',
               'combined': '% Change',
               'rsi': 'RSI',
               'macd': 'MACD',
               'bollinger': 'Price',
               'stochastic': 'Stochastic %',
               'volume': 'Price'
           };
           return titles[chartType] || 'Value';
       }
       
       // Initialize chart
       function initializeChart() {
           const layout = {
               paper_bgcolor: 'rgba(0, 0, 0, 0)',
               plot_bgcolor: 'rgba(0, 0, 0, 0.3)',
               font: { color: '#fff' },
               xaxis: {
                   gridcolor: 'rgba(255, 255, 255, 0.1)',
                   tickfont: { color: '#888' }
               },
               yaxis: {
                   gridcolor: 'rgba(255, 255, 255, 0.1)',
                   tickfont: { color: '#888' }
               },
               margin: { t: 20, r: 20, b: 50, l: 60 }
           };
           
           Plotly.newPlot('mainChart', [], layout, {responsive: true});
       }
       
       // Setup chart controls
       function setupChartControls() {
           document.querySelectorAll('.chart-btn[data-range]').forEach(btn => {
               btn.addEventListener('click', function() {
                   document.querySelectorAll('.chart-btn[data-range]').forEach(b => b.classList.remove('active'));
                   this.classList.add('active');
                   
                   const range = this.dataset.range;
                   updateChartRange(range);
               });
           });
       }
       
       // Update chart range
       function updateChartRange(range) {
           if (!selectedIndicator || !historicalData[selectedIndicator]) return;
           
           const data = historicalData[selectedIndicator];
           const endDate = new Date(data[data.length - 1].date);
           let startDate = new Date(data[0].date);
           
           switch(range) {
               case '1M':
                   startDate = new Date(endDate);
                   startDate.setMonth(startDate.getMonth() - 1);
                   break;
               case '3M':
                   startDate = new Date(endDate);
                   startDate.setMonth(startDate.getMonth() - 3);
                   break;
               case '6M':
                   startDate = new Date(endDate);
                   startDate.setMonth(startDate.getMonth() - 6);
                   break;
               case 'YTD':
                   startDate = new Date(endDate.getFullYear(), 0, 1);
                   break;
               case '1Y':
                   startDate = new Date(endDate);
                   startDate.setFullYear(startDate.getFullYear() - 1);
                   break;
               case '5Y':
                   startDate = new Date(endDate);
                   startDate.setFullYear(startDate.getFullYear() - 5);
                   break;
               case '10Y':
                   startDate = new Date(endDate);
                   startDate.setFullYear(startDate.getFullYear() - 10);
                   break;
           }
           
           Plotly.relayout('mainChart', {
               'xaxis.range': [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]
           });
       }
       
       // Format value
       function formatValue(value) {
           if (value === null || value === undefined) return '--';
           
           if (value >= 1000000000) {
               return (value / 1000000000).toFixed(2) + 'B';
           } else if (value >= 1000000) {
               return (value / 1000000).toFixed(2) + 'M';
           } else if (value >= 1000) {
               return (value / 1000).toFixed(2) + 'K';
           } else if (value < 1 && value > 0) {
               return value.toFixed(4);
           } else {
               return value.toFixed(2);
           }
       }
       
       // Refresh watchlist with real data
       async function refreshWatchlist() {
           console.log('Refreshing watchlist with latest data...');
           
           for (const item of watchlist) {
               // Re-fetch latest data
               const historical = await fetchHistoricalData(item.symbol, item.api);
               
               if (historical && historical.length > 0) {
                   const enrichedData = calculateAllIndicators(historical);
                   historicalData[item.symbol] = enrichedData;
                   
                   const changes = calculatePercentageChanges(enrichedData);
                   percentageChangeData[item.symbol] = changes;
                   
                   const currentTechnicals = calculateCurrentTechnicals(enrichedData);
                   technicalIndicators[item.symbol] = currentTechnicals;
                   
                   // Re-detect trend signals
                   const trendSignal = detectEarlyTrendReversal(enrichedData);
                   trendSignals[item.symbol] = trendSignal;
                   
                   // Update values
                   item.currentValue = enrichedData[enrichedData.length - 1].value;
                   item.monthChange = changes.mom[changes.mom.length - 1]?.value || 0;
                   item.quarterChange = changes.qoq[changes.qoq.length - 1]?.value || 0;
                   item.yearChange = changes.yoy[changes.yoy.length - 1]?.value || 0;
                   item.rsi = currentTechnicals.rsi;
                   item.volatility = currentTechnicals.volatility;
                   item.trendSignal = trendSignal;
                   item.lastUpdate = new Date().toISOString();
               }
           }
           
           updateWatchlistDisplay();
           saveWatchlistToStorage();
           
           if (selectedIndicator) {
               const indicator = watchlist.find(item => item.symbol === selectedIndicator);
               if (indicator) {
                   updateChartStats(indicator);
                   plotChart(selectedIndicator);
                   if (trendDetectionEnabled && indicator.trendSignal) {
                       showTrendAlert(indicator.trendSignal);
                   }
               }
           }
       }
       
       // Export watchlist
       function exportWatchlist() {
           const dataStr = JSON.stringify(watchlist, null, 2);
           const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
           
           const exportFileDefaultName = `watchlist_${new Date().toISOString().split('T')[0]}.json`;
           
           const linkElement = document.createElement('a');
           linkElement.setAttribute('href', dataUri);
           linkElement.setAttribute('download', exportFileDefaultName);
           linkElement.click();
       }
       
       // Clear watchlist
       function clearWatchlist() {
           if (confirm('Are you sure you want to clear your watchlist?')) {
               watchlist = [];
               selectedIndicator = null;
               historicalData = {};
               percentageChangeData = {};
               technicalIndicators = {};
               trendSignals = {};
               updateWatchlistDisplay();
               saveWatchlistToStorage();
               initializeChart();
               document.getElementById('chartTitle').textContent = 'Select an indicator to view data with advanced analysis';
               document.getElementById('chartStats').style.display = 'none';
               document.getElementById('techLegend').style.display = 'none';
               document.getElementById('trendAlert').classList.remove('active');
           }
       }
       
       // Remove from watchlist
       function removeFromWatchlist(index) {
           const symbol = watchlist[index].symbol;
           watchlist.splice(index, 1);
           
           delete historicalData[symbol];
           delete percentageChangeData[symbol];
           delete technicalIndicators[symbol];
           delete trendSignals[symbol];
           
           if (selectedIndicator === symbol) {
               selectedIndicator = null;
               initializeChart();
               document.getElementById('chartTitle').textContent = 'Select an indicator to view data with advanced analysis';
               document.getElementById('chartStats').style.display = 'none';
               document.getElementById('techLegend').style.display = 'none';
               document.getElementById('trendAlert').classList.remove('active');
           }
           
           updateWatchlistDisplay();
           saveWatchlistToStorage();
       }
       
       // Save watchlist to localStorage
       function saveWatchlistToStorage() {
           try {
               const watchlistData = watchlist.map(item => ({
                   symbol: item.symbol,
                   name: item.name,
                   customName: item.customName,
                   api: item.api,
                   category: item.category
               }));
               localStorage.setItem('openbb_advanced_watchlist', JSON.stringify(watchlistData));
           } catch (error) {
               console.error('Error saving watchlist:', error);
           }
       }
       
       // Load watchlist from localStorage
       async function loadWatchlistFromStorage() {
           try {
               const stored = localStorage.getItem('openbb_advanced_watchlist');
               if (stored) {
                   const watchlistData = JSON.parse(stored);
                   
                   for (const item of watchlistData) {
                       const indicator = allIndicators.find(ind => 
                           ind.symbol === item.symbol && ind.api === item.api
                       );
                       
                       if (indicator) {
                           const historical = await fetchHistoricalData(item.symbol, item.api);
                           
                           if (historical && historical.length > 0) {
                               const enrichedData = calculateAllIndicators(historical);
                               historicalData[item.symbol] = enrichedData;
                               
                               const changes = calculatePercentageChanges(enrichedData);
                               percentageChangeData[item.symbol] = changes;
                               
                               const currentTechnicals = calculateCurrentTechnicals(enrichedData);
                               technicalIndicators[item.symbol] = currentTechnicals;
                               
                               const trendSignal = detectEarlyTrendReversal(enrichedData);
                               trendSignals[item.symbol] = trendSignal;
                               
                               const watchlistItem = {
                                   ...indicator,
                                   customName: item.customName || indicator.name,
                                   currentValue: enrichedData[enrichedData.length - 1].value,
                                   monthChange: changes.mom[changes.mom.length - 1]?.value || 0,
                                   quarterChange: changes.qoq[changes.qoq.length - 1]?.value || 0,
                                   yearChange: changes.yoy[changes.yoy.length - 1]?.value || 0,
                                   rsi: currentTechnicals.rsi,
                                   volatility: currentTechnicals.volatility,
                                   trendSignal: trendSignal,
                                   lastUpdate: new Date().toISOString()
                               };
                               
                               watchlist.push(watchlistItem);
                           }
                       }
                   }
                   
                   updateWatchlistDisplay();
               }
           } catch (error) {
               console.error('Error loading watchlist:', error);
           }
       }
       
       // Auto-refresh every 5 minutes with real data
       setInterval(() => {
           if (watchlist.length > 0) {
               refreshWatchlist();
           }
       }, 300000);
       
       // Handle keyboard shortcuts
       document.addEventListener('keydown', function(e) {
           if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
               e.preventDefault();
               document.getElementById('searchInput').focus();
           }
           
           if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
               e.preventDefault();
               refreshWatchlist();
           }
           
           if (e.key === 'Escape') {
               document.getElementById('searchResults').classList.remove('active');
               document.getElementById('searchInput').blur();
           }
       });
       
       // Handle window resize
       window.addEventListener('resize', function() {
           Plotly.Plots.resize('mainChart');
       });
   </script>
</body>
</html>
