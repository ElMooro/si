const highlightMatch = (text) => highlightMatch(text, query);<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBB Financial Charts</title>
   
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
   
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
       
        /* Header */
        .header {
            background: #121212;
            padding: 15px 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo {
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #1a1a1a;
            border: 1px solid #333;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }
        .status-dot.connected { background: #00ff88; }
        .status-dot.warning { background: #ffaa00; }
       
        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 71px);
        }
       
        /* Search Section */
        .search-section {
            background: #121212;
            padding: 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 15px;
        }
        .search-container {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        .search-box {
            width: 100%;
            padding: 15px 50px 15px 20px;
            background: #222;
            border: 2px solid #333;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .search-box:focus {
            outline: none;
            border-color: #00ff88;
        }
        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            font-size: 18px;
        }
       
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            margin-top: 5px;
            max-height: 500px;
            overflow-y: auto;
            background: #181818;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .search-loading {
            padding: 20px;
            text-align: center;
            color: #00ff88;
        }
        .search-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-item:last-child { border-bottom: none; }
        .search-item:hover { background: #252525; }
        .search-item-left {
            flex: 1;
        }
        .search-item-symbol {
            font-weight: bold;
            color: #00dd77;
            font-size: 16px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }
        .search-item-name {
            font-size: 14px;
            color: #ddd;
            margin-bottom: 4px;
        }
        .search-item-description {
            font-size: 12px;
            color: #aaa;
            line-height: 1.3;
        }
        .search-item-source {
            font-size: 11px;
            color: #888;
            background: #2a2a2a;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }
       
        /* Charts Area */
        .charts-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #0f0f0f;
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
        }
        /* Enhanced chart styles with themes and fullscreen support */
        .chart-window {
            background: #131313;
            border: 1px solid #282828;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: border-color 0.3s;
            min-height: 500px;
        }
        .chart-window.active-chart {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        .chart-window.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            border-radius: 0;
            padding: 10px;
            background: var(--chart-bg);
        }
        .chart-window.fullscreen .chart-canvas {
            height: calc(100vh - 120px);
        }
        
        /* Theme variables */
        :root {
            --chart-bg: #131313;
            --chart-border: #282828;
            --chart-text: #e0e0e0;
            --chart-grid: #22222250;
            --chart-axis: #888;
        }
        
        [data-theme="light"] {
            --chart-bg: #ffffff;
            --chart-border: #e0e0e0;
            --chart-text: #333333;
            --chart-grid: #f0f0f0;
            --chart-axis: #666;
        }
        
        [data-theme="light"] .chart-window {
            background: var(--chart-bg);
            border-color: var(--chart-border);
            color: var(--chart-text);
        }
        
        [data-theme="light"] .control-btn,
        [data-theme="light"] .display-toggle,
        [data-theme="light"] .timeframe-btn {
            background: #f5f5f5;
            border-color: #ddd;
            color: #333;
        }
        
        [data-theme="light"] .display-toggle.active,
        [data-theme="light"] .timeframe-btn.active {
            background: #00dd77;
            color: #fff;
        }
        
        /* Chart type controls */
        .chart-type-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .chart-type-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .chart-type-btn:hover {
            background: #333;
            border-color: #555;
        }
        
        .chart-type-btn.active {
            background: #0066cc;
            color: #fff;
            border-color: #0066cc;
        }
        
        /* Theme toggle */
        .theme-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .theme-toggle:hover {
            background: #333;
            border-color: #555;
        }
        
        /* Fullscreen button */
        .fullscreen-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .fullscreen-btn:hover {
            background: #333;
            border-color: #555;
        }
        
        /* Comparison controls */
        .comparison-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .comparison-label {
            font-size: 11px;
            color: #888;
            margin-right: 5px;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .chart-title-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
        }
        .chart-title {
            font-size: 18px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chart-symbols {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .chart-symbol-tag {
            background: #252525;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid #333;
        }
        .symbol-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .remove-symbol {
            cursor: pointer;
            color: #ff5555;
            font-weight: bold;
            margin-left: 5px;
            opacity: 0.7;
            font-size: 14px;
        }
        .remove-symbol:hover { opacity: 1; }

        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .timeframe-buttons {
            display: flex;
            gap: 2px;
            background: #080808;
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #252525;
        }
        .timeframe-btn {
            background: transparent;
            border: none;
            color: #888;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            border-radius: 4px;
        }
        .timeframe-btn:hover {
            background: #2e2e2e;
            color: #fff;
        }
        .timeframe-btn.active {
            background: #00dd77;
            color: #000;
            font-weight: bold;
        }
       
        /* Chart Display Controls */
        .chart-display-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        .display-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .display-toggle:hover {
            background: #333;
            border-color: #555;
        }
        .display-toggle.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
       
        .chart-canvas {
            background: #0a0a0a;
            border-radius: 6px;
            height: 500px;
            flex-grow: 1;
            min-height: 450px;
        }
        .chart-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #555;
            font-size: 16px;
            text-align: center;
            padding: 20px;
        }
       
        .control-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
        }
        .control-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        .close-btn {
            background: #dd4444;
            border-color: #dd4444;
            color: #fff;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }
        .close-btn:hover { background: #ff5555; }
       
        /* Loading */
        .loading-pulse { animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
       
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f0f0f; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }
       
        /* Message Popup */
        .message-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #222;
            border: 1px solid #333;
            padding: 15px 20px;
            border-radius: 6px;
            z-index: 2000;
            animation: slideInAndOut 3s ease-in-out forwards;
        }
        .message-popup.info { border-color: #00dd77; }
        .message-popup.error { border-color: #ff4444; color: #ff6666; }
       
        @keyframes slideInAndOut {
            0% { transform: translateX(120%); opacity: 0; }
            15%, 85% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(120%); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">📊 OPENBB FINANCIAL CHARTS • 6,042+ Indicators</div>
        <div class="header-controls">
            <div class="status-indicator" id="apiStatus">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Checking API...</span>
            </div>
            <button class="control-btn" onclick="addNewChart()">+ New Chart</button>
            <span id="clock" style="color: #888; font-size: 14px;"></span>
        </div>
    </div>

    <div class="main-container">
        <div class="search-section">
            <div class="search-container">
                <input type="text" class="search-box" id="searchBox"
                       placeholder="🔍 Search 6,042+ OpenBB Financial Indicators (FEDFUNDS, Treasury, GDP, AAPL, etc.)..."
                       onkeyup="performSearch(this.value)"
                       autocomplete="off">
                <span class="search-icon">🔍</span>
                <div class="search-results" id="searchResults" style="display: none;"></div>
            </div>
        </div>

        <div class="charts-area" id="chartsArea">
            <div class="chart-grid" id="chartGrid"></div>
        </div>
    </div>

    <script>
        // Enhanced Configuration with CORS-friendly endpoints and fallbacks
        const API_CONFIG = {
            openbb_base: 'https://i3y8tfdp1k.execute-api.us-east-1.amazonaws.com/prod',
            cors_proxy: 'https://api.allorigins.win/raw?url=',
            backup_endpoints: [
                'https://api.polygon.io/v2/aggs/ticker/',
                'https://api.twelvedata.com/time_series',
                'https://financialmodelingprep.com/api/v3/historical-price-full/'
            ],
            use_proxy: true,
            timeout: 5000
        };
        
        let apiConnectionStatus = 'disconnected';
        
        // Enhanced symbol database with more financial indicators
        const sampleSymbols = [
            { symbol: 'AAPL', name: 'Apple Inc.', source: 'polygon', provider: 'polygon_direct', sector: 'Technology' },
            { symbol: 'MSFT', name: 'Microsoft Corporation', source: 'polygon', provider: 'polygon_direct', sector: 'Technology' },
            { symbol: 'GOOGL', name: 'Alphabet Inc.', source: 'polygon', provider: 'polygon_direct', sector: 'Technology' },
            { symbol: 'AMZN', name: 'Amazon.com Inc.', source: 'polygon', provider: 'polygon_direct', sector: 'Consumer Discretionary' },
            { symbol: 'TSLA', name: 'Tesla Inc.', source: 'polygon', provider: 'polygon_direct', sector: 'Automotive' },
            { symbol: 'NVDA', name: 'NVIDIA Corporation', source: 'polygon', provider: 'polygon_direct', sector: 'Technology' },
            { symbol: 'META', name: 'Meta Platforms Inc.', source: 'polygon', provider: 'polygon_direct', sector: 'Technology' },
            { symbol: 'SPY', name: 'SPDR S&P 500 ETF', source: 'polygon', provider: 'polygon_direct', sector: 'ETF' },
            { symbol: 'QQQ', name: 'Invesco QQQ Trust', source: 'polygon', provider: 'polygon_direct', sector: 'ETF' },
            { symbol: 'VTI', name: 'Vanguard Total Stock Market ETF', source: 'polygon', provider: 'polygon_direct', sector: 'ETF' },
            
            // Federal Reserve Economic Data (FRED)
            { symbol: 'FEDFUNDS', name: 'Federal Funds Rate', source: 'fred', provider: 'fred_direct', description: 'Effective Federal Funds Rate', units: 'Percent' },
            { symbol: 'UNRATE', name: 'Unemployment Rate', source: 'fred', provider: 'fred_direct', description: 'Civilian Unemployment Rate', units: 'Percent' },
            { symbol: 'GDP', name: 'Gross Domestic Product', source: 'fred', provider: 'fred_direct', description: 'Real GDP', units: 'Billions of Chained 2012 Dollars' },
            { symbol: 'CPIAUCSL', name: 'Consumer Price Index', source: 'fred', provider: 'fred_direct', description: 'CPI for All Urban Consumers', units: 'Index 1982-84=100' },
            { symbol: 'DGS10', name: '10-Year Treasury Rate', source: 'fred', provider: 'fred_direct', description: '10-Year Treasury Constant Maturity Rate', units: 'Percent' },
            { symbol: 'DGS2', name: '2-Year Treasury Rate', source: 'fred', provider: 'fred_direct', description: '2-Year Treasury Constant Maturity Rate', units: 'Percent' },
            { symbol: 'DGS30', name: '30-Year Treasury Rate', source: 'fred', provider: 'fred_direct', description: '30-Year Treasury Constant Maturity Rate', units: 'Percent' },
            { symbol: 'VIXCLS', name: 'CBOE Volatility Index', source: 'fred', provider: 'fred_direct', description: 'VIX Closing Price', units: 'Index' },
            { symbol: 'DEXUSEU', name: 'US/Euro Exchange Rate', source: 'fred', provider: 'fred_direct', description: 'US Dollars to One Euro', units: 'US Dollars to One Euro' },
            { symbol: 'GOLDAMGBD228NLBM', name: 'Gold Price', source: 'fred', provider: 'fred_direct', description: 'Gold Fixing Price in London Bullion Market', units: 'US Dollars per Troy Ounce' },
            
            // Additional Economic Indicators
            { symbol: 'PAYEMS', name: 'Nonfarm Payrolls', source: 'fred', provider: 'fred_direct', description: 'All Employees: Total Nonfarm Payrolls', units: 'Thousands of Persons' },
            { symbol: 'INDPRO', name: 'Industrial Production Index', source: 'fred', provider: 'fred_direct', description: 'Industrial Production Index', units: 'Index 2017=100' },
            { symbol: 'HOUST', name: 'Housing Starts', source: 'fred', provider: 'fred_direct', description: 'New Privately-Owned Housing Units Started', units: 'Thousands of Units' },
            { symbol: 'UMCSENT', name: 'Consumer Sentiment', source: 'fred', provider: 'fred_direct', description: 'University of Michigan Consumer Sentiment', units: 'Index 1966:Q1=100' },
            { symbol: 'M2SL', name: 'M2 Money Supply', source: 'fred', provider: 'fred_direct', description: 'M2 Money Stock', units: 'Billions of Dollars' },
            
            // Cryptocurrency (sample data)
            { symbol: 'BTC-USD', name: 'Bitcoin', source: 'crypto', provider: 'crypto_direct', description: 'Bitcoin to USD', units: 'USD' },
            { symbol: 'ETH-USD', name: 'Ethereum', source: 'crypto', provider: 'crypto_direct', description: 'Ethereum to USD', units: 'USD' },
            
            // Commodities
            { symbol: 'CL=F', name: 'Crude Oil Futures', source: 'commodities', provider: 'commodities_direct', description: 'Light Sweet Crude Oil Futures', units: 'USD per Barrel' },
            { symbol: 'GC=F', name: 'Gold Futures', source: 'commodities', provider: 'commodities_direct', description: 'Gold Futures', units: 'USD per Troy Ounce' }
        ];
       
        const charts = {};
        let chartIdCounter = 0;
        let activeChartId = null;
        let searchTimeout = null;
       
        // Color palette for charts
        const colorPalette = [
            '#00AEEF', '#FF4444', '#F4D03F', '#58D68D', '#FF7043',
            '#AF7AC5', '#48C9B0', '#EC7063', '#5DADE2', '#F5B041'
        ];
       
        // Initialize the application
        async function init() {
            updateClock();
            setInterval(updateClock, 1000);
            document.getElementById('searchBox').focus();
            
            // Check API connectivity
            await checkApiStatus();
            
            addNewChart(); // Start with one chart
        }
        
        // Enhanced API status checker with CORS-friendly requests
        async function checkApiStatus() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            statusText.textContent = 'Checking API...';
            statusDot.className = 'status-dot warning';
            
            try {
                // Test OpenBB API with CORS proxy
                const testUrl = API_CONFIG.use_proxy 
                    ? `${API_CONFIG.cors_proxy}${encodeURIComponent(API_CONFIG.openbb_base + '/api/search?query=test&limit=1')}`
                    : `${API_CONFIG.openbb_base}/api/search?query=test&limit=1`;
                
                const controller = new AbortController();
                setTimeout(() => controller.abort(), API_CONFIG.timeout);
                
                const response = await fetch(testUrl, {
                    signal: controller.signal,
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    apiConnectionStatus = 'connected';
                    statusText.textContent = 'OpenBB API Connected';
                    statusDot.className = 'status-dot connected';
                    console.log('✅ OpenBB API connection successful');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.warn('⚠️ OpenBB API connection failed:', error.message);
                apiConnectionStatus = 'fallback';
                statusText.textContent = 'Using Sample Data';
                statusDot.className = 'status-dot warning';
            }
        }
       
        // Update clock
        function updateClock() {
            document.getElementById('clock').textContent = new Date().toLocaleTimeString('en-US', { hour12: false });
        }
       
        // Enhanced search with CORS handling and better error recovery
        async function performSearch(query) {
            const resultsDiv = document.getElementById('searchResults');
           
            if (!query || query.trim().length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }
           
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                resultsDiv.innerHTML = '<div class="search-loading">🔍 Searching 6,042+ OpenBB Financial Indicators...</div>';
                resultsDiv.style.display = 'block';
               
                try {
                    let searchResults = [];
                    
                    // Try OpenBB API with CORS proxy if connected
                    if (apiConnectionStatus === 'connected') {
                        try {
                            console.log('🔍 Searching OpenBB API via CORS proxy...');
                            const searchUrl = API_CONFIG.use_proxy 
                                ? `${API_CONFIG.cors_proxy}${encodeURIComponent(API_CONFIG.openbb_base + `/api/search?query=${encodeURIComponent(query)}&limit=50`)}`
                                : `${API_CONFIG.openbb_base}/api/search?query=${encodeURIComponent(query)}&limit=50`;
                            
                            const controller = new AbortController();
                            setTimeout(() => controller.abort(), API_CONFIG.timeout);
                            
                            const apiResponse = await fetch(searchUrl, {
                                signal: controller.signal,
                                headers: {
                                    'Accept': 'application/json',
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            if (apiResponse.ok) {
                                const apiData = await apiResponse.json();
                                console.log('✅ OpenBB API Response:', apiData);
                                
                                if (apiData.results && Array.isArray(apiData.results)) {
                                    searchResults = apiData.results.map(item => ({
                                        symbol: item.symbol || item.indicator_name || item.id,
                                        name: item.title || item.description || item.name || item.symbol,
                                        source: item.provider || item.source || 'openbb',
                                        provider: item.provider || 'openbb_direct',
                                        description: item.description || item.units || '',
                                        frequency: item.frequency || '',
                                        units: item.units || ''
                                    }));
                                    console.log(`✅ Found ${searchResults.length} indicators from OpenBB`);
                                }
                            }
                        } catch (apiError) {
                            console.warn('⚠️ OpenBB API search failed:', apiError);
                            // Fall back to sample data
                        }
                    }
                    
                    // Always include sample data for reliability
                    const sampleResults = sampleSymbols.filter(symbol =>
                        symbol.symbol.toLowerCase().includes(query.toLowerCase()) ||
                        symbol.name.toLowerCase().includes(query.toLowerCase()) ||
                        (symbol.description && symbol.description.toLowerCase().includes(query.toLowerCase()))
                    );
                    
                    // Combine API results with sample data, avoiding duplicates
                    const combinedResults = [...searchResults];
                    sampleResults.forEach(sample => {
                        if (!combinedResults.find(result => result.symbol === sample.symbol)) {
                            combinedResults.push(sample);
                        }
                    });
                    
                    console.log(`📊 Total results: ${combinedResults.length} (${searchResults.length} from API, ${sampleResults.length} from samples)`);
                    displaySearchResults(combinedResults, query);
                    
                } catch (error) {
                    console.error('❌ Complete search error:', error);
                    
                    // Ultimate fallback - show sample data only
                    const fallbackResults = sampleSymbols.filter(symbol =>
                        symbol.symbol.toLowerCase().includes(query.toLowerCase()) ||
                        symbol.name.toLowerCase().includes(query.toLowerCase())
                    );
                    
                    displaySearchResults(fallbackResults, query);
                }
            }, 300);
        }
       
        // Enhanced display for search results with better organization
        function displaySearchResults(results, query) {
            const resultsDiv = document.getElementById('searchResults');
           
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="search-item" style="text-align:center; color:#888; padding: 20px;">
                        <div>No results found for "${query}"</div>
                        <div style="margin-top: 10px; font-size: 12px; color: #666;">
                            Search examples: FEDFUNDS, Treasury, GDP, Unemployment, VIX, AAPL, MSFT
                        </div>
                        <div style="margin-top: 5px; font-size: 11px; color: #00ff88;">
                            📊 Database: 6,042+ OpenBB Financial Indicators
                        </div>
                    </div>
                `;
                return;
            }
           
            // Sort and categorize results
            const categorized = {
                'Stocks': [],
                'ETFs': [],
                'Economic': [],
                'Rates': [],
                'Crypto': [],
                'Commodities': [],
                'Other': []
            };
            
            results.forEach(result => {
                // Safely check properties with fallbacks
                const symbol = result.symbol || '';
                const name = result.name || '';
                const source = result.source || '';
                const provider = result.provider || '';
                const sector = result.sector || '';
                const description = result.description || '';
                
                if (sector === 'ETF' || symbol.includes('ETF') || name.includes('ETF')) {
                    categorized['ETFs'].push(result);
                } else if (source === 'fred' || provider === 'fred_direct') {
                    if (symbol.includes('DGS') || symbol.includes('RATE') || symbol === 'FEDFUNDS' || description.includes('Rate')) {
                        categorized['Rates'].push(result);
                    } else {
                        categorized['Economic'].push(result);
                    }
                } else if (source === 'crypto' || symbol.includes('-USD') || symbol.includes('BTC') || symbol.includes('ETH')) {
                    categorized['Crypto'].push(result);
                } else if (source === 'commodities' || symbol.includes('=F') || name.includes('Gold') || name.includes('Oil')) {
                    categorized['Commodities'].push(result);
                } else if (source === 'polygon' || sector) {
                    categorized['Stocks'].push(result);
                } else {
                    categorized['Other'].push(result);
                }
            });
            
            // Sort each category
            Object.keys(categorized).forEach(category => {
                categorized[category].sort((a, b) => {
                    const symbolA = (a.symbol || '').toLowerCase();
                    const symbolB = (b.symbol || '').toLowerCase();
                    const queryLower = query.toLowerCase();
                   
                    // Exact matches first
                    if (symbolA === queryLower) return -1;
                    if (symbolB === queryLower) return 1;
                   
                    // Then starts with
                    if (symbolA.startsWith(queryLower)) return -1;
                    if (symbolB.startsWith(queryLower)) return 1;
                   
                    return 0;
                });
            });
           
        function highlightMatch(text, query) {
            if (!text || !query) return text || '';
            const regex = new RegExp(`(${query.split(' ').join('|')})`, 'gi');
            return text.replace(regex, '<span style="color: #00ff88; font-weight: bold;">$1</span>');
        }
           
            const getProviderIcon = (provider, source) => {
                const icons = {
                    'fred': '🏛️ FRED',
                    'fred_direct': '🏛️ FRED',
                    'polygon': '📈 Polygon',
                    'polygon_direct': '📈 Polygon',
                    'crypto': '₿ Crypto',
                    'crypto_direct': '₿ Crypto',
                    'commodities': '🥇 Commodities',
                    'commodities_direct': '🥇 Commodities',
                    'openbb': '⚡ OpenBB',
                    'openbb_direct': '⚡ OpenBB'
                };
                return icons[provider] || icons[source] || '📊 Financial';
            };
            
            let html = `
                <div style="padding: 8px 20px; font-size: 11px; color: #00ff88; border-bottom: 1px solid #333; background: #1a1a1a;">
                    📊 OpenBB Financial Intelligence • Found ${results.length} of 6,042+ indicators • API Status: ${apiConnectionStatus}
                </div>
            `;
            
            // Display results by category
            Object.keys(categorized).forEach(category => {
                const categoryResults = categorized[category];
                if (categoryResults.length === 0) return;
                
                html += `
                    <div style="padding: 6px 20px; font-size: 10px; color: #666; background: #1a1a1a; border-bottom: 1px solid #333; font-weight: bold;">
                        ${category.toUpperCase()} (${categoryResults.length})
                    </div>
                `;
                
                categoryResults.slice(0, 20).forEach(result => { // Limit per category
                    const providerIcon = getProviderIcon(result.provider, result.source);
                    const frequency = result.frequency ? ` • ${result.frequency}` : '';
                    const units = result.units ? ` • ${result.units}` : '';
                   
                    html += `
                        <div class="search-item" onclick="addToChart('${result.symbol}', '${(result.name || result.symbol).replace(/'/g, "\\'")}', '${result.provider || result.source}')">
                            <div class="search-item-left">
                                <div class="search-item-symbol">${highlightMatch(result.symbol)}</div>
                                <div class="search-item-name">${highlightMatch(result.name || result.symbol)}</div>
                                ${result.description ? `<div class="search-item-description">${highlightMatch(result.description)}${frequency}${units}</div>` : ''}
                            </div>
                            <div class="search-item-source">${providerIcon}</div>
                        </div>
                    `;
                });
            });
           
            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }
       
        // Add symbol to active chart with enhanced provider support
        function addToChart(symbol, name, provider) {
            if (activeChartId) {
                addSymbolToChart(activeChartId, symbol, name, provider);
            } else {
                addNewChart();
                if (activeChartId) {
                    addSymbolToChart(activeChartId, symbol, name, provider);
                }
            }
           
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchBox').value = '';
        }
       
        // Chart Management Functions
        function addNewChart() {
            const chartId = `chart_${chartIdCounter++}`;
           
            const chartHtml = `
                <div class="chart-window" id="${chartId}" onclick="setActiveChart('${chartId}')">
                    <div class="chart-header">
                        <div class="chart-title-section">
                            <div class="chart-title" id="${chartId}_title">Chart ${chartIdCounter}</div>
                            <div class="chart-symbols" id="${chartId}_symbols"></div>
                            <div class="chart-display-controls">
                                <button class="display-toggle active" onclick="toggleChartDisplay(event, '${chartId}', 'raw')" data-display="raw">📈 Raw Data</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'pct_change')" data-display="pct_change">📊 YoY % Change</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'unit_change')" data-display="unit_change">🔢 Trend Strength</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'rsi')" data-display="rsi">🎯 RSI</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'macd')" data-display="macd">⚡ MACD</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'bollinger')" data-display="bollinger">🌊 Bollinger Bands</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'stochastic')" data-display="stochastic">🔄 Stochastic</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'volume')" data-display="volume">📦 Volume Analysis</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'multi_indicator')" data-display="multi_indicator">🎛️ Multi-Indicator</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'signals')" data-display="signals">🎪 Trading Signals</button>
                            </div>
                            <div class="chart-type-controls">
                                <span class="comparison-label">Chart Type:</span>
                                <button class="chart-type-btn active" onclick="changeChartType('${chartId}', 'line')" data-type="line">📈 Line</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'candlestick')" data-type="candlestick">🕯️ Candlestick</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'ohlc')" data-type="ohlc">📊 OHLC</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'area')" data-type="area">🏔️ Area</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'mountain')" data-type="mountain">🗻 Mountain</button>
                            </div>
                            <div class="comparison-controls">
                                <span class="comparison-label">Compare:</span>
                                <button class="display-toggle active" onclick="changeComparisonMode('${chartId}', 'absolute')" data-comparison="absolute">Absolute</button>
                                <button class="display-toggle" onclick="changeComparisonMode('${chartId}', 'percentage')" data-comparison="percentage">Percentage</button>
                                <button class="display-toggle" onclick="changeComparisonMode('${chartId}', 'indexed')" data-comparison="indexed">Indexed (100)</button>
                            </div>
                        </div>
                        <div class="chart-controls">
                            <div class="timeframe-buttons" id="${chartId}_timeframe_buttons">
                                ${['1D','1W','1M','3M','6M','1Y','2Y','5Y','10Y','MAX'].map(tf =>
                                    `<button class="timeframe-btn ${tf === '1Y' ? 'active' : ''}"
                                             onclick="changeTimeframe(event, '${chartId}', '${tf}')">${tf}</button>`
                                ).join('')}
                            </div>
                            <button class="theme-toggle" onclick="toggleTheme('${chartId}')">🌓 Theme</button>
                            <button class="fullscreen-btn" onclick="toggleFullscreen('${chartId}')" title="Toggle Fullscreen">⛶</button>
                            <button class="close-btn" onclick="removeChart(event, '${chartId}')">×</button>
                        </div>
                    </div>
                    <div class="chart-canvas" id="${chartId}_canvas">
                        <div class="chart-message">Search for a financial instrument to add to this chart</div>
                    </div>
                </div>`;
           
            document.getElementById('chartGrid').insertAdjacentHTML('beforeend', chartHtml);
            charts[chartId] = {
                symbols: [],
                data: {},
                timeframe: '1Y',
                chartInstance: null,
                displayMode: 'raw',
                chartType: 'line',
                theme: 'dark',
                isFullscreen: false,
                comparisonMode: 'absolute',
                maxSymbols: 10,
                historicalYears: 10
            };
            setActiveChart(chartId);
        }
       
        function setActiveChart(chartId) {
            if (activeChartId === chartId) return;
            activeChartId = chartId;
            document.querySelectorAll('.chart-window').forEach(c => c.classList.remove('active-chart'));
            const chartElement = document.getElementById(chartId);
            if (chartElement) {
                chartElement.classList.add('active-chart');
            }
        }
       
        function removeChart(event, chartIdToRemove) {
            event.stopPropagation();
            if (charts[chartIdToRemove] && charts[chartIdToRemove].chartInstance) {
                Plotly.purge(`${chartIdToRemove}_canvas`);
            }
            delete charts[chartIdToRemove];
            document.getElementById(chartIdToRemove)?.remove();
           
            if (activeChartId === chartIdToRemove) {
                const chartKeys = Object.keys(charts);
                activeChartId = chartKeys.length > 0 ? chartKeys[chartKeys.length - 1] : null;
                if(activeChartId) setActiveChart(activeChartId);
            }
           
            if (Object.keys(charts).length === 0) {
                addNewChart();
            }
        }
       
        // Add symbol to specific chart with enhanced provider
        function addSymbolToChart(chartId, symbol, name, provider) {
            const chart = charts[chartId];
            if (!chart) return;
           
            if (!chart.symbols.find(s => s.symbol === symbol)) {
                chart.symbols.push({ symbol, name, provider: provider || 'sample_data' });
                loadChartData(chartId, symbol, name, provider);
            }
            setActiveChart(chartId);
        }
       
        // Enhanced sample data generation with realistic financial data patterns
        function generateSampleData(symbol, years = 10) {
            const data = [];
            const startDate = new Date();
            startDate.setFullYear(startDate.getFullYear() - years);
           
            // Symbol-specific enhanced parameters
            const symbolConfig = {
                'AAPL': { baseValue: 150, baseVolume: 50000000, volatility: 0.025, hasEarnings: true },
                'MSFT': { baseValue: 300, baseVolume: 30000000, volatility: 0.022, hasEarnings: true },
                'GOOGL': { baseValue: 2500, baseVolume: 25000000, volatility: 0.028, hasEarnings: true },
                'AMZN': { baseValue: 3200, baseVolume: 35000000, volatility: 0.030, hasEarnings: true },
                'TSLA': { baseValue: 800, baseVolume: 80000000, volatility: 0.045, hasEarnings: true },
                'NVDA': { baseValue: 500, baseVolume: 45000000, volatility: 0.035, hasEarnings: true },
                'META': { baseValue: 280, baseVolume: 25000000, volatility: 0.032, hasEarnings: true },
                'SPY': { baseValue: 450, baseVolume: 70000000, volatility: 0.018, hasEarnings: false },
                'QQQ': { baseValue: 380, baseVolume: 45000000, volatility: 0.022, hasEarnings: false },
                'VTI': { baseValue: 220, baseVolume: 35000000, volatility: 0.016, hasEarnings: false },
                'FEDFUNDS': { baseValue: 2.5, baseVolume: 0, volatility: 0.01, hasEarnings: false, isRate: true, min: 0, max: 8 },
                'UNRATE': { baseValue: 5.0, baseVolume: 0, volatility: 0.005, hasEarnings: false, isRate: true, min: 2, max: 12 },
                'DGS10': { baseValue: 3.5, baseVolume: 0, volatility: 0.008, hasEarnings: false, isRate: true, min: 0.5, max: 8 },
                'DGS2': { baseValue: 3.2, baseVolume: 0, volatility: 0.01, hasEarnings: false, isRate: true, min: 0.1, max: 7 },
                'DGS30': { baseValue: 3.8, baseVolume: 0, volatility: 0.007, hasEarnings: false, isRate: true, min: 1, max: 8 },
                'VIXCLS': { baseValue: 20, baseVolume: 0, volatility: 0.15, hasEarnings: false, min: 8, max: 85 },
                'GDP': { baseValue: 25000, baseVolume: 0, volatility: 0.003, hasEarnings: false, min: 20000, max: 30000 },
                'CPIAUCSL': { baseValue: 310, baseVolume: 0, volatility: 0.002, hasEarnings: false, trend: 0.0001 },
                'BTC-USD': { baseValue: 45000, baseVolume: 1000000, volatility: 0.05, hasEarnings: false },
                'ETH-USD': { baseValue: 3000, baseVolume: 2000000, volatility: 0.06, hasEarnings: false },
                'CL=F': { baseValue: 75, baseVolume: 500000, volatility: 0.03, hasEarnings: false, min: 30, max: 150 },
                'GC=F': { baseValue: 1950, baseVolume: 200000, volatility: 0.02, hasEarnings: false, min: 1500, max: 2500 }
            };
            
            const config = symbolConfig[symbol] || { baseValue: 100, baseVolume: 1000000, volatility: 0.02 };
            let currentValue = config.baseValue;
            
            // Market events simulation
            const marketEvents = [];
            for (let i = 0; i < years * 4; i++) {
                if (Math.random() < 0.3) { // 30% chance of market event per quarter
                    marketEvents.push({
                        day: Math.floor(Math.random() * (years * 252)),
                        impact: (Math.random() - 0.5) * config.volatility * 5,
                        duration: Math.floor(Math.random() * 10) + 1
                    });
                }
            }
            
            for (let i = 0; i < years * 252; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
               
                // Base random walk
                const randomWalk = (Math.random() - 0.5) * config.volatility * 2;
                
                // Multiple trend components
                const longTermTrend = config.trend || Math.sin(i / 500) * 0.001; // Long-term secular trends
                const mediumTermTrend = Math.sin(i / 150) * 0.003; // Medium-term business cycles
                const shortTermTrend = Math.sin(i / 50) * 0.005; // Short-term market cycles
                const seasonalComponent = Math.sin((i % 252) / 252 * 2 * Math.PI) * 0.002; // Annual seasonality
                
                // Market event impacts
                let eventComponent = 0;
                marketEvents.forEach(event => {
                    if (i >= event.day && i < event.day + event.duration) {
                        eventComponent += event.impact * Math.exp(-(i - event.day) / event.duration);
                    }
                });
                
                // Earnings announcements (quarterly for stocks)
                let earningsComponent = 0;
                if (config.hasEarnings && i % 63 === 0 && Math.random() < 0.8) { // ~80% chance every quarter
                    earningsComponent = (Math.random() - 0.5) * config.volatility * 3;
                }
                
                // Weekend/holiday effects (reduced volatility)
                const dayOfWeek = (i % 5);
                const weekendMultiplier = dayOfWeek < 4 ? 1 : 0.5;
                
                const totalChange = (randomWalk + longTermTrend + mediumTermTrend + shortTermTrend + 
                                  seasonalComponent + eventComponent + earningsComponent) * weekendMultiplier;
                
                // Apply change
                const previousClose = currentValue;
                currentValue *= (1 + totalChange);
               
                // Apply constraints
                if (config.min !== undefined) currentValue = Math.max(currentValue, config.min);
                if (config.max !== undefined) currentValue = Math.min(currentValue, config.max);
                
                // Generate realistic OHLC data
                const dailyVolatility = config.volatility * (0.3 + Math.random() * 0.7) * weekendMultiplier;
                const range = currentValue * dailyVolatility;
                
                // Open price (slight gap from previous close)
                const gapSize = (Math.random() - 0.5) * config.volatility * 0.5;
                const open = previousClose * (1 + gapSize);
                
                // Intraday movements
                const intrarayMove1 = (Math.random() - 0.5) * range * 2;
                const intrarayMove2 = (Math.random() - 0.5) * range * 2;
                
                const high = Math.max(open, currentValue) + Math.abs(intrarayMove1);
                const low = Math.min(open, currentValue) - Math.abs(intrarayMove2);
                
                // Ensure OHLC consistency
                const finalHigh = Math.max(high, open, currentValue);
                const finalLow = Math.min(low, open, currentValue);
                
                // Generate volume data
                let volume = 0;
                if (config.baseVolume > 0) {
                    const volumeVariation = (Math.random() - 0.5) * 0.6;
                    const volumeTrend = Math.abs(totalChange) * 3; // Higher volume on bigger moves
                    const volumeCluster = Math.abs(eventComponent) > 0 ? 2.5 : 1;
                    const earningsVolume = Math.abs(earningsComponent) > 0 ? 1.8 : 1;
                    volume = Math.round(config.baseVolume * (1 + volumeVariation + volumeTrend) * volumeCluster * earningsVolume);
                    volume = Math.max(volume, config.baseVolume * 0.1);
                }
               
                data.push({
                    date: date.toISOString().split('T')[0],
                    value: currentValue,
                    close: currentValue,
                    open: open,
                    high: finalHigh,
                    low: finalLow,
                    volume: volume,
                    typical_price: (finalHigh + finalLow + currentValue) / 3,
                    weighted_price: (finalHigh + finalLow + currentValue + currentValue) / 4
                });
            }
           
            return data;
        }
       
        // Load chart data with comprehensive error handling
        async function loadChartData(chartId, symbol, name, provider) {
            const chart = charts[chartId];
            if (!chart) {
                console.error('❌ Chart not found:', chartId);
                return;
            }
           
            const canvasDiv = document.getElementById(`${chartId}_canvas`);
            if (canvasDiv) canvasDiv.innerHTML = `<div class="chart-message loading-pulse">📊 Loading ${symbol}...</div>`;
           
            try {
                let processedData = [];
                console.log(`🔄 Starting data load for ${symbol} with provider ${provider}`);
                
                // First try to fetch real data if API is connected
                if (apiConnectionStatus === 'connected' && provider && provider !== 'sample_data') {
                    try {
                        console.log(`🌐 Attempting to fetch real data for ${symbol}...`);
                        // This would be where you implement real API calls
                        // For now, we'll continue with sample data
                        console.log(`⚠️ Real data fetching not implemented yet, using sample data`);
                    } catch (realDataError) {
                        console.warn(`⚠️ Real data fetch failed for ${symbol}:`, realDataError);
                    }
                }
                
                // Generate enhanced sample data
                try {
                    console.log(`📊 Generating enhanced sample data for ${symbol}...`);
                    const rawData = generateSampleData(symbol, chart.historicalYears || 10);
                    console.log(`✅ Generated ${rawData.length} enhanced data points`);
                    
                    if (rawData.length === 0) {
                        throw new Error('No raw data generated');
                    }
                    
                    // Validate data structure
                    const validData = rawData.filter(item => 
                        item && 
                        item.date && 
                        typeof item.value === 'number' && 
                        !isNaN(item.value) && 
                        isFinite(item.value) &&
                        typeof item.close === 'number' &&
                        typeof item.open === 'number' &&
                        typeof item.high === 'number' &&
                        typeof item.low === 'number'
                    );
                    
                    console.log(`✅ Validated ${validData.length} data points`);
                    
                    if (validData.length === 0) {
                        throw new Error('No valid data after filtering');
                    }
                    
                    processedData = validData;
                    
                } catch (dataError) {
                    console.error('❌ Data generation error:', dataError);
                    throw new Error(`Data generation failed: ${dataError.message}`);
                }
                
                // Calculate changes with error protection
                try {
                    console.log('🔄 Calculating chart changes...');
                    processedData = calculateChartChanges(processedData);
                    console.log('✅ Chart changes calculated');
                } catch (changeError) {
                    console.error('❌ Change calculation error:', changeError);
                    console.log('⚠️ Continuing without change calculations');
                }
                
                // Calculate technical indicators with error protection
                try {
                    console.log('🔄 Calculating technical indicators...');
                    processedData = calculateTechnicalIndicators(processedData);
                    console.log('✅ Technical indicators calculated');
                } catch (indicatorError) {
                    console.error('❌ Technical indicator error:', indicatorError);
                    console.log('⚠️ Continuing without technical indicators');
                }
                
                // Validate final processed data
                if (!processedData || processedData.length === 0) {
                    throw new Error('No processed data available');
                }
                
                console.log(`✅ Final processed data: ${processedData.length} points`);
                
                // Store data safely
                chart.data[symbol] = processedData;
                
                // Update chart with error protection
                try {
                    console.log('🔄 Updating chart render...');
                    updateChartRender(chartId);
                    console.log('✅ Chart render updated');
                } catch (renderError) {
                    console.error('❌ Chart render error:', renderError);
                    if (canvasDiv) {
                        canvasDiv.innerHTML = `
                            <div class="chart-message" style="color: #ffaa00;">
                                ⚠️ Chart render issue for ${symbol}<br>
                                <small>Data loaded but display failed</small><br>
                                <button onclick="updateChartRender('${chartId}')" style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">Retry Display</button>
                            </div>
                        `;
                    }
                    return;
                }
                
                // Update symbols with error protection
                try {
                    updateChartSymbols(chartId);
                    console.log('✅ Chart symbols updated');
                } catch (symbolError) {
                    console.error('❌ Symbol update error:', symbolError);
                }
               
                const sourceLabel = provider ? provider.replace('_direct', '').toUpperCase() : 'Enhanced Sample';
                showTemporaryMessage(`✅ Added ${symbol} (${processedData.length} points)`, 'info');
               
            } catch (error) {
                console.error(`❌ Complete failure loading ${symbol}:`, error);
                
                if (canvasDiv) {
                    canvasDiv.innerHTML = `
                        <div class="chart-message" style="color: #ff4444;">
                            ❌ Failed to load ${symbol}<br>
                            <small>${error.message}</small><br>
                            <button onclick="retryLoadChart('${chartId}', '${symbol}', '${name}', '${provider}')" 
                                    style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                                🔄 Retry
                            </button>
                        </div>
                    `;
                }
                
                // Remove failed symbol from chart
                try {
                    chart.symbols = chart.symbols.filter(s => s.symbol !== symbol);
                    updateChartSymbols(chartId);
                } catch (cleanupError) {
                    console.error('❌ Cleanup error:', cleanupError);
                }
                
                showTemporaryMessage(`❌ Failed to load ${symbol}`, 'error');
            }
        }
        
        // Retry function for failed charts
        function retryLoadChart(chartId, symbol, name, provider) {
            console.log(`🔄 Retrying chart load for ${symbol}...`);
            loadChartData(chartId, symbol, name, provider);
        }
       
        // Calculate additional changes for chart data with proper trend detection
        function calculateChartChanges(data) {
            if (!data || data.length === 0) return data;
           
            return data.map((item, index, arr) => {
                const newItem = { ...item };
                const currentDate = new Date(item.date);
               
                // Helper function to find previous value by days
                const findPreviousValue = (daysAgo) => {
                    const targetDate = new Date(currentDate);
                    targetDate.setDate(currentDate.getDate() - daysAgo);
                   
                    for (let i = index - 1; i >= 0; i--) {
                        if (new Date(arr[i].date) <= targetDate) {
                            return arr[i].value;
                        }
                    }
                    return null;
                };
               
                // Calculate various period changes for trend detection
                const prevDayValue = (index > 0) ? arr[index-1].value : null;
                const prevWeekValue = findPreviousValue(7);
                const prevMonthValue = findPreviousValue(30);
                const prevYearValue = findPreviousValue(365);
               
                // Daily changes
                if (prevDayValue !== null && prevDayValue !== 0) {
                    newItem.daily_pct_change = ((item.value - prevDayValue) / Math.abs(prevDayValue)) * 100;
                    newItem.daily_change_units = item.value - prevDayValue;
                } else {
                    newItem.daily_pct_change = 0;
                    newItem.daily_change_units = 0;
                }
               
                // Weekly changes
                if (prevWeekValue !== null && prevWeekValue !== 0) {
                    newItem.weekly_pct_change = ((item.value - prevWeekValue) / Math.abs(prevWeekValue)) * 100;
                    newItem.weekly_change_units = item.value - prevWeekValue;
                } else {
                    newItem.weekly_pct_change = 0;
                    newItem.weekly_change_units = 0;
                }
               
                // Monthly changes
                if (prevMonthValue !== null && prevMonthValue !== 0) {
                    newItem.monthly_pct_change = ((item.value - prevMonthValue) / Math.abs(prevMonthValue)) * 100;
                    newItem.monthly_change_units = item.value - prevMonthValue;
                } else {
                    newItem.monthly_pct_change = 0;
                    newItem.monthly_change_units = 0;
                }
               
                // Yearly changes
                if (prevYearValue !== null && prevYearValue !== 0) {
                    newItem.yearly_pct_change = ((item.value - prevYearValue) / Math.abs(prevYearValue)) * 100;
                    newItem.yearly_change_units = item.value - prevYearValue;
                } else {
                    newItem.yearly_pct_change = 0;
                    newItem.yearly_change_units = 0;
                }
               
                // Trend detection indicators
                if (index >= 5) {
                    // 5-period trend
                    const recentValues = arr.slice(index - 4, index + 1).map(d => d.value);
                    const trend = recentValues[recentValues.length - 1] - recentValues[0];
                    newItem.short_trend = trend;
                    
                    // Moving average for smoothing
                    const avgValue = recentValues.reduce((sum, val) => sum + val, 0) / recentValues.length;
                    newItem.moving_avg_5 = avgValue;
                }
               
                if (index >= 20) {
                    // 20-period moving average for longer trend
                    const longerValues = arr.slice(index - 19, index + 1).map(d => d.value);
                    const avgLonger = longerValues.reduce((sum, val) => sum + val, 0) / longerValues.length;
                    newItem.moving_avg_20 = avgLonger;
                    
                    // Trend strength
                    newItem.trend_strength = ((item.value - avgLonger) / Math.abs(avgLonger)) * 100;
                }
               
                return newItem;
            });
        }
       
        // Comprehensive technical indicators calculation
        function calculateTechnicalIndicators(data) {
            if (!data || data.length === 0) return data;
           
            const values = data.map(d => d.value);
            const highs = data.map(d => d.high || d.value);
            const lows = data.map(d => d.low || d.value);
            const closes = data.map(d => d.close || d.value);
            const volumes = data.map(d => d.volume || 0);
           
            // RSI Calculation (14-period)
            const calculateRSI = (prices, period = 14) => {
                const rsiValues = [];
                
                for (let i = 0; i < period; i++) {
                    rsiValues.push(null);
                }
                
                if (prices.length > period) {
                    let gains = [];
                    let losses = [];
                    
                    // Calculate initial gains and losses
                    for (let i = 1; i <= period; i++) {
                        const change = prices[i] - prices[i - 1];
                        gains.push(change > 0 ? change : 0);
                        losses.push(change < 0 ? -change : 0);
                    }
                    
                    let avgGain = gains.reduce((sum, gain) => sum + gain, 0) / period;
                    let avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / period;
                    
                    // Calculate RSI for the period
                    let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    let rsi = 100 - (100 / (1 + rs));
                    rsiValues.push(rsi);
                    
                    // Use Wilder's smoothing for subsequent values
                    for (let i = period + 1; i < prices.length; i++) {
                        const change = prices[i] - prices[i - 1];
                        const gain = change > 0 ? change : 0;
                        const loss = change < 0 ? -change : 0;
                        
                        avgGain = (avgGain * (period - 1) + gain) / period;
                        avgLoss = (avgLoss * (period - 1) + loss) / period;
                        
                        rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                        rsi = 100 - (100 / (1 + rs));
                        rsiValues.push(rsi);
                    }
                }
                
                return rsiValues;
            };
            
            // Stochastic Oscillator Calculation
            const calculateStochastic = (highs, lows, closes, kPeriod = 14, dPeriod = 3) => {
                const stochK = [];
                const stochD = [];
                
                for (let i = 0; i < kPeriod - 1; i++) {
                    stochK.push(null);
                    stochD.push(null);
                }
                
                for (let i = kPeriod - 1; i < closes.length; i++) {
                    const periodHighs = highs.slice(i - kPeriod + 1, i + 1);
                    const periodLows = lows.slice(i - kPeriod + 1, i + 1);
                    
                    const highestHigh = Math.max(...periodHighs);
                    const lowestLow = Math.min(...periodLows);
                    
                    const k = ((closes[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
                    stochK.push(k);
                }
                
                // Calculate %D (Simple Moving Average of %K)
                for (let i = 0; i < dPeriod - 1; i++) {
                    stochD.push(null);
                }
                
                for (let i = dPeriod - 1; i < stochK.length; i++) {
                    const kValues = stochK.slice(i - dPeriod + 1, i + 1).filter(v => v !== null);
                    if (kValues.length === dPeriod) {
                        const d = kValues.reduce((sum, val) => sum + val, 0) / dPeriod;
                        stochD.push(d);
                    } else {
                        stochD.push(null);
                    }
                }
                
                return { stochK, stochD };
            };
            
            // Bollinger Bands Calculation
            const calculateBollingerBands = (prices, period = 20, stdDev = 2) => {
                const sma = [];
                const upperBand = [];
                const lowerBand = [];
                const bandwidth = [];
                
                for (let i = 0; i < period - 1; i++) {
                    sma.push(null);
                    upperBand.push(null);
                    lowerBand.push(null);
                    bandwidth.push(null);
                }
                
                for (let i = period - 1; i < prices.length; i++) {
                    const slice = prices.slice(i - period + 1, i + 1);
                    const average = slice.reduce((sum, val) => sum + val, 0) / period;
                    sma.push(average);
                    
                    // Calculate standard deviation
                    const variance = slice.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) / period;
                    const standardDev = Math.sqrt(variance);
                    
                    upperBand.push(average + (standardDev * stdDev));
                    lowerBand.push(average - (standardDev * stdDev));
                    bandwidth.push((standardDev * stdDev * 2) / average * 100);
                }
                
                return { sma, upperBand, lowerBand, bandwidth };
            };
            
            // Volume indicators
            const calculateVolumeIndicators = (prices, volumes) => {
                const volumeMovingAvg = [];
                const volumeRatio = [];
                const priceVolumeStrength = [];
                
                const vmaPeriod = 20;
                
                for (let i = 0; i < vmaPeriod - 1; i++) {
                    volumeMovingAvg.push(null);
                    volumeRatio.push(null);
                    priceVolumeStrength.push(null);
                }
                
                for (let i = vmaPeriod - 1; i < volumes.length; i++) {
                    const volumeSlice = volumes.slice(i - vmaPeriod + 1, i + 1);
                    const avgVolume = volumeSlice.reduce((sum, vol) => sum + vol, 0) / vmaPeriod;
                    volumeMovingAvg.push(avgVolume);
                    
                    const ratio = avgVolume > 0 ? volumes[i] / avgVolume : 0;
                    volumeRatio.push(ratio);
                    
                    if (i > 0) {
                        const priceChange = (prices[i] - prices[i - 1]) / prices[i - 1];
                        const strength = priceChange * ratio;
                        priceVolumeStrength.push(strength);
                    } else {
                        priceVolumeStrength.push(0);
                    }
                }
                
                return { volumeMovingAvg, volumeRatio, priceVolumeStrength };
            };
            
            // Calculate EMA helper function
            const calculateEMA = (period, dataArray) => {
                if (dataArray.length < period) return dataArray.map(() => null);
               
                const k = 2 / (period + 1);
                const emaArray = [];
               
                let ema = dataArray.slice(0, period).reduce((sum, val) => sum + val, 0) / period;
                emaArray.push(...Array(period - 1).fill(null), ema);
               
                for (let i = period; i < dataArray.length; i++) {
                    ema = (dataArray[i] - ema) * k + ema;
                    emaArray.push(ema);
                }
               
                return emaArray;
            };
           
            // Calculate MACD components
            const ema12Values = calculateEMA(12, values);
            const ema26Values = calculateEMA(26, values);
            const macdLine = ema12Values.map((e12, i) =>
                ema26Values[i] !== null && e12 !== null ? e12 - ema26Values[i] : null
            );
            const macdForSignal = macdLine.slice();
            const signalLineValues = calculateEMA(9, macdForSignal.map(v => v || 0));
            const macdHistogram = macdLine.map((macd, i) => 
                macd !== null && signalLineValues[i] !== null ? macd - signalLineValues[i] : null
            );
            
            // Calculate all indicators
            const rsiValues = calculateRSI(values);
            const stochastic = calculateStochastic(highs, lows, closes);
            const bollinger = calculateBollingerBands(values);
            const volumeIndicators = calculateVolumeIndicators(values, volumes);
           
            return data.map((item, index) => {
                let slope30 = null;
                let zscore30 = null;
                let signal = null;
                let currentMacd = macdLine[index];
                let currentSignal = signalLineValues[index];
                
                if (currentMacd === null) {
                    currentSignal = null;
                }
                
                // Calculate 30-period slope and z-score
                if (index >= 29) {
                    const window = values.slice(index - 29, index + 1);
                    const n = window.length;
                    const x = Array.from({length: n}, (_, i) => i);
                   
                    const sumX = x.reduce((a, b) => a + b, 0);
                    const sumY = window.reduce((a, b) => a + b, 0);
                    const sumXY = x.reduce((sum, xi, i) => sum + xi * window[i], 0);
                    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                   
                    if ((n * sumX2 - sumX * sumX) !== 0) {
                        slope30 = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    }
                   
                    const mean = sumY / n;
                    const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
                    const stdDev = Math.sqrt(variance);
                   
                    if (stdDev > 0) {
                        zscore30 = (item.value - mean) / stdDev;
                    }
                }
                
                // Enhanced signal generation
                const rsi = rsiValues[index];
                const stochK = stochastic.stochK[index];
                const stochD = stochastic.stochD[index];
                const volumeRatio = volumeIndicators.volumeRatio[index];
                
                if (currentMacd !== null && currentSignal !== null && rsi !== null && stochK !== null) {
                    let signalStrength = 0;
                    
                    if (currentMacd > currentSignal) signalStrength += 1;
                    else signalStrength -= 1;
                    
                    if (rsi < 30) signalStrength += 2;
                    else if (rsi > 70) signalStrength -= 2;
                    else if (rsi > 50) signalStrength += 0.5;
                    else signalStrength -= 0.5;
                    
                    if (stochK > stochD && stochK < 20) signalStrength += 1;
                    else if (stochK < stochD && stochK > 80) signalStrength -= 1;
                    
                    if (volumeRatio > 1.5) signalStrength *= 1.2;
                    
                    if (signalStrength >= 2) signal = 1;
                    else if (signalStrength <= -2) signal = -1;
                    else signal = 0;
                }
               
                return {
                    ...item,
                    slope_30: slope30,
                    ema12: ema12Values[index],
                    ema26: ema26Values[index],
                    macd: currentMacd,
                    macd_signal: currentSignal,
                    macd_histogram: macdHistogram[index],
                    zscore_30: zscore30,
                    rsi: rsiValues[index],
                    stoch_k: stochastic.stochK[index],
                    stoch_d: stochastic.stochD[index],
                    bb_sma: bollinger.sma[index],
                    bb_upper: bollinger.upperBand[index],
                    bb_lower: bollinger.lowerBand[index],
                    bb_bandwidth: bollinger.bandwidth[index],
                    volume_ma: volumeIndicators.volumeMovingAvg[index],
                    volume_ratio: volumeIndicators.volumeRatio[index],
                    pv_strength: volumeIndicators.priceVolumeStrength[index],
                    signal: signal
                };
            });
        }
       
        // Add new display mode for institutional-grade trend analysis
        function addTrendReversalMode() {
            // This function adds a new display mode specifically for FRED-style trend analysis
            // Called during chart rendering for better institutional-grade analysis
        }
        
        // Enhanced search with better economic indicators
        const enhancedEconomicIndicators = [
            { symbol: 'DTWEXBGS', name: 'Nominal Broad U.S. Dollar Index', source: 'fred', provider: 'fred_direct', 
              description: 'Trade Weighted U.S. Dollar Index: Broad, Goods and Services', units: 'Index Jan 2006=100' },
            { symbol: 'T10Y2Y', name: 'Yield Curve (10Y-2Y Spread)', source: 'fred', provider: 'fred_direct', 
              description: '10-Year Treasury Constant Maturity Minus 2-Year Treasury Constant Maturity', units: 'Percent' },
            { symbol: 'T10YFF', name: 'Term Spread (10Y-Fed Funds)', source: 'fred', provider: 'fred_direct', 
              description: '10-Year Treasury Constant Maturity Minus Federal Funds Rate', units: 'Percent' },
            { symbol: 'MORTGAGE30US', name: '30-Year Fixed Rate Mortgage Average', source: 'fred', provider: 'fred_direct', 
              description: '30-Year Fixed Rate Mortgage Average in the United States', units: 'Percent' },
            { symbol: 'REAINTRATREARAT10Y', name: 'Real Interest Rate', source: 'fred', provider: 'fred_direct', 
              description: '10-Year Treasury Inflation-Indexed Security, Constant Maturity', units: 'Percent' }
        ];
        
        // Add to existing sample symbols
        sampleSymbols.push(...enhancedEconomicIndicators);
        function toggleChartDisplay(event, chartId, displayMode) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
           
            chart.previousDisplayMode = chart.displayMode;
            chart.displayMode = displayMode;
           
            const controlsDiv = event.target.parentElement;
            controlsDiv.querySelectorAll('.display-toggle').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
           
            try {
                updateChartRender(chartId);
            } catch (error) {
                console.error('Display mode change failed:', error);
                chart.displayMode = chart.previousDisplayMode || 'raw';
                showTemporaryMessage(`Failed to switch to ${displayMode} mode`, 'error');
            }
        }
        
        function changeChartType(chartId, chartType) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.chartType = chartType;
            
            const chartWindow = document.getElementById(chartId);
            chartWindow.querySelectorAll('.chart-type-btn').forEach(btn => btn.classList.remove('active'));
            chartWindow.querySelector(`[data-type="${chartType}"]`).classList.add('active');
            
            updateChartRender(chartId);
        }
        
        function changeComparisonMode(chartId, mode) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.comparisonMode = mode;
            
            const chartWindow = document.getElementById(chartId);
            chartWindow.querySelectorAll('[data-comparison]').forEach(btn => btn.classList.remove('active'));
            chartWindow.querySelector(`[data-comparison="${mode}"]`).classList.add('active');
            
            updateChartRender(chartId);
        }
        
        function toggleTheme(chartId) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.theme = chart.theme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', chart.theme);
            
            updateChartRender(chartId);
        }
        
        function toggleFullscreen(chartId) {
            const chart = charts[chartId];
            const chartWindow = document.getElementById(chartId);
            if (!chart || !chartWindow) return;
            
            chart.isFullscreen = !chart.isFullscreen;
            
            if (chart.isFullscreen) {
                chartWindow.classList.add('fullscreen');
                document.body.style.overflow = 'hidden';
            } else {
                chartWindow.classList.remove('fullscreen');
                document.body.style.overflow = 'auto';
            }
            
            setTimeout(() => {
                updateChartRender(chartId);
            }, 100);
        }
        
        // Handle escape key for fullscreen
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                Object.keys(charts).forEach(chartId => {
                    if (charts[chartId].isFullscreen) {
                        toggleFullscreen(chartId);
                    }
                });
            }
        });
       
        function changeTimeframe(event, chartId, timeframe) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
            chart.timeframe = timeframe;
           
            const buttonContainer = document.getElementById(`${chartId}_timeframe_buttons`);
            if (buttonContainer) {
                buttonContainer.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
                if(event.target.tagName === 'BUTTON') event.target.classList.add('active');
            }
            updateChartRender(chartId);
        }
       
        function updateChartSymbols(chartId) {
            const chart = charts[chartId];
            if (!chart) return;
            const symbolsDiv = document.getElementById(`${chartId}_symbols`);
            if (!symbolsDiv) return;
           
            symbolsDiv.innerHTML = chart.symbols.map((s, i) => `
                <div class="chart-symbol-tag">
                    <span class="symbol-color-dot" style="background-color: ${colorPalette[i % colorPalette.length]};"></span>
                    ${s.symbol}
                    <span class="remove-symbol" onclick="removeSymbolFromChart(event, '${chartId}', '${s.symbol}')">×</span>
                </div>`).join('');
        }
       
        function removeSymbolFromChart(event, chartId, symbolToRemove) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;

            chart.symbols = chart.symbols.filter(s => s.symbol !== symbolToRemove);
            delete chart.data[symbolToRemove];
           
            updateChartRender(chartId);
            updateChartSymbols(chartId);
           
            if (chart.symbols.length === 0) {
                document.getElementById(`${chartId}_canvas`).innerHTML = '<div class="chart-message">Search for a financial instrument to add to this chart</div>';
            }
        }
       
        function filterDataByTimeframe(data, timeframe) {
            if (!data || data.length === 0) return data;
           
            const now = new Date();
            let cutoffDate = new Date();
           
            switch(timeframe) {
                case '1D':
                    cutoffDate.setDate(now.getDate() - 1);
                    break;
                case '1W':
                    cutoffDate.setDate(now.getDate() - 7);
                    break;
                case '1M':
                    cutoffDate.setMonth(now.getMonth() - 1);
                    break;
                case '3M':
                    cutoffDate.setMonth(now.getMonth() - 3);
                    break;
                case '6M':
                    cutoffDate.setMonth(now.getMonth() - 6);
                    break;
                case '1Y':
                    cutoffDate.setFullYear(now.getFullYear() - 1);
                    break;
                case '2Y':
                    cutoffDate.setFullYear(now.getFullYear() - 2);
                    break;
                case '5Y':
                    cutoffDate.setFullYear(now.getFullYear() - 5);
                    break;
                case '10Y':
                    cutoffDate.setFullYear(now.getFullYear() - 10);
                    break;
                case 'MAX':
                    return data;
            }
           
            return data.filter(item => new Date(item.date) >= cutoffDate);
        }
       
        // Enhanced chart rendering with comprehensive display modes
        function updateChartRender(chartId) {
            console.log(`🔄 Starting chart render for ${chartId}`);
            
            const chart = charts[chartId];
            const canvasElement = document.getElementById(`${chartId}_canvas`);
            
            if (!canvasElement) {
                console.error('❌ Canvas element not found:', chartId);
                return;
            }
            
            if (!chart) {
                console.error('❌ Chart object not found:', chartId);
                canvasElement.innerHTML = '<div class="chart-message" style="color: #ff4444;">Chart configuration error</div>';
                return;
            }
           
            if (chart.symbols.length === 0) {
                console.log('📊 No symbols in chart, showing default message');
                canvasElement.innerHTML = '<div class="chart-message">Search for a financial instrument to add to this chart</div>';
                if (chart.chartInstance) {
                    try {
                        Plotly.purge(canvasElement);
                    } catch (purgeError) {
                        console.warn('⚠️ Plotly purge warning:', purgeError);
                    }
                }
                return;
            }
           
            try {
                const traces = [];
                const displayMode = chart.displayMode || 'raw';
                let yLabel = 'Value';
                let layout = {};
                
                console.log(`📊 Processing ${chart.symbols.length} symbols in ${displayMode} mode`);
           
                chart.symbols.forEach((s, index) => {
                    try {
                        console.log(`🔄 Processing symbol ${s.symbol} (${index + 1}/${chart.symbols.length})`);
                        
                        const symbolData = chart.data[s.symbol];
                        if (!symbolData || symbolData.length === 0) {
                            console.warn(`⚠️ No data for symbol ${s.symbol}`);
                            return;
                        }
                        
                        const filteredData = filterDataByTimeframe(symbolData, chart.timeframe);
                        if (filteredData.length === 0) {
                            console.warn(`⚠️ No data after timeframe filter for ${s.symbol}`);
                            return;
                        }
                        
                        const lineColor = colorPalette[index % colorPalette.length];
                        let yData, hoverTemplate;
                        
                        // Enhanced display mode processing
                        try {
                            const chartType = chart.chartType || 'line';
                            const comparisonMode = chart.comparisonMode || 'absolute';
                            
                            // Declare variables outside switch to avoid const conflicts
                            let processedData = filteredData;
                            let xDataForTrace = filteredData;
                            
                            switch (displayMode) {
                                case 'raw':
                                    yData = filteredData.map(d => d.value).filter(v => v !== null && !isNaN(v) && isFinite(v));
                                    yLabel = 'Price/Value';
                                    hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                                    xDataForTrace = filteredData; // Set x-axis data for raw mode
                                    // Note: Comparison mode transformations will be applied after trace creation
                                    break;
                                    
                                case 'pct_change':
                                    // Calculate year-over-year percentage change like FRED charts
                                    processedData = filteredData.map((item, idx) => {
                                        if (idx < 252) return { ...item, yoy_change: null }; // Need 1 year of data
                                        const yearAgoValue = filteredData[idx - 252]?.value;
                                        if (!yearAgoValue || yearAgoValue === 0) return { ...item, yoy_change: null };
                                        const yoyChange = ((item.value - yearAgoValue) / yearAgoValue) * 100;
                                        return { ...item, yoy_change: yoyChange };
                                    }).filter(d => d.yoy_change !== null && !isNaN(d.yoy_change) && isFinite(d.yoy_change));
                                    
                                    if (processedData.length === 0) {
                                        console.warn(`⚠️ No YoY change data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    yData = processedData.map(d => d.yoy_change);
                                    yLabel = 'Year-over-Year % Change';
                                    hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>YoY Change: %{y:.2f}%<extra></extra>`;
                                    xDataForTrace = processedData;
                                    
                                    // Add zero line and trend zones
                                    if (index === 0) {
                                        traces.push({
                                            x: processedData.map(d => d.date),
                                            y: processedData.map(() => 0),
                                            type: 'scatter',
                                            mode: 'lines',
                                            name: 'Zero Line',
                                            line: { color: '#888', width: 2, dash: 'solid' },
                                            showlegend: false,
                                            hoverinfo: 'skip'
                                        });
                                        
                                        // Add recession/expansion zones
                                        traces.push({
                                            x: processedData.map(d => d.date),
                                            y: processedData.map(() => 10),
                                            type: 'scatter',
                                            mode: 'lines',
                                            name: 'Strong Growth (+10%)',
                                            line: { color: 'green', width: 1, dash: 'dot' },
                                            showlegend: false,
                                            hoverinfo: 'skip'
                                        });
                                        
                                        traces.push({
                                            x: processedData.map(d => d.date),
                                            y: processedData.map(() => -5),
                                            type: 'scatter',
                                            mode: 'lines',
                                            name: 'Contraction (-5%)',
                                            line: { color: 'red', width: 1, dash: 'dot' },
                                            showlegend: false,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                    break;
                                    
                                case 'unit_change':
                                    // Calculate momentum and trend strength like institutional analysis
                                    processedData = filteredData.map((item, idx) => {
                                        if (idx < 20) return { ...item, momentum: null, trend_strength: null };
                                        
                                        // 20-period momentum
                                        const twentyPeriodsAgo = filteredData[idx - 20]?.value;
                                        if (!twentyPeriodsAgo) return { ...item, momentum: null, trend_strength: null };
                                        
                                        const momentum = item.value - twentyPeriodsAgo;
                                        
                                        // Trend strength using linear regression slope
                                        const window = filteredData.slice(idx - 19, idx + 1);
                                        const x = Array.from({length: 20}, (_, i) => i);
                                        const y = window.map(d => d.value);
                                        
                                        const n = 20;
                                        const sumX = x.reduce((a, b) => a + b, 0);
                                        const sumY = y.reduce((a, b) => a + b, 0);
                                        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                                        const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                                        
                                        let slope = 0;
                                        if ((n * sumX2 - sumX * sumX) !== 0) {
                                            slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                                        }
                                        
                                        // Normalize slope by price level for trend strength
                                        const trendStrength = (slope / item.value) * 10000; // Scale for visibility
                                        
                                        return { ...item, momentum: momentum, trend_strength: trendStrength };
                                    }).filter(d => d.momentum !== null && !isNaN(d.momentum) && isFinite(d.momentum));
                                    
                                    if (processedData.length === 0) {
                                        console.warn(`⚠️ No momentum data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    yData = processedData.map(d => d.trend_strength);
                                    yLabel = 'Trend Strength (Institutional Grade)';
                                    hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Trend: %{y:.3f}<br>Momentum: ${processedData[0].momentum?.toFixed(2)}<extra></extra>`;
                                    xDataForTrace = processedData;
                                    
                                    // Add trend reversal zones
                                    if (index === 0) {
                                        traces.push({
                                            x: processedData.map(d => d.date),
                                            y: processedData.map(() => 0),
                                            type: 'scatter',
                                            mode: 'lines',
                                            name: 'Neutral Trend',
                                            line: { color: '#888', width: 2, dash: 'solid' },
                                            showlegend: false,
                                            hoverinfo: 'skip'
                                        });
                                        
                                        // Strong uptrend zone
                                        traces.push({
                                            x: processedData.map(d => d.date),
                                            y: processedData.map(() => 2),
                                            type: 'scatter',
                                            mode: 'lines',
                                            name: 'Strong Uptrend',
                                            line: { color: 'green', width: 1, dash: 'dot' },
                                            showlegend: false,
                                            hoverinfo: 'skip'
                                        });
                                        
                                        // Strong downtrend zone
                                        traces.push({
                                            x: processedData.map(d => d.date),
                                            y: processedData.map(() => -2),
                                            type: 'scatter',
                                            mode: 'lines',
                                            name: 'Strong Downtrend',
                                            line: { color: 'red', width: 1, dash: 'dot' },
                                            showlegend: false,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                    break;
                                    
                                case 'rsi':
                                    processedData = filteredData.filter(d => d.rsi !== null && d.rsi !== undefined && !isNaN(d.rsi));
                                    if (processedData.length === 0) {
                                        console.warn(`⚠️ No RSI data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    yData = processedData.map(d => d.rsi);
                                    yLabel = 'RSI (%)';
                                    hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>RSI: %{y:.1f}%<extra></extra>`;
                                    xDataForTrace = processedData;
                                    
                                    if (index === 0) {
                                        [70, 50, 30].forEach((level, i) => {
                                            const colors = ['red', 'gray', 'green'];
                                            const names = ['Overbought (70)', 'Midline (50)', 'Oversold (30)'];
                                            traces.push({
                                                x: processedData.map(d => d.date),
                                                y: processedData.map(() => level),
                                                type: 'scatter',
                                                mode: 'lines',
                                                name: names[i],
                                                line: { color: colors[i], width: 1, dash: i === 1 ? 'dot' : 'dash' },
                                                showlegend: false,
                                                hoverinfo: 'skip'
                                            });
                                        });
                                    }
                                    break;
                                    
                                case 'macd':
                                    const validMacdData = filteredData.filter(d => d.macd !== null && d.macd !== undefined && !isNaN(d.macd));
                                    if (validMacdData.length === 0) {
                                        console.warn(`⚠️ No MACD data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    // MACD Line
                                    traces.push({
                                        x: validMacdData.map(d => d.date),
                                        y: validMacdData.map(d => d.macd),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} MACD`,
                                        line: { color: lineColor, width: 2 },
                                        hovertemplate: `<b>${s.symbol} MACD</b><br>Date: %{x}<br>MACD: %{y:.4f}<extra></extra>`
                                    });
                                    
                                    // Signal Line
                                    traces.push({
                                        x: validMacdData.map(d => d.date),
                                        y: validMacdData.map(d => d.macd_signal),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} Signal`,
                                        line: { color: lineColor, width: 1, dash: 'dash' },
                                        hovertemplate: `<b>${s.symbol} Signal</b><br>Date: %{x}<br>Signal: %{y:.4f}<extra></extra>`
                                    });
                                    
                                    // Histogram
                                    traces.push({
                                        x: validMacdData.map(d => d.date),
                                        y: validMacdData.map(d => d.macd_histogram),
                                        type: 'bar',
                                        name: `${s.symbol} Histogram`,
                                        marker: { 
                                            color: validMacdData.map(d => d.macd_histogram > 0 ? '#00ff88' : '#ff4444'),
                                            opacity: 0.7
                                        },
                                        hovertemplate: `<b>${s.symbol} Histogram</b><br>Date: %{x}<br>Histogram: %{y:.4f}<extra></extra>`
                                    });
                                    
                                    yLabel = 'MACD';
                                    return; // Skip normal trace creation for MACD
                                    
                                case 'bollinger':
                                    const validBbData = filteredData.filter(d => d.bb_sma !== null && d.bb_sma !== undefined && !isNaN(d.bb_sma));
                                    if (validBbData.length === 0) {
                                        console.warn(`⚠️ No Bollinger Bands data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    // Upper Band
                                    traces.push({
                                        x: validBbData.map(d => d.date),
                                        y: validBbData.map(d => d.bb_upper),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} Upper BB`,
                                        line: { color: lineColor, width: 1, dash: 'dot' },
                                        showlegend: false,
                                        hoverinfo: 'skip'
                                    });
                                    
                                    // SMA (Middle Band)
                                    traces.push({
                                        x: validBbData.map(d => d.date),
                                        y: validBbData.map(d => d.bb_sma),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} BB SMA`,
                                        line: { color: lineColor, width: 2 },
                                        hovertemplate: `<b>${s.symbol} BB SMA</b><br>Date: %{x}<br>SMA: %{y:.4f}<extra></extra>`
                                    });
                                    
                                    // Lower Band
                                    traces.push({
                                        x: validBbData.map(d => d.date),
                                        y: validBbData.map(d => d.bb_lower),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} Lower BB`,
                                        line: { color: lineColor, width: 1, dash: 'dot' },
                                        fill: 'tonexty',
                                        fillcolor: `${lineColor}20`,
                                        showlegend: false,
                                        hoverinfo: 'skip'
                                    });
                                    
                                    // Price line
                                    traces.push({
                                        x: validBbData.map(d => d.date),
                                        y: validBbData.map(d => d.value),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} Price`,
                                        line: { color: '#ffffff', width: 2 },
                                        hovertemplate: `<b>${s.symbol} Price</b><br>Date: %{x}<br>Price: %{y:.4f}<extra></extra>`
                                    });
                                    
                                    yLabel = 'Price with Bollinger Bands';
                                    return; // Skip normal trace creation
                                    
                                case 'stochastic':
                                    const validStochData = filteredData.filter(d => d.stoch_k !== null && d.stoch_k !== undefined && !isNaN(d.stoch_k));
                                    if (validStochData.length === 0) {
                                        console.warn(`⚠️ No Stochastic data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    // %K Line
                                    traces.push({
                                        x: validStochData.map(d => d.date),
                                        y: validStochData.map(d => d.stoch_k),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} %K`,
                                        line: { color: lineColor, width: 2 },
                                        hovertemplate: `<b>${s.symbol} %K</b><br>Date: %{x}<br>%K: %{y:.1f}<extra></extra>`
                                    });
                                    
                                    // %D Line
                                    traces.push({
                                        x: validStochData.map(d => d.date),
                                        y: validStochData.map(d => d.stoch_d),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} %D`,
                                        line: { color: lineColor, width: 1, dash: 'dash' },
                                        hovertemplate: `<b>${s.symbol} %D</b><br>Date: %{x}<br>%D: %{y:.1f}<extra></extra>`
                                    });
                                    
                                    // Reference lines
                                    if (index === 0) {
                                        [80, 20].forEach((level, i) => {
                                            traces.push({
                                                x: validStochData.map(d => d.date),
                                                y: validStochData.map(() => level),
                                                type: 'scatter',
                                                mode: 'lines',
                                                name: level === 80 ? 'Overbought (80)' : 'Oversold (20)',
                                                line: { color: level === 80 ? 'red' : 'green', width: 1, dash: 'dash' },
                                                showlegend: false,
                                                hoverinfo: 'skip'
                                            });
                                        });
                                    }
                                    
                                    yLabel = 'Stochastic %';
                                    return; // Skip normal trace creation
                                    
                                case 'volume':
                                    if (s.symbol.includes('RATE') || s.symbol.includes('GDP') || s.symbol === 'FEDFUNDS') {
                                        console.warn(`⚠️ Volume analysis not applicable for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    const validVolumeData = filteredData.filter(d => d.volume !== null && d.volume !== undefined && d.volume > 0);
                                    if (validVolumeData.length === 0) {
                                        console.warn(`⚠️ No volume data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    // Volume bars
                                    traces.push({
                                        x: validVolumeData.map(d => d.date),
                                        y: validVolumeData.map(d => d.volume),
                                        type: 'bar',
                                        name: `${s.symbol} Volume`,
                                        marker: { 
                                            color: validVolumeData.map(d => d.daily_pct_change > 0 ? '#00ff88' : '#ff4444'),
                                            opacity: 0.7
                                        },
                                        hovertemplate: `<b>${s.symbol} Volume</b><br>Date: %{x}<br>Volume: %{y:,.0f}<extra></extra>`
                                    });
                                    
                                    // Volume MA
                                    traces.push({
                                        x: validVolumeData.map(d => d.date),
                                        y: validVolumeData.map(d => d.volume_ma),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} Volume MA`,
                                        line: { color: lineColor, width: 2 },
                                        hovertemplate: `<b>${s.symbol} Volume MA</b><br>Date: %{x}<br>Volume MA: %{y:,.0f}<extra></extra>`
                                    });
                                    
                                    yLabel = 'Volume';
                                    return; // Skip normal trace creation
                                    
                                case 'signals':
                                    const validSignalData = filteredData.filter(d => d.signal !== null && d.signal !== undefined);
                                    if (validSignalData.length === 0) {
                                        console.warn(`⚠️ No signal data for ${s.symbol}`);
                                        return;
                                    }
                                    
                                    // Price line
                                    traces.push({
                                        x: validSignalData.map(d => d.date),
                                        y: validSignalData.map(d => d.value),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: `${s.symbol} Price`,
                                        line: { color: lineColor, width: 2 },
                                        hovertemplate: `<b>${s.symbol}</b><br>Date: %{x}<br>Price: %{y:.4f}<extra></extra>`
                                    });
                                    
                                    // Buy signals
                                    const buySignals = validSignalData.filter(d => d.signal === 1);
                                    if (buySignals.length > 0) {
                                        traces.push({
                                            x: buySignals.map(d => d.date),
                                            y: buySignals.map(d => d.value),
                                            type: 'scatter',
                                            mode: 'markers',
                                            name: `${s.symbol} Buy`,
                                            marker: { 
                                                color: '#00ff88',
                                                size: 8,
                                                symbol: 'triangle-up'
                                            },
                                            hovertemplate: `<b>${s.symbol} BUY SIGNAL</b><br>Date: %{x}<br>Price: %{y:.4f}<extra></extra>`
                                        });
                                    }
                                    
                                    // Sell signals
                                    const sellSignals = validSignalData.filter(d => d.signal === -1);
                                    if (sellSignals.length > 0) {
                                        traces.push({
                                            x: sellSignals.map(d => d.date),
                                            y: sellSignals.map(d => d.value),
                                            type: 'scatter',
                                            mode: 'markers',
                                            name: `${s.symbol} Sell`,
                                            marker: { 
                                                color: '#ff4444',
                                                size: 8,
                                                symbol: 'triangle-down'
                                            },
                                            hovertemplate: `<b>${s.symbol} SELL SIGNAL</b><br>Date: %{x}<br>Price: %{y:.4f}<extra></extra>`
                                        });
                                    }
                                    
                                    yLabel = 'Price with Trading Signals';
                                    return; // Skip normal trace creation
                                    
                                default:
                                    yData = filteredData.map(d => d.value).filter(v => v !== null && !isNaN(v) && isFinite(v));
                                    yLabel = 'Value';
                                    hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                            }
                            
                            if (yData.length === 0) {
                                console.warn(`⚠️ No valid Y data for ${s.symbol} in ${displayMode} mode`);
                                return;
                            }
                            
                        } catch (modeError) {
                            console.error(`❌ Display mode error for ${s.symbol}:`, modeError);
                            return;
                        }
                        
                        // Create trace with enhanced chart types
                        try {
                            const chartType = chart.chartType || 'line';
                            const comparisonMode = chart.comparisonMode || 'absolute';
                            let trace;
                            
                            if (chartType === 'candlestick' && displayMode === 'raw' && filteredData[0]?.open !== undefined) {
                                trace = {
                                    x: filteredData.map(d => d.date),
                                    open: filteredData.map(d => d.open),
                                    high: filteredData.map(d => d.high),
                                    low: filteredData.map(d => d.low),
                                    close: filteredData.map(d => d.close),
                                    type: 'candlestick',
                                    name: s.symbol,
                                    increasing: { line: { color: '#00ff88' } },
                                    decreasing: { line: { color: '#ff4444' } }
                                };
                            } else if (chartType === 'ohlc' && displayMode === 'raw' && filteredData[0]?.open !== undefined) {
                                trace = {
                                    x: filteredData.map(d => d.date),
                                    open: filteredData.map(d => d.open),
                                    high: filteredData.map(d => d.high),
                                    low: filteredData.map(d => d.low),
                                    close: filteredData.map(d => d.close),
                                    type: 'ohlc',
                                    name: s.symbol,
                                    increasing: { line: { color: '#00ff88' } },
                                    decreasing: { line: { color: '#ff4444' } }
                                };
                            } else if (chartType === 'area') {
                                trace = {
                                    x: filteredData.map(d => d.date),
                                    y: yData,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: s.symbol,
                                    hovertemplate: hoverTemplate,
                                    line: { color: lineColor, width: 2 },
                                    fill: 'tozeroy',
                                    fillcolor: `${lineColor}40`
                                };
                            } else if (chartType === 'mountain') {
                                trace = {
                                    x: filteredData.map(d => d.date),
                                    y: yData,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: s.symbol,
                                    hovertemplate: hoverTemplate,
                                    line: { color: lineColor, width: 2 },
                                    fill: 'tonexty',
                                    fillcolor: `${lineColor}30`
                                };
                                
                                // Add base line for first trace
                                if (index === 0) {
                                    const minValue = Math.min(...yData);
                                    traces.push({
                                        x: filteredData.map(d => d.date),
                                        y: filteredData.map(() => minValue),
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: { color: 'transparent' },
                                        showlegend: false,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Default line chart - use the correct data source
                                trace = {
                                    x: xDataForTrace.map(d => d.date),
                                    y: yData,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: s.symbol,
                                    hovertemplate: hoverTemplate,
                                    line: { color: lineColor, width: 2 }
                                };
                            }
                            
                            // Apply comparison mode transformations AFTER chart type
                            if (comparisonMode === 'percentage' && trace.y && displayMode === 'raw') {
                                const baseValue = trace.y[0];
                                if (baseValue && baseValue !== 0) {
                                    trace.y = trace.y.map(v => ((v - baseValue) / Math.abs(baseValue)) * 100);
                                    yLabel = 'Percentage Change from Start (%)';
                                    trace.hovertemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Change: %{y:.2f}%<extra></extra>`;
                                }
                            } else if (comparisonMode === 'indexed' && trace.y && displayMode === 'raw') {
                                const baseValue = trace.y[0];
                                if (baseValue && baseValue !== 0) {
                                    trace.y = trace.y.map(v => (v / baseValue) * 100);
                                    yLabel = 'Indexed (Base = 100)';
                                    trace.hovertemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Index: %{y:.2f}<extra></extra>`;
                                }
                            }
                            
                            // Add color coding for trend analysis modes
                            if (displayMode === 'pct_change' || displayMode === 'unit_change') {
                                if (chartType === 'line') {
                                    trace.marker = {
                                        color: yData.map(v => {
                                            if (v > 2) return '#00ff88';      // Strong positive
                                            if (v > 0) return '#88ff88';      // Weak positive  
                                            if (v < -2) return '#ff4444';     // Strong negative
                                            if (v < 0) return '#ff8888';      // Weak negative
                                            return '#888888';                 // Neutral
                                        }),
                                        size: 3
                                    };
                                    trace.mode = 'lines+markers';
                                }
                                
                                // Add trend zones for better institutional-grade analysis
                                trace.line.width = 3; // Thicker line for trend analysis
                            }
                            
                            traces.push(trace);
                            console.log(`✅ Added ${chartType} trace for ${s.symbol}`);
                            
                        } catch (traceError) {
                            console.error(`❌ Trace creation error for ${s.symbol}:`, traceError);
                        }
                        
                    } catch (symbolError) {
                        console.error(`❌ Symbol processing error for ${s.symbol}:`, symbolError);
                    }
                });
           
                if (traces.length === 0) {
                    console.warn('⚠️ No traces created, showing no data message');
                    canvasElement.innerHTML = '<div class="chart-message">No data to display for selected timeframe and mode</div>';
                    return;
                }
                
                console.log(`✅ Created ${traces.length} traces, preparing to render`);
           
                const finalLayout = {
                    title: {
                        text: `${displayMode.replace('_', ' ').toUpperCase()} VIEW - ${chart.chartType?.toUpperCase() || 'LINE'} - ${chart.comparisonMode?.toUpperCase() || 'ABSOLUTE'}`,
                        font: { color: chart.theme === 'light' ? '#333' : '#fff', size: 14 },
                        x: 0.5
                    },
                    paper_bgcolor: chart.theme === 'light' ? '#ffffff' : '#0a0a0a',
                    plot_bgcolor: chart.theme === 'light' ? '#ffffff' : '#0a0a0a',
                    font: { color: chart.theme === 'light' ? '#333' : '#aaa', size: 12 },
                    margin: { t: 60, r: 80, b: 60, l: 80 },
                    xaxis: {
                        type: 'date',
                        gridcolor: chart.theme === 'light' ? '#f0f0f0' : '#22222250',
                        tickfont: { color: chart.theme === 'light' ? '#666' : '#888' },
                        rangeslider: { visible: false }
                    },
                    yaxis: {
                        title: { text: yLabel, font: { color: chart.theme === 'light' ? '#666' : '#aaa' } },
                        gridcolor: chart.theme === 'light' ? '#f0f0f0' : '#22222250',
                        tickfont: { color: chart.theme === 'light' ? '#666' : '#888' },
                        zeroline: true,
                        zerolinecolor: chart.theme === 'light' ? '#ccc' : '#444',
                        zerolinewidth: 1
                    },
                    hovermode: 'x unified',
                    showlegend: true,
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1,
                        bgcolor: chart.theme === 'light' ? 'rgba(255,255,255,0.9)' : 'rgba(10,10,10,0.8)',
                        bordercolor: chart.theme === 'light' ? '#ddd' : '#333',
                        borderwidth: 1,
                        font: { size: 11, color: chart.theme === 'light' ? '#333' : '#fff' }
                    },
                    height: chart.isFullscreen ? window.innerHeight - 120 : 500,
                    autosize: true,
                    ...layout
                };
           
                const config = {
                    responsive: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['select2d', 'lasso2d', 'toImage'],
                    displayModeBar: true
                };
           
                if (canvasElement.querySelector('.chart-message')) {
                    canvasElement.innerHTML = '';
                }
                
                console.log('🎨 Rendering chart with Plotly...');
           
                Plotly.react(canvasElement, traces, finalLayout, config)
                    .then(gd => {
                        charts[chartId].chartInstance = gd;
                        console.log(`✅ Chart ${chartId} rendered successfully`);
                    })
                    .catch(err => {
                        console.error("❌ Plotly rendering error:", err);
                        canvasElement.innerHTML = `
                            <div class="chart-message" style="color: #ff4444;">
                                ❌ Chart rendering error<br>
                                <small>${err.message}</small><br>
                                <button onclick="updateChartRender('${chartId}')" 
                                        style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                                    🔄 Retry Render
                                </button>
                            </div>
                        `;
                    });
                    
            } catch (error) {
                console.error("❌ Complete chart render failure:", error);
                canvasElement.innerHTML = `
                    <div class="chart-message" style="color: #ff4444;">
                        ❌ Chart system error<br>
                        <small>${error.message}</small><br>
                        <button onclick="updateChartRender('${chartId}')" 
                                style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                            🔄 Retry
                        </button>
                    </div>
                `;
            }
        }
       
        // Utility functions
        function showTemporaryMessage(text, type = 'info') {
            const popup = document.createElement('div');
            popup.className = `message-popup ${type}`;
            popup.textContent = text;
            document.body.appendChild(popup);
           
            setTimeout(() => popup.remove(), 3000);
        }
       
        // Hide search results when clicking outside
        document.addEventListener('click', function(event) {
            const searchBox = document.getElementById('searchBox');
            const searchResults = document.getElementById('searchResults');
           
            if (!searchBox.contains(event.target) && !searchResults.contains(event.target)) {
                searchResults.style.display = 'none';
            }
        });
       
        // Initialize on page load
        window.onload = init;
    </script>
</body>
</html>