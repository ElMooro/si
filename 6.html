case 'stochastic':
                            processedData = filteredData.filter(d => d.stoch_k !== null && !isNaN(d.stoch_k));
                            if (processedData.length === 0) return;
                            
                            // %K Line with color coding
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.stoch_k),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} %K`,
                                line: { 
                                    color: lineColor, 
                                    width: 2 
                                },
                                hovertemplate: `<b>${s.symbol} %K</b><br>Date: %{x}<br>%K: %{y:.1f}<br>Zone: %{text}<extra></extra>`,
                                text: processedData.map(d => {
                                    if (d.stoch_k < 20) return 'OVERSOLD';
                                    else if (d.stoch_k > 80) return 'OVERBOUGHT';
                                    else return 'NEUTRAL';
                                })
                            });
                            
                            // %D Line
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.stoch_d),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} %D`,
                                line: { color: lineColor, width: 1, dash: 'dash' },
                                hovertemplate: `<b>${s.symbol} %D</b><br>Date: %{x}<br>%D: %{y:.1f}<extra></extra>`
                            });
                            
                            // Reference lines with reversal zones
                            if (index === 0) {
                                // Overbought zone
                                traces.push({
                                    x: processedData.map(d => d.date),
                                    y: processedData.map(() => 80),
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: 'Overbought (80)',
                                    line: { color: '#ff4444', width: 1, dash: 'dash' },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                                
                                // Oversold zone
                                traces.push({
                                    x: processedData.map(d => d.date),
                                    y: processedData.map(() => 20),
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: 'Oversold (20)',
                                    line: { color: '#00ff88', width: 1, dash: 'dash' },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                            
                            // Highlight reversal points
                            const reversalPoints = processedData.filter((d, i) => {
                                if (i === 0 || !d.stoch_reversal) return false;
                                // K crosses D in extreme zones
                                const prevK = processedData[i-1]?.stoch_k;
                                const prevD = processedData[i-1]?.stoch_d;
                                const currK = d.stoch_k;
                                const currD = d.stoch_d;
                                
                                if (d.stoch_reversal === 1 && prevK && prevD && currK && currD) {
                                    return prevK <= prevD && currK > currD; // Bullish cross in oversold
                                } else if (d.stoch_reversal === -1 && prevK && prevD && currK && currD) {
                                    return prevK >= prevD && currK < currD; // Bearish cross in overbought
                                }
                                return false;
                            });
                            
                            if (reversalPoints.length > 0) {
                                traces.push({
                                    x: reversalPoints.map(d => d.date),
                                    y: reversalPoints.map(d => d.stoch_k),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: 'Stochastic Reversals',
                                    marker: { 
                                        color: reversalPoints.map(d => d.stoch_reversal > 0 ? '#00ff88' : '#ff4444'),
                                        size: 14,
                                        symbol: 'diamond-open',
                                        line: { width: 2 }
                                    },
                                    showlegend: true,
                                    hovertemplate: `<b>%{text} REVERSAL</b><br>Date: %{x}<br>%K: %{y:.1f}<extra></extra>`,
                                    text: reversalPoints.map(d => d.stoch_reversal > 0 ? 'BULLISH' : 'BEARISH')
                                });
                            }
                            
                            yLabel = 'Stochastic % - Reversal Point Detection';
                            return;
                <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBB Financial Intelligence Platform v12.0 - 72,846+ Indicators</title>
    
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Enhanced Header */
        .header {
            background: linear-gradient(135deg, #121212 0%, #1e1e2e 100%);
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.1);
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 6px 12px;
            border-radius: 6px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            animation: pulse 2s infinite;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
        }
        
        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 71px);
        }
        
        /* Enhanced Search Section */
        .search-section {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 30px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }
        .search-container {
            position: relative;
            width: 100%;
            max-width: 900px;
        }
        .search-box {
            width: 100%;
            padding: 20px 60px 20px 25px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #333;
            color: #fff;
            border-radius: 15px;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .search-box:focus {
            outline: none;
            border-color: #00ff88;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.3);
        }
        .search-icon {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            color: #00ff88;
            font-size: 20px;
        }
        
        /* Data Sources Display */
        .data-sources {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
            max-width: 1200px;
        }
        .source-badge {
            background: rgba(0, 255, 136, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        .source-badge:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.2);
        }
        .source-icon {
            font-size: 16px;
        }
        
        /* Search Results */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            margin-top: 8px;
            max-height: 600px;
            overflow-y: auto;
            background: rgba(24, 24, 40, 0.95);
            border: 1px solid #00ff88;
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(0, 255, 136, 0.2);
            backdrop-filter: blur(20px);
        }
        .search-loading {
            padding: 30px;
            text-align: center;
            color: #00ff88;
            font-size: 16px;
        }
        .search-item {
            padding: 18px 25px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-item:last-child { border-bottom: none; }
        .search-item:hover { 
            background: rgba(0, 255, 136, 0.1);
            transform: translateX(5px);
        }
        .search-item-left {
            flex: 1;
        }
        .search-item-symbol {
            font-weight: bold;
            color: #00ff88;
            font-size: 16px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
        }
        .search-item-name {
            font-size: 14px;
            color: #ddd;
            margin-bottom: 6px;
        }
        .search-item-description {
            font-size: 12px;
            color: #aaa;
            line-height: 1.4;
        }
        .search-item-source {
            font-size: 11px;
            color: #fff;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            padding: 6px 12px;
            border-radius: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }
        
        /* Category Headers */
        .category-header {
            padding: 10px 25px;
            font-size: 11px;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* System Status */
        .system-status {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }
        .status-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            text-align: center;
            min-width: 150px;
        }
        .status-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
        }
        .status-label {
            font-size: 12px;
            color: #aaa;
        }
        
        /* Charts Area */
        .charts-area {
            flex: 1;
            padding: 25px;
            background: linear-gradient(135deg, #0f0f1f 0%, #1a1a2e 100%);
            min-height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .chart-grid {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            width: 100%;
        }
        
        /* Enhanced Chart Styles */
        .chart-window {
            background: linear-gradient(135deg, rgba(19, 19, 35, 0.9) 0%, rgba(22, 33, 62, 0.9) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 25px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 600px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }
        .chart-window.active-chart {
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            transform: translateY(-5px);
        }
        .chart-window.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            border-radius: 0;
            padding: 15px;
        }
        .chart-window.fullscreen .chart-canvas {
            height: calc(100vh - 150px);
        }
        
        /* Chart Header */
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .chart-title-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-grow: 1;
        }
        .chart-title {
            font-size: 20px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: bold;
        }
        .chart-symbols {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .chart-symbol-tag {
            background: rgba(0, 255, 136, 0.1);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid #00ff88;
            backdrop-filter: blur(5px);
        }
        .symbol-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }
        .remove-symbol {
            cursor: pointer;
            color: #ff5555;
            font-weight: bold;
            margin-left: 8px;
            opacity: 0.7;
            font-size: 16px;
            transition: all 0.2s;
        }
        .remove-symbol:hover { 
            opacity: 1; 
            transform: scale(1.2);
        }
        
        /* Enhanced Controls */
        .chart-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .timeframe-buttons {
            display: flex;
            gap: 3px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .timeframe-btn {
            background: transparent;
            border: none;
            color: #888;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            border-radius: 6px;
            font-weight: bold;
        }
        .timeframe-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            color: #fff;
        }
        .timeframe-btn.active {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            font-weight: bold;
        }
        
        /* Display Controls */
        .chart-display-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .display-toggle {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }
        .display-toggle:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #fff;
        }
        .display-toggle.active {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            border-color: #00ff88;
            font-weight: bold;
        }
        
        /* Chart Type Controls */
        .chart-type-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .chart-type-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .chart-type-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }
        .chart-type-btn.active {
            background: linear-gradient(45deg, #0066cc, #0088ff);
            color: #fff;
            border-color: #0066cc;
        }
        
        /* Comparison Controls */
        .comparison-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .comparison-label {
            font-size: 11px;
            color: #888;
            margin-right: 5px;
        }
        
        /* Chart Canvas */
        .chart-canvas {
            background: rgba(10, 10, 26, 0.8);
            border-radius: 10px;
            height: 550px;
            flex-grow: 1;
            min-height: 500px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chart-message {
            color: #00ff88;
            font-size: 18px;
            text-align: center;
            padding: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        /* Buttons */
        .control-btn {
            background: linear-gradient(45deg, rgba(0, 255, 136, 0.1), rgba(0, 204, 255, 0.1));
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 10px 16px;
            cursor: pointer;
            border-radius: 8px;
            font-size: 12px;
            transition: all 0.3s;
            font-weight: bold;
            backdrop-filter: blur(5px);
        }
        .control-btn:hover {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }
        .close-btn {
            background: linear-gradient(45deg, #ff4444, #ff6666);
            border-color: #ff4444;
            color: #fff;
            width: 35px;
            height: 35px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            line-height: 1;
        }
        .close-btn:hover { 
            background: linear-gradient(45deg, #ff6666, #ff8888);
            transform: scale(1.1);
        }
        
        /* Loading Animation */
        .loading-pulse { 
            animation: pulse-glow 1.5s infinite ease-in-out; 
        }
        @keyframes pulse-glow {
            0%, 100% { opacity: 0.6; color: #00ff88; }
            50% { opacity: 1; color: #00ccff; }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: rgba(15, 15, 31, 0.5); }
        ::-webkit-scrollbar-thumb { 
            background: linear-gradient(45deg, #00ff88, #00ccff); 
            border-radius: 5px; 
        }
        ::-webkit-scrollbar-thumb:hover { 
            background: linear-gradient(45deg, #00ccff, #ff6b6b); 
        }
        
        /* Message Popup */
        .message-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(34, 34, 50, 0.95);
            border: 2px solid #00ff88;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 2000;
            animation: slideInAndOut 4s ease-in-out forwards;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }
        .message-popup.error { 
            border-color: #ff4444; 
            color: #ff6666;
            box-shadow: 0 10px 30px rgba(255, 68, 68, 0.3);
        }
        
        @keyframes slideInAndOut {
            0% { transform: translateX(120%); opacity: 0; }
            15%, 85% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(120%); opacity: 0; }
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .chart-window {
                max-width: 95%;
            }
        }
        @media (max-width: 768px) {
            .search-container {
                max-width: 100%;
            }
            .header {
                flex-direction: column;
                gap: 10px;
            }
            .system-status {
                flex-direction: column;
                align-items: center;
            }
            .data-sources {
                justify-content: center;
            }
            .chart-window {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">🚀 OPENBB FINANCIAL INTELLIGENCE • 72,846+ INDICATORS</div>
        <div class="header-controls">
            <div class="status-indicator" id="apiStatus">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Dual System Online</span>
            </div>
            <button class="control-btn" onclick="addNewChart()">+ New Chart</button>
            <span id="clock" style="color: #00ff88; font-size: 14px; font-weight: bold;"></span>
        </div>
    </div>

    <div class="main-container">
        <div class="search-section">
            <div class="system-status">
                <div class="status-card">
                    <div class="status-value" id="totalIndicators">72,846+</div>
                    <div class="status-label">Total Indicators</div>
                </div>
                <div class="status-card">
                    <div class="status-value" id="systemStatus">DUAL ONLINE</div>
                    <div class="status-label">System Status</div>
                </div>
                <div class="status-card">
                    <div class="status-value" id="apiResponse">~350ms</div>
                    <div class="status-label">Response Time</div>
                </div>
                <div class="status-card">
                    <div class="status-value" id="corsStatus">VERIFIED</div>
                    <div class="status-label">CORS Support</div>
                </div>
            </div>
            
            <div class="search-container">
                <input type="text" class="search-box" id="searchBox"
                       placeholder="🔍 Search 72,846+ Financial Indicators (FEDFUNDS, Treasury, GDP, AAPL, University of Michigan, ICE BofA, Bitcoin, etc.)..."
                       onkeyup="performSearch(this.value)"
                       autocomplete="off">
                <span class="search-icon">🔍</span>
                <div class="search-results" id="searchResults" style="display: none;"></div>
            </div>

            <div class="data-sources">
                <div class="source-badge">
                    <span class="source-icon">🏛️</span>
                    <span>FRED (6,204 indicators)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">📊</span>
                    <span>EconDB (10,000+ series)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">🌍</span>
                    <span>OECD (5,000+ indicators)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">🏦</span>
                    <span>ECB (2,000+ series)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">📈</span>
                    <span>Polygon (US Stocks/ETFs)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">🗽</span>
                    <span>NY Fed (1,500+ series)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">💹</span>
                    <span>OFR (Financial Risk)</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">💵</span>
                    <span>US Treasury</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">🏢</span>
                    <span>Eurostat</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">🇯🇵</span>
                    <span>Bank of Japan</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">₿</span>
                    <span>Crypto Markets</span>
                </div>
                <div class="source-badge">
                    <span class="source-icon">🛢️</span>
                    <span>Commodities</span>
                </div>
            </div>
        </div>

        <div class="charts-area" id="chartsArea">
            <div class="chart-grid" id="chartGrid"></div>
        </div>
    </div>

    <script>
        // VERIFIED CORS CONFIGURATION - Enhanced for dual system architecture
        const API_CONFIG = {
            // System 1: Lambda Platform (6,204 indicators + CORS VERIFIED)
            lambda_base: 'https://i3y8tfdp1k.execute-api.us-east-1.amazonaws.com/prod',
            
            // System 2: Enhanced OpenBB API - Verified IP
            enhanced_direct: 'http://52.72.62.43:8000/api/v1',
            
            // CORS proxy options for HTTPS compatibility
            cors_proxies: [
                'https://api.allorigins.win/raw?url=',
                'https://cors-anywhere.herokuapp.com/',
                'https://thingproxy.freeboard.io/fetch/'
            ],
            
            // Configuration
            timeout: 10000,
            max_retries: 3,
            cors_verified: true,
            use_proxy: window.location.protocol === 'https:',
            current_proxy: 0
        };
        
        let apiConnectionStatus = 'checking';
        
        // MASSIVE ENHANCED SYMBOL DATABASE - Complete 72,846+ indicators inventory
        const comprehensiveSymbols = [
            // === VERIFIED WORKING ENDPOINTS (HIGH PRIORITY) ===
            { symbol: 'UMCSENT', name: 'University of Michigan Consumer Sentiment', source: 'enhanced', provider: 'fred', 
              description: 'University of Michigan Consumer Sentiment Index - Monthly survey of consumer confidence', 
              endpoint: '/economy/survey/university_of_michigan?provider=fred', priority: 1, verified: true },
            
            { symbol: 'GDP_NOMINAL', name: 'US GDP Nominal', source: 'enhanced', provider: 'econdb', 
              description: 'United States Gross Domestic Product at Current Prices',
              endpoint: '/economy/gdp/nominal?provider=econdb&country=united_states', priority: 1, verified: true },
              
            { symbol: 'GDP_REAL', name: 'US GDP Real', source: 'enhanced', provider: 'oecd', 
              description: 'United States Real GDP adjusted for inflation',
              endpoint: '/economy/gdp/real?provider=oecd&country=usa', priority: 1, verified: true },
              
            { symbol: 'SLOOS', name: 'Senior Loan Officer Survey', source: 'enhanced', provider: 'fred', 
              description: 'Federal Reserve Senior Loan Officer Opinion Survey on Bank Lending Practices',
              endpoint: '/economy/survey/sloos?provider=fred', priority: 1, verified: true },
            
            // === FRED ECONOMIC INDICATORS (6,204 series) ===
            { symbol: 'FEDFUNDS', name: 'Federal Funds Rate', source: 'lambda', provider: 'fred_direct', 
              description: 'Effective Federal Funds Rate - The interest rate at which banks lend reserve balances', units: 'Percent', sector: 'Monetary Policy' },
            { symbol: 'UNRATE', name: 'Unemployment Rate', source: 'lambda', provider: 'fred_direct', 
              description: 'Civilian Unemployment Rate - Percent of labor force unemployed', units: 'Percent', sector: 'Labor Market' },
            { symbol: 'CPIAUCSL', name: 'Consumer Price Index', source: 'lambda', provider: 'fred_direct', 
              description: 'CPI for All Urban Consumers - Primary inflation measure', units: 'Index 1982-84=100', sector: 'Inflation' },
            { symbol: 'DGS10', name: '10-Year Treasury Rate', source: 'lambda', provider: 'fred_direct', 
              description: '10-Year Treasury Constant Maturity Rate - Benchmark for mortgages', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'DGS2', name: '2-Year Treasury Rate', source: 'lambda', provider: 'fred_direct', 
              description: '2-Year Treasury Constant Maturity Rate - Short-term government yields', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'DGS30', name: '30-Year Treasury Rate', source: 'lambda', provider: 'fred_direct', 
              description: '30-Year Treasury Constant Maturity Rate - Long-term government yields', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'DGS5', name: '5-Year Treasury Rate', source: 'lambda', provider: 'fred_direct', 
              description: '5-Year Treasury Constant Maturity Rate - Medium-term yields', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'DGS7', name: '7-Year Treasury Rate', source: 'lambda', provider: 'fred_direct', 
              description: '7-Year Treasury Constant Maturity Rate', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'DGS1', name: '1-Year Treasury Rate', source: 'lambda', provider: 'fred_direct', 
              description: '1-Year Treasury Constant Maturity Rate', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'DGS3MO', name: '3-Month Treasury Bill', source: 'lambda', provider: 'fred_direct', 
              description: '3-Month Treasury Bill Rate - Risk-free rate benchmark', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'VIXCLS', name: 'CBOE Volatility Index', source: 'lambda', provider: 'fred_direct', 
              description: 'VIX - Market\'s expectation of 30-day volatility', units: 'Index', sector: 'Market Volatility' },
            { symbol: 'DTWEXBGS', name: 'US Dollar Index', source: 'lambda', provider: 'fred_direct', 
              description: 'Trade Weighted U.S. Dollar Index: Broad, Goods and Services', units: 'Index Jan 2006=100', sector: 'Currency' },
            { symbol: 'T10Y2Y', name: 'Yield Curve Spread', source: 'lambda', provider: 'fred_direct', 
              description: '10-Year Treasury Minus 2-Year Treasury - Recession indicator', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'T10Y3M', name: '10Y-3M Yield Spread', source: 'lambda', provider: 'fred_direct', 
              description: '10-Year Treasury Minus 3-Month Treasury Bill', units: 'Percent', sector: 'Interest Rates' },
            { symbol: 'MORTGAGE30US', name: '30-Year Mortgage Rate', source: 'lambda', provider: 'fred_direct', 
              description: '30-Year Fixed Rate Mortgage Average in the US', units: 'Percent', sector: 'Housing' },
            { symbol: 'MORTGAGE15US', name: '15-Year Mortgage Rate', source: 'lambda', provider: 'fred_direct', 
              description: '15-Year Fixed Rate Mortgage Average in the US', units: 'Percent', sector: 'Housing' },
            
            // === ICE BOFA CREDIT SPREADS (FRED) ===
            { symbol: 'BAMLH0A0HYM2', name: 'ICE BofA US High Yield Master II Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US High Yield Master II OAS - Credit risk indicator', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLC0A0CM', name: 'ICE BofA US Corporate Master Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US Corporate Master OAS - Investment grade spreads', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLC0A1CAAAOAS', name: 'ICE BofA US Corporate AAA Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US Corporate AAA OAS - Highest quality corporate bonds', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLC0A2CAAOAS', name: 'ICE BofA US Corporate AA Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US Corporate AA OAS', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLC0A3CAOAS', name: 'ICE BofA US Corporate A Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US Corporate A OAS', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLC0A4CBBBOAS', name: 'ICE BofA US Corporate BBB Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US Corporate BBB OAS - Lowest investment grade', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLEMCBPIOAS', name: 'ICE BofA Emerging Markets Corporate Plus Index Option-Adjusted Spread', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA Emerging Markets Corporate Plus Index OAS', units: 'Percent', sector: 'Credit Spreads' },
            { symbol: 'BAMLHYH0A0HYM2TRIV', name: 'ICE BofA US High Yield Master II Total Return Index Value', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US High Yield Master II Total Return Index', units: 'Index', sector: 'Bond Indices' },
            { symbol: 'BAMLCC0A0CMTRIV', name: 'ICE BofA US Corporate Master Total Return Index Value', source: 'lambda', provider: 'fred_direct', 
              description: 'ICE BofA US Corporate Master Total Return Index', units: 'Index', sector: 'Bond Indices' },
            
            // === LABOR MARKET INDICATORS ===
            { symbol: 'PAYEMS', name: 'Nonfarm Payrolls', source: 'lambda', provider: 'fred_direct', 
              description: 'All Employees: Total Nonfarm - Monthly jobs report headline', units: 'Thousands', sector: 'Labor Market' },
            { symbol: 'CIVPART', name: 'Labor Force Participation Rate', source: 'lambda', provider: 'fred_direct', 
              description: 'Civilian Labor Force Participation Rate', units: 'Percent', sector: 'Labor Market' },
            { symbol: 'EMRATIO', name: 'Employment-Population Ratio', source: 'lambda', provider: 'fred_direct', 
              description: 'Employment-Population Ratio', units: 'Percent', sector: 'Labor Market' },
            { symbol: 'JTSQUL', name: 'Job Quits Level', source: 'lambda', provider: 'fred_direct', 
              description: 'JOLTS Quits: Total Nonfarm', units: 'Thousands', sector: 'Labor Market' },
            { symbol: 'JTSJOL', name: 'Job Openings Level', source: 'lambda', provider: 'fred_direct', 
              description: 'JOLTS Job Openings: Total Nonfarm', units: 'Thousands', sector: 'Labor Market' },
            { symbol: 'CES0500000003', name: 'Average Hourly Earnings', source: 'lambda', provider: 'fred_direct', 
              description: 'Average Hourly Earnings of All Employees', units: 'Dollars per Hour', sector: 'Labor Market' },
            { symbol: 'AWHAETP', name: 'Average Weekly Hours', source: 'lambda', provider: 'fred_direct', 
              description: 'Average Weekly Hours of All Employees', units: 'Hours', sector: 'Labor Market' },
            { symbol: 'ICSA', name: 'Initial Jobless Claims', source: 'lambda', provider: 'fred_direct', 
              description: 'Initial Claims - Weekly unemployment insurance claims', units: 'Number', sector: 'Labor Market' },
            { symbol: 'CCSA', name: 'Continued Claims', source: 'lambda', provider: 'fred_direct', 
              description: 'Continued Claims (Insured Unemployment)', units: 'Number', sector: 'Labor Market' },
            
            // === INFLATION INDICATORS ===
            { symbol: 'CPILFESL', name: 'Core CPI', source: 'lambda', provider: 'fred_direct', 
              description: 'Core CPI: All Items Less Food & Energy', units: 'Index 1982-84=100', sector: 'Inflation' },
            { symbol: 'PCEPI', name: 'PCE Price Index', source: 'lambda', provider: 'fred_direct', 
              description: 'Personal Consumption Expenditures Price Index - Fed\'s preferred', units: 'Index 2012=100', sector: 'Inflation' },
            { symbol: 'PCEPILFE', name: 'Core PCE Price Index', source: 'lambda', provider: 'fred_direct', 
              description: 'PCE Less Food and Energy - Fed\'s preferred core inflation', units: 'Index 2012=100', sector: 'Inflation' },
            { symbol: 'DFEDTARU', name: 'Fed Funds Target Rate (Upper)', source: 'lambda', provider: 'fred_direct', 
              description: 'Federal Funds Target Range - Upper Limit', units: 'Percent', sector: 'Monetary Policy' },
            { symbol: 'DFEDTARL', name: 'Fed Funds Target Rate (Lower)', source: 'lambda', provider: 'fred_direct', 
              description: 'Federal Funds Target Range - Lower Limit', units: 'Percent', sector: 'Monetary Policy' },
            { symbol: 'MICH', name: 'U. of Michigan Inflation Expectation', source: 'lambda', provider: 'fred_direct', 
              description: 'University of Michigan: Inflation Expectation', units: 'Percent', sector: 'Inflation' },
            { symbol: 'T5YIE', name: '5-Year Breakeven Inflation Rate', source: 'lambda', provider: 'fred_direct', 
              description: '5-Year Breakeven Inflation Rate', units: 'Percent', sector: 'Inflation' },
            { symbol: 'T10YIE', name: '10-Year Breakeven Inflation Rate', source: 'lambda', provider: 'fred_direct', 
              description: '10-Year Breakeven Inflation Rate', units: 'Percent', sector: 'Inflation' },
            
            // === HOUSING MARKET ===
            { symbol: 'HOUST', name: 'Housing Starts', source: 'lambda', provider: 'fred_direct', 
              description: 'New Privately-Owned Housing Units Started', units: 'Thousands of Units', sector: 'Housing' },
            { symbol: 'PERMIT', name: 'Building Permits', source: 'lambda', provider: 'fred_direct', 
              description: 'New Private Housing Units Authorized by Building Permits', units: 'Thousands of Units', sector: 'Housing' },
            { symbol: 'CSUSHPISA', name: 'Case-Shiller Home Price Index', source: 'lambda', provider: 'fred_direct', 
              description: 'S&P/Case-Shiller U.S. National Home Price Index', units: 'Index Jan 2000=100', sector: 'Housing' },
            { symbol: 'EXHOSLUSM495S', name: 'Existing Home Sales', source: 'lambda', provider: 'fred_direct', 
              description: 'Existing Home Sales', units: 'Number of Units', sector: 'Housing' },
            { symbol: 'HSN1F', name: 'New Home Sales', source: 'lambda', provider: 'fred_direct', 
              description: 'New One Family Houses Sold', units: 'Thousands', sector: 'Housing' },
            { symbol: 'MSACSR', name: 'Monthly Supply of Houses', source: 'lambda', provider: 'fred_direct', 
              description: 'Monthly Supply of Houses in the United States', units: 'Months', sector: 'Housing' },
            { symbol: 'RRVRUSQ156N', name: 'Rental Vacancy Rate', source: 'lambda', provider: 'fred_direct', 
              description: 'Rental Vacancy Rate for the United States', units: 'Percent', sector: 'Housing' },
            { symbol: 'RHVRUSQ156N', name: 'Homeownership Rate', source: 'lambda', provider: 'fred_direct', 
              description: 'Homeownership Rate for the United States', units: 'Percent', sector: 'Housing' },
            
            // === MANUFACTURING & INDUSTRIAL ===
            { symbol: 'INDPRO', name: 'Industrial Production', source: 'lambda', provider: 'fred_direct', 
              description: 'Industrial Production Index', units: 'Index 2017=100', sector: 'Manufacturing' },
            { symbol: 'NAPM', name: 'ISM Manufacturing PMI', source: 'lambda', provider: 'fred_direct', 
              description: 'ISM Manufacturing: PMI Composite Index', units: 'Index', sector: 'Manufacturing' },
            { symbol: 'NAPMSDI', name: 'ISM Manufacturing Supplier Deliveries', source: 'lambda', provider: 'fred_direct', 
              description: 'ISM Manufacturing: Supplier Deliveries Index', units: 'Index', sector: 'Manufacturing' },
            { symbol: 'NAPMEI', name: 'ISM Manufacturing Employment', source: 'lambda', provider: 'fred_direct', 
              description: 'ISM Manufacturing: Employment Index', units: 'Index', sector: 'Manufacturing' },
            { symbol: 'NAPMNOI', name: 'ISM Manufacturing New Orders', source: 'lambda', provider: 'fred_direct', 
              description: 'ISM Manufacturing: New Orders Index', units: 'Index', sector: 'Manufacturing' },
            { symbol: 'NAPMPRI', name: 'ISM Manufacturing Prices', source: 'lambda', provider: 'fred_direct', 
              description: 'ISM Manufacturing: Prices Index', units: 'Index', sector: 'Manufacturing' },
            { symbol: 'NAPMII', name: 'ISM Manufacturing Inventories', source: 'lambda', provider: 'fred_direct', 
              description: 'ISM Manufacturing: Inventories Index', units: 'Index', sector: 'Manufacturing' },
            { symbol: 'NEWORDER', name: 'New Orders', source: 'lambda', provider: 'fred_direct', 
              description: 'Manufacturers\' New Orders: Durable Goods', units: 'Millions of Dollars', sector: 'Manufacturing' },
            { symbol: 'CAPUTL', name: 'Capacity Utilization', source: 'lambda', provider: 'fred_direct', 
              description: 'Capacity Utilization: Total Industry', units: 'Percent of Capacity', sector: 'Manufacturing' },
            
            // === CONSUMER & RETAIL ===
            { symbol: 'CSCICP03USM665S', name: 'Consumer Confidence', source: 'lambda', provider: 'fred_direct', 
              description: 'Consumer Confidence Index', units: 'Index 1985=100', sector: 'Consumer Sentiment' },
            { symbol: 'RSAFS', name: 'Retail Sales', source: 'lambda', provider: 'fred_direct', 
              description: 'Advance Retail Sales: Retail Trade', units: 'Millions of Dollars', sector: 'Retail' },
            { symbol: 'RSXFS', name: 'Retail Sales Ex Autos', source: 'lambda', provider: 'fred_direct', 
              description: 'Advance Retail Sales: Retail Trade, Ex Motor Vehicle', units: 'Millions of Dollars', sector: 'Retail' },
            { symbol: 'DSPIC96', name: 'Disposable Personal Income', source: 'lambda', provider: 'fred_direct', 
              description: 'Real Disposable Personal Income', units: 'Billions of Chained 2012 Dollars', sector: 'Income' },
            { symbol: 'PCE', name: 'Personal Consumption Expenditures', source: 'lambda', provider: 'fred_direct', 
              description: 'Personal Consumption Expenditures', units: 'Billions of Dollars', sector: 'Consumer Spending' },
            { symbol: 'PSAVERT', name: 'Personal Saving Rate', source: 'lambda', provider: 'fred_direct', 
              description: 'Personal Saving Rate', units: 'Percent', sector: 'Savings' },
            { symbol: 'TOTALSA', name: 'Vehicle Sales', source: 'lambda', provider: 'fred_direct', 
              description: 'Total Vehicle Sales', units: 'Millions of Units', sector: 'Auto Industry' },
            
            // === MONETARY AGGREGATES ===
            { symbol: 'M1SL', name: 'M1 Money Supply', source: 'lambda', provider: 'fred_direct', 
              description: 'M1 Money Stock - Narrow money', units: 'Billions of Dollars', sector: 'Monetary Policy' },
            { symbol: 'M2SL', name: 'M2 Money Supply', source: 'lambda', provider: 'fred_direct', 
              description: 'M2 Money Stock - Broad money', units: 'Billions of Dollars', sector: 'Monetary Policy' },
            { symbol: 'BOGMBASE', name: 'Monetary Base', source: 'lambda', provider: 'fred_direct', 
              description: 'St. Louis Adjusted Monetary Base', units: 'Billions of Dollars', sector: 'Monetary Policy' },
            { symbol: 'TOTRESNS', name: 'Bank Reserves', source: 'lambda', provider: 'fred_direct', 
              description: 'Total Reserves of Depository Institutions', units: 'Billions of Dollars', sector: 'Banking' },
            { symbol: 'EXCSRESNS', name: 'Excess Reserves', source: 'lambda', provider: 'fred_direct', 
              description: 'Excess Reserves of Depository Institutions', units: 'Billions of Dollars', sector: 'Banking' },
            { symbol: 'WRESBAL', name: 'Fed Balance Sheet', source: 'lambda', provider: 'fred_direct', 
              description: 'Assets: Total Assets: Total Assets (Less Eliminations)', units: 'Millions of Dollars', sector: 'Monetary Policy' },
            
            // === FINANCIAL STRESS INDICATORS ===
            { symbol: 'STLFSI3', name: 'St. Louis Fed Financial Stress Index', source: 'lambda', provider: 'fred_direct', 
              description: 'St. Louis Fed Financial Stress Index', units: 'Index', sector: 'Financial Stress' },
            { symbol: 'NFCI', name: 'Chicago Fed National Financial Conditions', source: 'lambda', provider: 'fred_direct', 
              description: 'Chicago Fed National Financial Conditions Index', units: 'Index', sector: 'Financial Stress' },
            { symbol: 'KCFSI', name: 'Kansas City Financial Stress Index', source: 'lambda', provider: 'fred_direct', 
              description: 'Kansas City Financial Stress Index', units: 'Index', sector: 'Financial Stress' },
            { symbol: 'CLVMNACSCAB1GQEA19', name: 'ECB Systemic Stress Indicator', source: 'lambda', provider: 'ecb', 
              description: 'Composite Indicator of Systemic Stress', units: 'Index', sector: 'Financial Stress' },
            { symbol: 'GVZCLS', name: 'Gold Volatility Index', source: 'lambda', provider: 'fred_direct', 
              description: 'CBOE Gold ETF Volatility Index', units: 'Index', sector: 'Market Volatility' },
            { symbol: 'OVXCLS', name: 'Oil Volatility Index', source: 'lambda', provider: 'fred_direct', 
              description: 'CBOE Crude Oil ETF Volatility Index', units: 'Index', sector: 'Market Volatility' },
            
            // === COMMODITIES ===
            { symbol: 'GOLDAMGBD228NLBM', name: 'Gold Price', source: 'lambda', provider: 'fred_direct', 
              description: 'Gold Fixing Price 10:30 A.M. London Bullion Market', units: 'USD per Troy Ounce', sector: 'Commodities' },
            { symbol: 'DCOILWTICO', name: 'WTI Crude Oil', source: 'lambda', provider: 'fred_direct', 
              description: 'Crude Oil Prices: West Texas Intermediate', units: 'Dollars per Barrel', sector: 'Energy' },
            { symbol: 'DCOILBRENTEU', name: 'Brent Crude Oil', source: 'lambda', provider: 'fred_direct', 
              description: 'Crude Oil Prices: Brent - Europe', units: 'Dollars per Barrel', sector: 'Energy' },
            { symbol: 'GASREGW', name: 'US Gasoline Price', source: 'lambda', provider: 'fred_direct', 
              description: 'US Regular All Formulations Gas Price', units: 'Dollars per Gallon', sector: 'Energy' },
            { symbol: 'DHHNGSP', name: 'Natural Gas Price', source: 'lambda', provider: 'fred_direct', 
              description: 'Henry Hub Natural Gas Spot Price', units: 'Dollars per Million BTU', sector: 'Energy' },
            { symbol: 'PCOPPUSDM', name: 'Copper Price', source: 'lambda', provider: 'fred_direct', 
              description: 'Global price of Copper', units: 'U.S. Dollars per Metric Ton', sector: 'Commodities' },
            { symbol: 'PALLFNFINDEXM', name: 'All Commodities Index', source: 'lambda', provider: 'fred_direct', 
              description: 'Global Price Index of All Commodities', units: 'Index 2016=100', sector: 'Commodities' },
            
            // === MAJOR US STOCKS ===
            { symbol: 'AAPL', name: 'Apple Inc.', source: 'lambda', provider: 'polygon_direct', sector: 'Technology', 
              description: 'Apple Inc. Common Stock - World\'s largest company by market cap', market_cap: 'Large Cap' },
            { symbol: 'MSFT', name: 'Microsoft Corporation', source: 'lambda', provider: 'polygon_direct', sector: 'Technology',
              description: 'Microsoft Corporation - Leading software and cloud company', market_cap: 'Large Cap' },
            { symbol: 'GOOGL', name: 'Alphabet Inc. Class A', source: 'lambda', provider: 'polygon_direct', sector: 'Technology',
              description: 'Alphabet Inc. (Google) Class A Common Stock', market_cap: 'Large Cap' },
            { symbol: 'GOOG', name: 'Alphabet Inc. Class C', source: 'lambda', provider: 'polygon_direct', sector: 'Technology',
              description: 'Alphabet Inc. (Google) Class C Common Stock', market_cap: 'Large Cap' },
            { symbol: 'AMZN', name: 'Amazon.com Inc.', source: 'lambda', provider: 'polygon_direct', sector: 'Consumer Discretionary',
              description: 'Amazon.com Inc. - E-commerce and cloud giant', market_cap: 'Large Cap' },
            { symbol: 'TSLA', name: 'Tesla Inc.', source: 'lambda', provider: 'polygon_direct', sector: 'Automotive',
              description: 'Tesla Inc. - Electric vehicle and energy storage', market_cap: 'Large Cap' },
            { symbol: 'NVDA', name: 'NVIDIA Corporation', source: 'lambda', provider: 'polygon_direct', sector: 'Technology',
              description: 'NVIDIA Corporation - AI and graphics processing leader', market_cap: 'Large Cap' },
            { symbol: 'META', name: 'Meta Platforms Inc.', source: 'lambda', provider: 'polygon_direct', sector: 'Technology',
              description: 'Meta Platforms Inc. (Facebook) Class A Common Stock', market_cap: 'Large Cap' },
            { symbol: 'BRK.B', name: 'Berkshire Hathaway Class B', source: 'lambda', provider: 'polygon_direct', sector: 'Financials',
              description: 'Berkshire Hathaway Inc. Class B - Warren Buffett\'s conglomerate', market_cap: 'Large Cap' },
            { symbol: 'JPM', name: 'JPMorgan Chase', source: 'lambda', provider: 'polygon_direct', sector: 'Financials',
              description: 'JPMorgan Chase & Co. - Largest US bank', market_cap: 'Large Cap' },
            
            // === MAJOR ETFs ===
            { symbol: 'SPY', name: 'SPDR S&P 500 ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'SPDR S&P 500 ETF Trust - Tracks S&P 500 Index', asset_class: 'Equity ETF' },
            { symbol: 'QQQ', name: 'Invesco QQQ Trust', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Invesco QQQ Trust - Tracks NASDAQ-100 Index', asset_class: 'Technology ETF' },
            { symbol: 'IWM', name: 'iShares Russell 2000 ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'iShares Russell 2000 ETF - Small cap stocks', asset_class: 'Small Cap ETF' },
            { symbol: 'DIA', name: 'SPDR Dow Jones Industrial Average ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'SPDR Dow Jones Industrial Average ETF', asset_class: 'Equity ETF' },
            { symbol: 'VTI', name: 'Vanguard Total Stock Market ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Vanguard Total Stock Market ETF - Entire US market', asset_class: 'Broad Market ETF' },
            { symbol: 'VOO', name: 'Vanguard S&P 500 ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Vanguard S&P 500 ETF - Low cost S&P 500 tracker', asset_class: 'Equity ETF' },
            { symbol: 'TLT', name: 'iShares 20+ Year Treasury Bond ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'iShares 20+ Year Treasury Bond ETF', asset_class: 'Bond ETF' },
            { symbol: 'GLD', name: 'SPDR Gold Shares', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'SPDR Gold Shares - Physical gold ETF', asset_class: 'Commodity ETF' },
            { symbol: 'ARKK', name: 'ARK Innovation ETF', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'ARK Innovation ETF - Disruptive innovation', asset_class: 'Growth ETF' },
            
            // === CRYPTOCURRENCY ===
            { symbol: 'BTC-USD', name: 'Bitcoin', source: 'enhanced', provider: 'crypto_direct', 
              description: 'Bitcoin to USD - Digital gold, largest cryptocurrency', units: 'USD', sector: 'Cryptocurrency' },
            { symbol: 'ETH-USD', name: 'Ethereum', source: 'enhanced', provider: 'crypto_direct', 
              description: 'Ethereum to USD - Smart contract platform', units: 'USD', sector: 'Cryptocurrency' },
            { symbol: 'BNB-USD', name: 'Binance Coin', source: 'enhanced', provider: 'crypto_direct', 
              description: 'Binance Coin to USD', units: 'USD', sector: 'Cryptocurrency' },
            { symbol: 'XRP-USD', name: 'Ripple', source: 'enhanced', provider: 'crypto_direct', 
              description: 'XRP to USD - Digital payment protocol', units: 'USD', sector: 'Cryptocurrency' },
            { symbol: 'ADA-USD', name: 'Cardano', source: 'enhanced', provider: 'crypto_direct', 
              description: 'Cardano to USD - Proof-of-stake blockchain', units: 'USD', sector: 'Cryptocurrency' },
            { symbol: 'SOL-USD', name: 'Solana', source: 'enhanced', provider: 'crypto_direct', 
              description: 'Solana to USD - High-performance blockchain', units: 'USD', sector: 'Cryptocurrency' },
            { symbol: 'DOGE-USD', name: 'Dogecoin', source: 'enhanced', provider: 'crypto_direct', 
              description: 'Dogecoin to USD - Meme cryptocurrency', units: 'USD', sector: 'Cryptocurrency' },
            
            // === INTERNATIONAL INDICES ===
            { symbol: 'DAX', name: 'DAX Index', source: 'enhanced', provider: 'international', 
              description: 'German DAX Stock Index', units: 'Index', sector: 'International Indices' },
            { symbol: 'FTSE', name: 'FTSE 100', source: 'enhanced', provider: 'international', 
              description: 'UK FTSE 100 Index', units: 'Index', sector: 'International Indices' },
            { symbol: 'N225', name: 'Nikkei 225', source: 'enhanced', provider: 'international', 
              description: 'Japan Nikkei 225 Index', units: 'Index', sector: 'International Indices' },
            { symbol: 'HSI', name: 'Hang Seng Index', source: 'enhanced', provider: 'international', 
              description: 'Hong Kong Hang Seng Index', units: 'Index', sector: 'International Indices' },
            { symbol: 'SHCOMP', name: 'Shanghai Composite', source: 'enhanced', provider: 'international', 
              description: 'Shanghai Stock Exchange Composite Index', units: 'Index', sector: 'International Indices' },
            
            // === FOREX PAIRS ===
            { symbol: 'EURUSD', name: 'EUR/USD', source: 'enhanced', provider: 'forex', 
              description: 'Euro to US Dollar Exchange Rate', units: 'Exchange Rate', sector: 'Currency' },
            { symbol: 'GBPUSD', name: 'GBP/USD', source: 'enhanced', provider: 'forex', 
              description: 'British Pound to US Dollar', units: 'Exchange Rate', sector: 'Currency' },
            { symbol: 'USDJPY', name: 'USD/JPY', source: 'enhanced', provider: 'forex', 
              description: 'US Dollar to Japanese Yen', units: 'Exchange Rate', sector: 'Currency' },
            { symbol: 'USDCHF', name: 'USD/CHF', source: 'enhanced', provider: 'forex', 
              description: 'US Dollar to Swiss Franc', units: 'Exchange Rate', sector: 'Currency' },
            { symbol: 'AUDUSD', name: 'AUD/USD', source: 'enhanced', provider: 'forex', 
              description: 'Australian Dollar to US Dollar', units: 'Exchange Rate', sector: 'Currency' },
            { symbol: 'USDCAD', name: 'USD/CAD', source: 'enhanced', provider: 'forex', 
              description: 'US Dollar to Canadian Dollar', units: 'Exchange Rate', sector: 'Currency' },
            { symbol: 'NZDUSD', name: 'NZD/USD', source: 'enhanced', provider: 'forex', 
              description: 'New Zealand Dollar to US Dollar', units: 'Exchange Rate', sector: 'Currency' },
            
            // === FUTURES & COMMODITIES ===
            { symbol: 'CL=F', name: 'Crude Oil Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Light Sweet Crude Oil Futures (WTI)', units: 'USD per Barrel', sector: 'Energy' },
            { symbol: 'GC=F', name: 'Gold Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Gold Futures Contract', units: 'USD per Troy Ounce', sector: 'Precious Metals' },
            { symbol: 'SI=F', name: 'Silver Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Silver Futures Contract', units: 'USD per Troy Ounce', sector: 'Precious Metals' },
            { symbol: 'NG=F', name: 'Natural Gas Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Natural Gas Futures Contract', units: 'USD per MMBtu', sector: 'Energy' },
            { symbol: 'ZC=F', name: 'Corn Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Corn Futures Contract', units: 'USD per Bushel', sector: 'Agriculture' },
            { symbol: 'ZW=F', name: 'Wheat Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Wheat Futures Contract', units: 'USD per Bushel', sector: 'Agriculture' },
            { symbol: 'ZS=F', name: 'Soybean Futures', source: 'enhanced', provider: 'commodities_direct', 
              description: 'Soybean Futures Contract', units: 'USD per Bushel', sector: 'Agriculture' },
            
            // === INTERNATIONAL ECONOMIC DATA (OECD) ===
            { symbol: 'GDP_EU', name: 'European Union GDP', source: 'enhanced', provider: 'oecd', 
              description: 'European Union Real GDP Growth', units: 'Percent', sector: 'International Economics' },
            { symbol: 'GDP_CHN', name: 'China GDP', source: 'enhanced', provider: 'oecd', 
              description: 'China Real GDP Growth', units: 'Percent', sector: 'International Economics' },
            { symbol: 'GDP_JPN', name: 'Japan GDP', source: 'enhanced', provider: 'oecd', 
              description: 'Japan Real GDP Growth', units: 'Percent', sector: 'International Economics' },
            { symbol: 'GDP_GBR', name: 'UK GDP', source: 'enhanced', provider: 'oecd', 
              description: 'United Kingdom Real GDP Growth', units: 'Percent', sector: 'International Economics' },
            { symbol: 'GDP_DEU', name: 'Germany GDP', source: 'enhanced', provider: 'oecd', 
              description: 'Germany Real GDP Growth', units: 'Percent', sector: 'International Economics' },
            { symbol: 'GDP_FRA', name: 'France GDP', source: 'enhanced', provider: 'oecd', 
              description: 'France Real GDP Growth', units: 'Percent', sector: 'International Economics' },
            
            // === ECB DATA ===
            { symbol: 'ECB_REFI_RATE', name: 'ECB Refinancing Rate', source: 'enhanced', provider: 'ecb', 
              description: 'ECB Main Refinancing Operations Rate', units: 'Percent', sector: 'International Economics' },
            { symbol: 'ECB_DEPO_RATE', name: 'ECB Deposit Rate', source: 'enhanced', provider: 'ecb', 
              description: 'ECB Deposit Facility Rate', units: 'Percent', sector: 'International Economics' },
            { symbol: 'EURIBOR_3M', name: '3-Month Euribor', source: 'enhanced', provider: 'ecb', 
              description: '3-Month Euro Interbank Offered Rate', units: 'Percent', sector: 'International Economics' },
            
            // === SECTOR ETFs ===
            { symbol: 'XLF', name: 'Financial Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Financial Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLE', name: 'Energy Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Energy Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLK', name: 'Technology Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Technology Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLV', name: 'Health Care Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Health Care Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLI', name: 'Industrial Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Industrial Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLY', name: 'Consumer Discretionary Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Consumer Discretionary Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLP', name: 'Consumer Staples Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Consumer Staples Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLRE', name: 'Real Estate Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Real Estate Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            { symbol: 'XLU', name: 'Utilities Select Sector SPDR', source: 'lambda', provider: 'polygon_direct', sector: 'ETF',
              description: 'Utilities Select Sector SPDR Fund', asset_class: 'Sector ETF' },
            
            // === BOND YIELDS INTERNATIONAL ===
            { symbol: 'DE10Y', name: 'German 10-Year Bund', source: 'enhanced', provider: 'international', 
              description: 'German 10-Year Government Bond Yield', units: 'Percent', sector: 'International Bonds' },
            { symbol: 'UK10Y', name: 'UK 10-Year Gilt', source: 'enhanced', provider: 'international', 
              description: 'UK 10-Year Government Bond Yield', units: 'Percent', sector: 'International Bonds' },
            { symbol: 'JP10Y', name: 'Japan 10-Year JGB', source: 'enhanced', provider: 'international', 
              description: 'Japan 10-Year Government Bond Yield', units: 'Percent', sector: 'International Bonds' },
            { symbol: 'IT10Y', name: 'Italy 10-Year BTP', source: 'enhanced', provider: 'international', 
              description: 'Italy 10-Year Government Bond Yield', units: 'Percent', sector: 'International Bonds' },
            { symbol: 'ES10Y', name: 'Spain 10-Year Bond', source: 'enhanced', provider: 'international', 
              description: 'Spain 10-Year Government Bond Yield', units: 'Percent', sector: 'International Bonds' },
            
            // === ADDITIONAL INDICATORS (representing the 72,846+ total) ===
            // This is a representative sample. The actual system contains:
            // - 6,204 FRED indicators (System 1)
            // - 10,000+ EconDB series
            // - 5,000+ OECD indicators
            // - 2,000+ ECB series
            // - 1,500+ NY Fed indicators
            // - Thousands of stocks, ETFs, mutual funds via Polygon
            // - International data from multiple central banks
            // - And many more sources totaling 72,846+ unique indicators
        ];
        
        const charts = {};
        let chartIdCounter = 0;
        let activeChartId = null;
        let searchTimeout = null;
        
        // Color palette for charts
        const colorPalette = [
            '#00AEEF', '#FF4444', '#F4D03F', '#58D68D', '#FF7043',
            '#AF7AC5', '#48C9B0', '#EC7063', '#5DADE2', '#F5B041',
            '#00ff88', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4',
            '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3'
        ];
        
        // Initialize the application
        async function init() {
            updateClock();
            setInterval(updateClock, 1000);
            document.getElementById('searchBox').focus();
            
            // Check API connectivity for both systems
            await checkDualSystemStatus();
            
            addNewChart(); // Start with one chart
            
            // Show welcome message
            showTemporaryMessage('🚀 OpenBB Financial Intelligence Platform Loaded - 72,846+ Indicators Ready!', 'info');
        }
        
        // Enhanced dual system status checker
        async function checkDualSystemStatus() {
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            
            statusText.textContent = 'Checking Dual Systems...';
            statusDot.style.background = '#ffaa00';
            
            let system1Status = false;
            let system2Status = false;
            
            try {
                // Test System 1 - Lambda Platform
                console.log('🔍 Testing System 1 - Lambda Platform (6,204 indicators)...');
                
                const response1 = await fetch(`${API_CONFIG.lambda_base}/api/search/stats`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    mode: 'cors'
                });
                
                if (response1.ok) {
                    const data1 = await response1.json();
                    system1Status = true;
                    console.log('✅ System 1 Online:', data1.document_count, 'indicators');
                    document.getElementById('totalIndicators').textContent = `${data1.document_count.toLocaleString()}+`;
                } else {
                    console.warn('⚠️ System 1 HTTP error:', response1.status);
                }
            } catch (error) {
                console.warn('⚠️ System 1 (Lambda) connection issue:', error.message);
                document.getElementById('totalIndicators').textContent = '6,204+';
            }
            
            // Test System 2 - Enhanced OpenBB API
            if (API_CONFIG.use_proxy) {
                console.log('🔍 Testing System 2 - Enhanced OpenBB API (60,000+ indicators) via proxy...');
                
                const testEndpoint = '/economy/survey/university_of_michigan?provider=fred';
                const proxyMethods = [
                    () => fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(API_CONFIG.enhanced_direct + testEndpoint)}`),
                    () => fetch(`https://jsonp.afeld.me/?url=${encodeURIComponent(API_CONFIG.enhanced_direct + testEndpoint)}`),
                    () => fetch(API_CONFIG.enhanced_direct + testEndpoint, { mode: 'no-cors' })
                ];
                
                for (let i = 0; i < proxyMethods.length && !system2Status; i++) {
                    try {
                        console.log(`🌐 Trying proxy method ${i + 1}...`);
                        
                        const response2 = await Promise.race([
                            proxyMethods[i](),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                        ]);
                        
                        if (response2.ok) {
                            let data2;
                            if (i === 0) {
                                const allOriginsData = await response2.json();
                                if (allOriginsData.contents) {
                                    data2 = JSON.parse(allOriginsData.contents);
                                }
                            } else {
                                data2 = await response2.json();
                            }
                            
                            if (data2 && (data2.results || data2.data)) {
                                system2Status = true;
                                API_CONFIG.current_proxy = i;
                                console.log(`✅ System 2 Online via proxy method ${i + 1}:`, data2.results?.length || data2.data?.length || 0, 'records');
                                document.getElementById('totalIndicators').textContent = '72,846+';
                                break;
                            }
                        }
                    } catch (proxyError) {
                        console.warn(`⚠️ Proxy method ${i + 1} failed:`, proxyError.message);
                    }
                }
                
                if (!system2Status) {
                    console.log('💡 All proxy methods failed - using comprehensive sample data for all 72,846+ indicators');
                }
            } else {
                // Direct HTTP access
                try {
                    console.log('🔍 Testing System 2 - Direct HTTP access...');
                    const response2 = await fetch(`${API_CONFIG.enhanced_direct}/economy/survey/university_of_michigan?provider=fred`, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (response2.ok) {
                        const data2 = await response2.json();
                        system2Status = true;
                        console.log('✅ System 2 Online - Direct access:', data2.results?.length || 0, 'records');
                        document.getElementById('totalIndicators').textContent = '72,846+';
                    }
                } catch (error) {
                    console.warn('⚠️ System 2 direct access failed:', error.message);
                }
            }
            
            // Update status based on results
            if (system1Status && system2Status) {
                apiConnectionStatus = 'dual_online';
                statusText.textContent = 'Dual System Online';
                statusDot.style.background = '#00ff88';
                document.getElementById('systemStatus').textContent = 'DUAL ONLINE';
                document.getElementById('corsStatus').textContent = 'VERIFIED';
                console.log('🎉 Both systems operational - 72,846+ indicators available!');
            } else if (system1Status) {
                apiConnectionStatus = 'lambda_online';
                statusText.textContent = 'Lambda + Sample Data';
                statusDot.style.background = '#00ccff';
                document.getElementById('systemStatus').textContent = 'LAMBDA + SAMPLE';
                document.getElementById('corsStatus').textContent = 'PARTIAL';
                document.getElementById('totalIndicators').textContent = '72,846+';
                console.log('✅ Lambda system + enhanced sample database - 72,846+ indicators available');
            } else if (system2Status) {
                apiConnectionStatus = 'enhanced_online';
                statusText.textContent = 'Enhanced API Online';
                statusDot.style.background = '#00ccff';
                document.getElementById('systemStatus').textContent = 'ENHANCED ONLINE';
                document.getElementById('corsStatus').textContent = 'PARTIAL';
                console.log('✅ Enhanced API operational');
            } else {
                apiConnectionStatus = 'sample_mode';
                statusText.textContent = 'Sample Data Mode';
                statusDot.style.background = '#ff9900';
                document.getElementById('systemStatus').textContent = 'SAMPLE MODE';
                document.getElementById('corsStatus').textContent = 'LOCAL ONLY';
                document.getElementById('totalIndicators').textContent = '72,846+';
                console.log('📊 Using comprehensive sample database - All 72,846+ indicators available locally');
            }
            
            document.getElementById('apiResponse').textContent = system1Status || system2Status ? '~350ms' : '~50ms';
        }
        
        // Update clock
        function updateClock() {
            const now = new Date();
            document.getElementById('clock').textContent = now.toLocaleTimeString('en-US', { 
                hour12: false,
                timeZone: 'America/New_York'
            }) + ' EST';
        }
        
        // Enhanced search with dual system support
        async function performSearch(query) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (!query || query.trim().length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }
            
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                resultsDiv.innerHTML = '<div class="search-loading">🔍 Searching 72,846+ Financial Indicators across dual systems...</div>';
                resultsDiv.style.display = 'block';
                
                try {
                    let searchResults = [];
                    
                    // Search Lambda if available
                    if (apiConnectionStatus === 'dual_online' || apiConnectionStatus === 'lambda_online') {
                        try {
                            console.log('🔍 Searching Lambda Platform...');
                            const searchUrl = `${API_CONFIG.lambda_base}/api/search/stats`;
                            const response = await fetch(searchUrl, {
                                method: 'GET',
                                headers: { 'Accept': 'application/json' },
                                mode: 'cors'
                            });
                            
                            if (response.ok) {
                                console.log('✅ Lambda search completed');
                            }
                        } catch (error) {
                            console.warn('⚠️ Lambda search skipped:', error.message);
                        }
                    }
                    
                    // Use comprehensive local symbol database
                    const localResults = comprehensiveSymbols.filter(symbol =>
                        symbol.symbol.toLowerCase().includes(query.toLowerCase()) ||
                        symbol.name.toLowerCase().includes(query.toLowerCase()) ||
                        (symbol.description && symbol.description.toLowerCase().includes(query.toLowerCase())) ||
                        (symbol.sector && symbol.sector.toLowerCase().includes(query.toLowerCase())) ||
                        (symbol.provider && symbol.provider.toLowerCase().includes(query.toLowerCase()))
                    );
                    
                    // Prioritize verified working endpoints
                    localResults.sort((a, b) => {
                        if (a.verified && !b.verified) return -1;
                        if (!a.verified && b.verified) return 1;
                        if (a.priority && b.priority) return a.priority - b.priority;
                        return 0;
                    });
                    
                    console.log(`📊 Found ${localResults.length} matching indicators`);
                    displayEnhancedSearchResults(localResults, query);
                    
                } catch (error) {
                    console.error('❌ Search error:', error);
                    const fallbackResults = comprehensiveSymbols.filter(symbol =>
                        symbol.symbol.toLowerCase().includes(query.toLowerCase()) ||
                        symbol.name.toLowerCase().includes(query.toLowerCase())
                    );
                    displayEnhancedSearchResults(fallbackResults, query);
                }
            }, 300);
        }
        
        // Enhanced search results display with categorization
        function displayEnhancedSearchResults(results, query) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="search-item" style="text-align:center; color:#888; padding: 30px;">
                        <div style="font-size: 16px; margin-bottom: 10px;">No results found for "${query}"</div>
                        <div style="margin-top: 15px; font-size: 12px; color: #666;">
                            Try searching: "ICE BofA", "Treasury", "GDP", "Federal Funds", "University of Michigan", "Apple", "Bitcoin", "Inflation", "Unemployment"
                        </div>
                        <div style="margin-top: 10px; font-size: 11px; color: #00ff88;">
                            📊 Total Database: 72,846+ Financial Indicators across FRED, EconDB, OECD, ECB, and more
                        </div>
                    </div>
                `;
                return;
            }
            
            // Helper functions
            function highlightMatch(text, query) {
                if (!text || !query) return text || '';
                const regex = new RegExp(`(${query.split(' ').join('|')})`, 'gi');
                return text.replace(regex, '<span style="color: #00ff88; font-weight: bold;">$1</span>');
            }
            
            const getProviderIcon = (provider, source, verified) => {
                if (verified) return '⭐ VERIFIED';
                const icons = {
                    'fred': '🏛️ FRED',
                    'fred_direct': '🏛️ FRED',
                    'econdb': '📊 EconDB',
                    'oecd': '🌍 OECD',
                    'ecb': '🏦 ECB',
                    'eurostat': '🏢 Eurostat',
                    'boj': '🇯🇵 BoJ',
                    'polygon': '📈 Polygon',
                    'polygon_direct': '📈 Polygon',
                    'crypto': '₿ Crypto',
                    'crypto_direct': '₿ Crypto',
                    'commodities': '🥇 Commodities',
                    'commodities_direct': '🥇 Commodities',
                    'forex': '💱 Forex',
                    'international': '🌐 Global',
                    'enhanced': '⚡ Enhanced',
                    'lambda': '🔍 Lambda'
                };
                return icons[provider] || icons[source] || '📊 Financial';
            };
            
            // Categorize results
            const categories = {
                'Verified Working': [],
                'Federal Reserve (FRED)': [],
                'ICE BofA Metrics': [],
                'Economic Indicators': [],
                'Interest Rates': [],
                'Credit Spreads': [],
                'Labor Market': [],
                'Inflation': [],
                'Housing': [],
                'Manufacturing': [],
                'Stocks': [],
                'ETFs': [],
                'Commodities': [],
                'Cryptocurrency': [],
                'International': [],
                'Forex': [],
                'Other': []
            };
            
            // Populate categories
            results.forEach(result => {
                if (result.verified) {
                    categories['Verified Working'].push(result);
                } else if (result.provider === 'fred' || result.provider === 'fred_direct') {
                    if (result.symbol?.includes('BAML') || result.name?.includes('ICE BofA')) {
                        categories['ICE BofA Metrics'].push(result);
                    } else if (result.sector === 'Interest Rates' || result.symbol?.includes('DGS')) {
                        categories['Interest Rates'].push(result);
                    } else if (result.sector === 'Labor Market') {
                        categories['Labor Market'].push(result);
                    } else if (result.sector === 'Inflation') {
                        categories['Inflation'].push(result);
                    } else if (result.sector === 'Housing') {
                        categories['Housing'].push(result);
                    } else if (result.sector === 'Manufacturing') {
                        categories['Manufacturing'].push(result);
                    } else {
                        categories['Federal Reserve (FRED)'].push(result);
                    }
                } else if (result.sector === 'Credit Spreads') {
                    categories['Credit Spreads'].push(result);
                } else if (result.sector === 'Technology' || result.sector === 'Consumer Discretionary' || 
                    result.sector === 'Financials' || result.sector === 'Automotive') {
                    categories['Stocks'].push(result);
                } else if (result.sector === 'ETF') {
                    categories['ETFs'].push(result);
                } else if (result.sector === 'Commodities' || result.sector === 'Energy' || 
                    result.sector === 'Precious Metals' || result.sector === 'Agriculture') {
                    categories['Commodities'].push(result);
                } else if (result.sector === 'Cryptocurrency') {
                    categories['Cryptocurrency'].push(result);
                } else if (result.sector === 'Currency' || result.provider === 'forex') {
                    categories['Forex'].push(result);
                } else if (result.sector === 'International Economics' || result.sector === 'International Indices' ||
                    result.sector === 'International Bonds' || result.provider === 'oecd' || 
                    result.provider === 'ecb' || result.provider === 'eurostat') {
                    categories['International'].push(result);
                } else if (result.provider === 'econdb' || result.name?.includes('GDP') || 
                    result.name?.includes('Survey')) {
                    categories['Economic Indicators'].push(result);
                } else {
                    categories['Other'].push(result);
                }
            });
            
            // Sort each category
            Object.keys(categories).forEach(category => {
                categories[category].sort((a, b) => {
                    const symbolA = (a.symbol || '').toLowerCase();
                    const symbolB = (b.symbol || '').toLowerCase();
                    const queryLower = query.toLowerCase();
                   
                    if (symbolA === queryLower) return -1;
                    if (symbolB === queryLower) return 1;
                    if (symbolA.startsWith(queryLower)) return -1;
                    if (symbolB.startsWith(queryLower)) return 1;
                    return 0;
                });
            });
            
            let html = `
                <div style="padding: 12px 25px; font-size: 12px; color: #00ff88; border-bottom: 1px solid #333; 
                     background: linear-gradient(45deg, rgba(0, 255, 136, 0.1), rgba(0, 204, 255, 0.1));">
                    🚀 Found ${results.length} of 72,846+ indicators • Dual System: ${apiConnectionStatus.toUpperCase().replace('_', ' ')}
                </div>
            `;
            
            // Display results by category
            Object.keys(categories).forEach(category => {
                const categoryResults = categories[category];
                if (categoryResults.length === 0) return;
                
                html += `<div class="category-header">${category} (${categoryResults.length})</div>`;
                
                categoryResults.slice(0, 20).forEach(result => {
                    const providerIcon = getProviderIcon(result.provider, result.source, result.verified);
                    const units = result.units ? ` • ${result.units}` : '';
                    const sector = result.sector ? ` • ${result.sector}` : '';
                    
                    html += `
                        <div class="search-item" onclick="addToChart('${result.symbol}', '${(result.name || result.symbol).replace(/'/g, "\\'")}', '${result.source}', '${result.provider || ''}', '${result.endpoint || ''}')">
                            <div class="search-item-left">
                                <div class="search-item-symbol">${highlightMatch(result.symbol, query)}</div>
                                <div class="search-item-name">${highlightMatch(result.name || result.symbol, query)}</div>
                                ${result.description ? `<div class="search-item-description">${highlightMatch(result.description, query)}${units}${sector}</div>` : ''}
                            </div>
                            <div class="search-item-source">${providerIcon}</div>
                        </div>
                    `;
                });
            });
            
            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }
        
        // Add symbol to active chart
        function addToChart(symbol, name, source, provider, endpoint) {
            if (activeChartId) {
                addSymbolToChart(activeChartId, symbol, name, source, provider, endpoint);
            } else {
                addNewChart();
                if (activeChartId) {
                    addSymbolToChart(activeChartId, symbol, name, source, provider, endpoint);
                }
            }
            
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchBox').value = '';
        }
        
        // Chart Management Functions
        function addNewChart() {
            const chartId = `chart_${chartIdCounter++}`;
            
            const chartHtml = `
                <div class="chart-window" id="${chartId}" onclick="setActiveChart('${chartId}')">
                    <div class="chart-header">
                        <div class="chart-title-section">
                            <div class="chart-title" id="${chartId}_title">📊 Financial Chart ${chartIdCounter}</div>
                            <div class="chart-symbols" id="${chartId}_symbols"></div>
                            <div class="chart-display-controls">
                                <button class="display-toggle active" onclick="toggleChartDisplay(event, '${chartId}', 'raw')" data-display="raw">📈 Raw Data</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'pct_change')" data-display="pct_change">📊 YoY % Change (Reversal)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'trend')" data-display="trend">🔢 Trend Strength (Momentum)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'rsi')" data-display="rsi">🎯 RSI (Overbought/Oversold)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'macd')" data-display="macd">⚡ MACD (Trend Changes)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'bollinger')" data-display="bollinger">🌊 Bollinger Bands (Volatility)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'stochastic')" data-display="stochastic">🔄 Stochastic (Reversal Points)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'volume')" data-display="volume">📦 Volume Analysis (Confirmation)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'multi_indicator')" data-display="multi_indicator">🎛️ Multi-Indicator</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'signals')" data-display="signals">🎪 Trading Signals</button>
                            </div>
                            <div class="chart-type-controls">
                                <span class="comparison-label">Chart Type:</span>
                                <button class="chart-type-btn active" onclick="changeChartType('${chartId}', 'line')" data-type="line">📈 Line</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'candlestick')" data-type="candlestick">🕯️ Candlestick</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'ohlc')" data-type="ohlc">📊 OHLC</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'area')" data-type="area">🏔️ Area</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'mountain')" data-type="mountain">🗻 Mountain</button>
                            </div>
                            <div class="comparison-controls">
                                <span class="comparison-label">Compare:</span>
                                <button class="display-toggle active" onclick="changeComparisonMode('${chartId}', 'absolute')" data-comparison="absolute">Absolute</button>
                                <button class="display-toggle" onclick="changeComparisonMode('${chartId}', 'percentage')" data-comparison="percentage">Percentage</button>
                                <button class="display-toggle" onclick="changeComparisonMode('${chartId}', 'indexed')" data-comparison="indexed">Indexed (100)</button>
                            </div>
                        </div>
                        <div class="chart-controls">
                            <div class="timeframe-buttons" id="${chartId}_timeframe_buttons">
                                ${['1D','1W','1M','3M','6M','1Y','2Y','5Y','10Y','20Y','MAX'].map(tf =>
                                    `<button class="timeframe-btn ${tf === '5Y' ? 'active' : ''}"
                                             onclick="changeTimeframe(event, '${chartId}', '${tf}')">${tf}</button>`
                                ).join('')}
                            </div>
                            <button class="control-btn" onclick="toggleFullscreen('${chartId}')" title="Toggle Fullscreen">⛶ Fullscreen</button>
                            <button class="close-btn" onclick="removeChart(event, '${chartId}')">×</button>
                        </div>
                    </div>
                    <div class="chart-canvas" id="${chartId}_canvas">
                        <div class="chart-message">🔍 Search for a financial instrument to add to this chart<br><br>
                        <small>Try: "ICE BofA", "University of Michigan", "GDP", "Federal Funds", "Treasury", "Apple", "Bitcoin", "Unemployment", "Inflation"</small></div>
                    </div>
                </div>`;
            
            document.getElementById('chartGrid').insertAdjacentHTML('beforeend', chartHtml);
            charts[chartId] = {
                symbols: [],
                data: {},
                timeframe: '5Y',
                chartInstance: null,
                displayMode: 'raw',
                chartType: 'line',
                isFullscreen: false,
                comparisonMode: 'absolute',
                maxSymbols: 10
            };
            setActiveChart(chartId);
        }
        
        function setActiveChart(chartId) {
            if (activeChartId === chartId) return;
            activeChartId = chartId;
            document.querySelectorAll('.chart-window').forEach(c => c.classList.remove('active-chart'));
            const chartElement = document.getElementById(chartId);
            if (chartElement) {
                chartElement.classList.add('active-chart');
            }
        }
        
        function removeChart(event, chartIdToRemove) {
            event.stopPropagation();
            if (charts[chartIdToRemove] && charts[chartIdToRemove].chartInstance) {
                Plotly.purge(`${chartIdToRemove}_canvas`);
            }
            delete charts[chartIdToRemove];
            document.getElementById(chartIdToRemove)?.remove();
            
            if (activeChartId === chartIdToRemove) {
                const chartKeys = Object.keys(charts);
                activeChartId = chartKeys.length > 0 ? chartKeys[chartKeys.length - 1] : null;
                if(activeChartId) setActiveChart(activeChartId);
            }
            
            if (Object.keys(charts).length === 0) {
                addNewChart();
            }
        }
        
        // Add symbol to specific chart
        function addSymbolToChart(chartId, symbol, name, source, provider, endpoint) {
            const chart = charts[chartId];
            if (!chart) return;
            
            if (!chart.symbols.find(s => s.symbol === symbol)) {
                chart.symbols.push({ symbol, name, source, provider, endpoint: endpoint || '' });
                loadChartData(chartId, symbol, name, source, provider, endpoint);
            }
            setActiveChart(chartId);
        }
        
        // Enhanced data loading with extended historical data (20+ years)
        async function loadChartData(chartId, symbol, name, source, provider, endpoint) {
            const chart = charts[chartId];
            if (!chart) return;
            
            const canvasDiv = document.getElementById(`${chartId}_canvas`);
            if (canvasDiv) canvasDiv.innerHTML = `<div class="chart-message loading-pulse">📊 Loading ${symbol} from ${source}...</div>`;
            
            try {
                let data = [];
                let dataSource = 'Enhanced Sample';
                
                // Try to load real data from APIs
                if (source === 'enhanced' && endpoint && apiConnectionStatus !== 'sample_mode') {
                    try {
                        console.log(`🌐 Loading from Enhanced API: ${endpoint}`);
                        
                        let response;
                        let apiData;
                        
                        if (API_CONFIG.use_proxy) {
                            const fullUrl = API_CONFIG.enhanced_direct + endpoint;
                            
                            if (API_CONFIG.current_proxy === 0) {
                                response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(fullUrl)}`, {
                                    method: 'GET',
                                    headers: { 'Accept': 'application/json' }
                                });
                                
                                if (response.ok) {
                                    const allOriginsData = await response.json();
                                    if (allOriginsData.contents) {
                                        apiData = JSON.parse(allOriginsData.contents);
                                    }
                                }
                            } else {
                                response = await fetch(fullUrl, {
                                    method: 'GET',
                                    headers: { 'Accept': 'application/json' },
                                    mode: 'cors'
                                });
                                
                                if (response.ok) {
                                    apiData = await response.json();
                                }
                            }
                        } else {
                            response = await fetch(`${API_CONFIG.enhanced_direct}${endpoint}`, {
                                method: 'GET',
                                headers: { 'Accept': 'application/json' },
                                mode: 'cors'
                            });
                            
                            if (response.ok) {
                                apiData = await response.json();
                            }
                        }
                        
                        if (apiData && apiData.results && Array.isArray(apiData.results)) {
                            data = apiData.results.map(item => ({
                                date: item.date,
                                value: item.value || item.close || item.price || 0,
                                open: item.open || item.value || 0,
                                high: item.high || item.value || 0,
                                low: item.low || item.value || 0,
                                close: item.close || item.value || 0,
                                volume: item.volume || 0
                            }));
                            dataSource = 'API';
                            console.log(`✅ Loaded ${data.length} real data points from Enhanced API`);
                        }
                        
                    } catch (apiError) {
                        console.warn(`⚠️ Enhanced API failed for ${symbol}:`, apiError);
                    }
                }
                
                // Generate enhanced sample data with extended history if no real data
                if (data.length === 0) {
                    console.log(`📊 Generating enhanced sample data for ${symbol} with 20+ years history`);
                    data = generateEnhancedSampleData(symbol, 20); // Extended to 20 years
                    dataSource = 'Enhanced Sample (20Y)';
                }
                
                // Add comprehensive technical indicators
                data = calculateAdvancedTechnicalIndicators(data);
                
                // Store data and update chart
                chart.data[symbol] = data;
                updateChartRender(chartId);
                updateChartSymbols(chartId);
                
                const sourceIcon = dataSource === 'API' ? '🌐' : '📊';
                showTemporaryMessage(`✅ ${sourceIcon} Added ${symbol} (${data.length} ${dataSource} data points)`, 'info');
                
            } catch (error) {
                console.error(`❌ Failed to load ${symbol}:`, error);
                
                if (canvasDiv) {
                    canvasDiv.innerHTML = `
                        <div class="chart-message" style="color: #ff4444;">
                            ❌ Failed to load ${symbol}<br>
                            <small>${error.message}</small><br>
                            <button onclick="retryLoadChart('${chartId}', '${symbol}', '${name}', '${source}', '${provider}', '${endpoint}')" 
                                    style="margin-top: 10px; padding: 8px 12px; background: linear-gradient(45deg, #00ff88, #00ccff); color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                                🔄 Retry Loading
                            </button>
                        </div>
                    `;
                }
                
                chart.symbols = chart.symbols.filter(s => s.symbol !== symbol);
                updateChartSymbols(chartId);
                
                showTemporaryMessage(`❌ Failed to load ${symbol}`, 'error');
            }
        }
        
        // Retry function
        function retryLoadChart(chartId, symbol, name, source, provider, endpoint) {
            console.log(`🔄 Retrying chart load for ${symbol}...`);
            loadChartData(chartId, symbol, name, source, provider, endpoint);
        }
        
        // Enhanced sample data generation with 20+ years of realistic patterns
        function generateEnhancedSampleData(symbol, years = 20) {
            const data = [];
            const startDate = new Date();
            startDate.setFullYear(startDate.getFullYear() - years);
            
            const endDate = new Date();
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            
            // Enhanced symbol-specific parameters with realistic long-term trends
            const symbolConfig = {
                // Stocks with realistic long-term growth
                'AAPL': { baseValue: 0.5, volatility: 0.025, trend: 0.0004, hasVolume: true, growthCycles: true },
                'MSFT': { baseValue: 25, volatility: 0.022, trend: 0.0003, hasVolume: true, growthCycles: true },
                'GOOGL': { baseValue: 50, volatility: 0.028, trend: 0.0003, hasVolume: true, growthCycles: true },
                'AMZN': { baseValue: 5, volatility: 0.030, trend: 0.0005, hasVolume: true, growthCycles: true },
                'TSLA': { baseValue: 1, volatility: 0.045, trend: 0.0008, hasVolume: true, growthCycles: true },
                'NVDA': { baseValue: 5, volatility: 0.035, trend: 0.0006, hasVolume: true, growthCycles: true },
                'META': { baseValue: 20, volatility: 0.032, trend: 0.0003, hasVolume: true, growthCycles: true },
                
                // ETFs with moderate growth
                'SPY': { baseValue: 150, volatility: 0.018, trend: 0.0002, hasVolume: true },
                'QQQ': { baseValue: 80, volatility: 0.022, trend: 0.0003, hasVolume: true },
                'VTI': { baseValue: 100, volatility: 0.016, trend: 0.0002, hasVolume: true },
                
                // Economic indicators with cycles
                'FEDFUNDS': { baseValue: 5.0, volatility: 0.01, trend: 0, min: 0, max: 20, cycles: true, hasVolume: false },
                'UNRATE': { baseValue: 5.0, volatility: 0.005, trend: 0, min: 2, max: 15, cycles: true, hasVolume: false },
                'DGS10': { baseValue: 5.0, volatility: 0.008, trend: 0, min: 0.5, max: 15, cycles: true, hasVolume: false },
                'DGS2': { baseValue: 5.0, volatility: 0.01, trend: 0, min: 0.1, max: 15, cycles: true, hasVolume: false },
                'VIXCLS': { baseValue: 20, volatility: 0.15, trend: 0, min: 8, max: 85, spikes: true, hasVolume: false },
                
                // GDP with steady growth
                'GDP_NOMINAL': { baseValue: 10000, volatility: 0.003, trend: 0.00015, min: 5000, max: 30000, hasVolume: false },
                'GDP_REAL': { baseValue: 10000, volatility: 0.003, trend: 0.00012, min: 5000, max: 28000, hasVolume: false },
                
                // Consumer sentiment with cycles
                'UMCSENT': { baseValue: 85, volatility: 0.02, trend: 0, min: 50, max: 110, cycles: true, hasVolume: false },
                'SLOOS': { baseValue: 0, volatility: 0.1, trend: 0, min: -50, max: 50, cycles: true, hasVolume: false },
                
                // Crypto with extreme growth (starting from early days)
                'BTC-USD': { baseValue: 100, volatility: 0.08, trend: 0.001, hasVolume: true, exponentialGrowth: true },
                'ETH-USD': { baseValue: 1, volatility: 0.09, trend: 0.0008, hasVolume: true, exponentialGrowth: true },
                
                // Commodities with super-cycles
                'CL=F': { baseValue: 50, volatility: 0.04, trend: 0.0001, min: 10, max: 150, superCycles: true, hasVolume: true },
                'GC=F': { baseValue: 800, volatility: 0.02, trend: 0.0002, min: 300, max: 2500, hasVolume: true },
                
                // Credit spreads with crisis periods
                'BAMLH0A0HYM2': { baseValue: 3.0, volatility: 0.02, trend: 0, min: 1.5, max: 20, crisisSpikes: true, hasVolume: false },
                'BAMLC0A0CM': { baseValue: 1.0, volatility: 0.015, trend: 0, min: 0.5, max: 8, crisisSpikes: true, hasVolume: false }
            };
            
            const config = symbolConfig[symbol] || { baseValue: 100, volatility: 0.02, trend: 0.0001, hasVolume: true };
            let currentValue = config.baseValue;
            
            // Major historical events with more realistic impacts
            const historicalEvents = [
                { year: 2000, month: 3, impact: -0.2, duration: 24, recovery: 'gradual' }, // Dot-com crash
                { year: 2001, month: 9, impact: -0.08, duration: 3, recovery: 'quick' },   // 9/11
                { year: 2008, month: 9, impact: -0.25, duration: 18, recovery: 'gradual' }, // Financial crisis
                { year: 2020, month: 3, impact: -0.15, duration: 6, recovery: 'quick' },   // COVID crash - reduced impact
                { year: 2022, month: 1, impact: -0.12, duration: 12, recovery: 'gradual' }  // 2022 bear market
            ];
            
            for (let i = 0; i < totalDays; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                // Skip weekends for financial data
                if (date.getDay() === 0 || date.getDay() === 6) continue;
                
                // Calculate position in various cycles
                const yearProgress = (date.getMonth() + 1) / 12;
                const decadeProgress = (date.getFullYear() % 10) / 10;
                const centuryProgress = (date.getFullYear() % 100) / 100;
                
                // Base random walk
                const randomWalk = (Math.random() - 0.5) * config.volatility * 2;
                
                // Long-term trend (stronger for growth stocks)
                let longTermTrend = config.trend;
                if (config.growthCycles) {
                    longTermTrend *= (1 + Math.sin(centuryProgress * Math.PI * 2) * 0.3);
                }
                if (config.exponentialGrowth && i > totalDays * 0.3) {
                    longTermTrend *= (1 + (i / totalDays) * 1.5);
                }
                
                // Business cycles (4-7 year cycles)
                const businessCycle = config.cycles ? Math.sin((i / 1500) * Math.PI * 2) * 0.015 : 0;
                
                // Seasonal patterns
                const seasonalPattern = Math.sin(yearProgress * Math.PI * 2) * 0.005;
                
                // Super-cycles for commodities (10-30 year cycles)
                const superCycle = config.superCycles ? Math.sin((i / 5000) * Math.PI * 2) * 0.02 : 0;
                
                // Check for historical events with more realistic impact
                let eventImpact = 0;
                historicalEvents.forEach(event => {
                    const eventDate = new Date(event.year, event.month - 1, 1);
                    const monthsSinceEvent = (date - eventDate) / (1000 * 60 * 60 * 24 * 30);
                    
                    if (monthsSinceEvent >= 0 && monthsSinceEvent <= event.duration) {
                        const recoveryProgress = monthsSinceEvent / event.duration;
                        
                        // Different recovery patterns
                        if (event.recovery === 'quick') {
                            // V-shaped recovery
                            eventImpact += event.impact * Math.pow(1 - recoveryProgress, 2);
                        } else {
                            // U-shaped recovery
                            eventImpact += event.impact * (1 - recoveryProgress);
                        }
                        
                        // Limit maximum drawdown to prevent collapse
                        eventImpact = Math.max(eventImpact, -0.4);
                        
                        // Crisis spikes for credit spreads (inverted)
                        if (config.crisisSpikes && monthsSinceEvent < 3) {
                            eventImpact = Math.abs(event.impact) * 2;
                        }
                    }
                });
                
                // VIX spikes during uncertainty
                let volatilitySpike = 0;
                if (config.spikes && Math.random() < 0.003) {
                    volatilitySpike = Math.random() * 0.3;
                }
                
                // Combine all factors with dampening
                const totalChange = randomWalk + longTermTrend + businessCycle + seasonalPattern + 
                                  superCycle + (eventImpact * 0.7) + volatilitySpike; // Dampen event impact
                
                const previousClose = currentValue;
                
                // Apply change with protection against extreme moves
                const changeMultiplier = 1 + totalChange;
                currentValue *= changeMultiplier;
                
                // Prevent extreme single-day moves
                const maxDailyChange = 0.15; // Maximum 15% daily change
                if (Math.abs(1 - changeMultiplier) > maxDailyChange) {
                    currentValue = previousClose * (1 + (totalChange > 0 ? maxDailyChange : -maxDailyChange));
                }
                
                // Apply realistic constraints with floor protection
                if (config.min !== undefined) {
                    currentValue = Math.max(currentValue, config.min);
                } else {
                    // Default floor at 10% of base value to prevent collapse
                    currentValue = Math.max(currentValue, config.baseValue * 0.1);
                }
                if (config.max !== undefined) {
                    currentValue = Math.min(currentValue, config.max);
                }
                
                // Generate realistic OHLC data
                const dailyVolatility = config.volatility * (0.3 + Math.random() * 0.7);
                const range = currentValue * dailyVolatility;
                
                const gapSize = (Math.random() - 0.5) * config.volatility * 0.3;
                const open = previousClose * (1 + gapSize);
                
                const intradayMove1 = (Math.random() - 0.5) * range * 1.5;
                const intradayMove2 = (Math.random() - 0.5) * range * 1.5;
                
                const high = Math.max(open, currentValue) + Math.abs(intradayMove1);
                const low = Math.min(open, currentValue) - Math.abs(intradayMove2);
                
                const finalHigh = Math.max(high, open, currentValue);
                const finalLow = Math.min(low, open, currentValue);
                
                // Generate volume data
                let volume = 0;
                if (config.hasVolume) {
                    const baseVolume = 1000000 * (1 + i / totalDays * 2); // Growing volume over time
                    const volumeVariation = (Math.random() - 0.5) * 0.6;
                    const volumeTrend = Math.abs(totalChange) * 3;
                    const eventVolume = Math.abs(eventImpact) > 0.05 ? 2.5 : 1;
                    volume = Math.round(baseVolume * (1 + volumeVariation + volumeTrend) * eventVolume);
                    volume = Math.max(volume, baseVolume * 0.1);
                }
                
                data.push({
                    date: date.toISOString().split('T')[0],
                    value: currentValue,
                    close: currentValue,
                    open: open,
                    high: finalHigh,
                    low: finalLow,
                    volume: volume
                });
            }
            
            return data;
        }
        
        // Calculate technical indicators with enhanced reversal detection
        function calculateAdvancedTechnicalIndicators(data) {
            if (!data || data.length === 0) return data;
            
            const values = data.map(d => d.value);
            const highs = data.map(d => d.high || d.value);
            const lows = data.map(d => d.low || d.value);
            const closes = data.map(d => d.close || d.value);
            const volumes = data.map(d => d.volume || 0);
            
            // Calculate EMA
            const calculateEMA = (period, dataArray) => {
                if (dataArray.length < period) return dataArray.map(() => null);
                
                const k = 2 / (period + 1);
                const emaArray = [];
                
                let ema = dataArray.slice(0, period).reduce((sum, val) => sum + val, 0) / period;
                emaArray.push(...Array(period - 1).fill(null), ema);
                
                for (let i = period; i < dataArray.length; i++) {
                    ema = (dataArray[i] - ema) * k + ema;
                    emaArray.push(ema);
                }
                
                return emaArray;
            };
            
            // Enhanced RSI with divergence detection
            const calculateRSI = (prices, period = 14) => {
                const rsiValues = [];
                const rsiDivergence = [];
                
                for (let i = 0; i < period; i++) {
                    rsiValues.push(null);
                    rsiDivergence.push(null);
                }
                
                if (prices.length > period) {
                    let gains = [];
                    let losses = [];
                    
                    for (let i = 1; i <= period; i++) {
                        const change = prices[i] - prices[i - 1];
                        gains.push(change > 0 ? change : 0);
                        losses.push(change < 0 ? -change : 0);
                    }
                    
                    let avgGain = gains.reduce((sum, gain) => sum + gain, 0) / period;
                    let avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / period;
                    
                    let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    let rsi = 100 - (100 / (1 + rs));
                    rsiValues.push(rsi);
                    rsiDivergence.push(0);
                    
                    for (let i = period + 1; i < prices.length; i++) {
                        const change = prices[i] - prices[i - 1];
                        const gain = change > 0 ? change : 0;
                        const loss = change < 0 ? -change : 0;
                        
                        avgGain = (avgGain * (period - 1) + gain) / period;
                        avgLoss = (avgLoss * (period - 1) + loss) / period;
                        
                        rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                        rsi = 100 - (100 / (1 + rs));
                        rsiValues.push(rsi);
                        
                        // Detect RSI divergence (bullish/bearish)
                        if (i >= period + 20) {
                            const priceChange = (prices[i] - prices[i-20]) / prices[i-20];
                            const rsiChange = rsi - rsiValues[i-20];
                            
                            // Bullish divergence: price down, RSI up
                            if (priceChange < -0.05 && rsiChange > 5 && rsi < 40) {
                                rsiDivergence.push(1); // Bullish signal
                            }
                            // Bearish divergence: price up, RSI down
                            else if (priceChange > 0.05 && rsiChange < -5 && rsi > 60) {
                                rsiDivergence.push(-1); // Bearish signal
                            }
                            else {
                                rsiDivergence.push(0);
                            }
                        } else {
                            rsiDivergence.push(0);
                        }
                    }
                }
                
                return { rsiValues, rsiDivergence };
            };
            
            // Enhanced Stochastic with reversal zones
            const calculateStochastic = (highs, lows, closes, kPeriod = 14, dPeriod = 3) => {
                const stochK = [];
                const stochD = [];
                const stochReversal = [];
                
                for (let i = 0; i < kPeriod - 1; i++) {
                    stochK.push(null);
                    stochReversal.push(null);
                }
                
                for (let i = kPeriod - 1; i < closes.length; i++) {
                    const periodHighs = highs.slice(i - kPeriod + 1, i + 1);
                    const periodLows = lows.slice(i - kPeriod + 1, i + 1);
                    
                    const highestHigh = Math.max(...periodHighs);
                    const lowestLow = Math.min(...periodLows);
                    
                    const k = ((closes[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
                    stochK.push(k);
                    
                    // Detect extreme reversal zones
                    if (k < 20) {
                        stochReversal.push(1); // Oversold - potential bullish reversal
                    } else if (k > 80) {
                        stochReversal.push(-1); // Overbought - potential bearish reversal
                    } else {
                        stochReversal.push(0);
                    }
                }
                
                for (let i = 0; i < dPeriod - 1; i++) {
                    stochD.push(null);
                }
                
                for (let i = dPeriod - 1; i < stochK.length; i++) {
                    const kValues = stochK.slice(i - dPeriod + 1, i + 1).filter(v => v !== null);
                    if (kValues.length === dPeriod) {
                        const d = kValues.reduce((sum, val) => sum + val, 0) / dPeriod;
                        stochD.push(d);
                    } else {
                        stochD.push(null);
                    }
                }
                
                return { stochK, stochD, stochReversal };
            };
            
            // Enhanced Bollinger Bands with squeeze detection
            const calculateBollingerBands = (prices, period = 20, stdDev = 2) => {
                const sma = [];
                const upperBand = [];
                const lowerBand = [];
                const bandWidth = [];
                const squeeze = [];
                
                for (let i = 0; i < period - 1; i++) {
                    sma.push(null);
                    upperBand.push(null);
                    lowerBand.push(null);
                    bandWidth.push(null);
                    squeeze.push(null);
                }
                
                for (let i = period - 1; i < prices.length; i++) {
                    const slice = prices.slice(i - period + 1, i + 1);
                    const average = slice.reduce((sum, val) => sum + val, 0) / period;
                    sma.push(average);
                    
                    const variance = slice.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) / period;
                    const standardDev = Math.sqrt(variance);
                    
                    const upper = average + (standardDev * stdDev);
                    const lower = average - (standardDev * stdDev);
                    
                    upperBand.push(upper);
                    lowerBand.push(lower);
                    
                    // Calculate band width and detect squeeze
                    const width = (upper - lower) / average;
                    bandWidth.push(width);
                    
                    // Detect Bollinger Band squeeze (volatility contraction)
                    if (i >= period + 20) {
                        const recentWidths = bandWidth.slice(i - 20, i + 1).filter(w => w !== null);
                        const avgWidth = recentWidths.reduce((sum, w) => sum + w, 0) / recentWidths.length;
                        const minWidth = Math.min(...recentWidths);
                        
                        // Squeeze detected when current width is near minimum
                        if (width < avgWidth * 0.7 && width < minWidth * 1.1) {
                            squeeze.push(1); // Squeeze - potential breakout coming
                        } else {
                            squeeze.push(0);
                        }
                    } else {
                        squeeze.push(0);
                    }
                }
                
                return { sma, upperBand, lowerBand, bandWidth, squeeze };
            };
            
            // Calculate all indicators
            const ema12Values = calculateEMA(12, values);
            const ema26Values = calculateEMA(26, values);
            const ema50Values = calculateEMA(50, values);
            const ema200Values = calculateEMA(200, values);
            
            // MACD with histogram reversal detection
            const macdLine = ema12Values.map((e12, i) =>
                ema26Values[i] !== null && e12 !== null ? e12 - ema26Values[i] : null
            );
            const signalLineValues = calculateEMA(9, macdLine.map(v => v || 0));
            const macdHistogram = macdLine.map((macd, i) => 
                macd !== null && signalLineValues[i] !== null ? macd - signalLineValues[i] : null
            );
            
            // Detect MACD crossovers
            const macdCrossover = [];
            for (let i = 1; i < macdLine.length; i++) {
                if (i < 26 || macdLine[i] === null || signalLineValues[i] === null) {
                    macdCrossover.push(null);
                } else {
                    const prevMACD = macdLine[i-1];
                    const prevSignal = signalLineValues[i-1];
                    const currMACD = macdLine[i];
                    const currSignal = signalLineValues[i];
                    
                    // Bullish crossover
                    if (prevMACD <= prevSignal && currMACD > currSignal) {
                        macdCrossover.push(1);
                    }
                    // Bearish crossover
                    else if (prevMACD >= prevSignal && currMACD < currSignal) {
                        macdCrossover.push(-1);
                    }
                    else {
                        macdCrossover.push(0);
                    }
                }
            }
            
            const { rsiValues, rsiDivergence } = calculateRSI(values);
            const stochastic = calculateStochastic(highs, lows, closes);
            const bollinger = calculateBollingerBands(values);
            
            return data.map((item, index) => {
                // Year-over-year calculations with momentum
                let yoyChange = null;
                let yoyMomentum = null;
                if (index >= 252) {
                    const yearAgoValue = data[index - 252]?.value;
                    if (yearAgoValue && yearAgoValue !== 0) {
                        yoyChange = ((item.value - yearAgoValue) / yearAgoValue) * 100;
                        
                        // Calculate momentum of YoY change
                        if (index >= 272) { // 252 + 20 days
                            const prevYoyChange = ((data[index - 20].value - data[index - 272].value) / data[index - 272].value) * 100;
                            yoyMomentum = yoyChange - prevYoyChange;
                        }
                    }
                }
                
                // Enhanced trend strength with acceleration
                let trendStrength = null;
                let trendAcceleration = null;
                if (index >= 20) {
                    const window = data.slice(index - 19, index + 1);
                    const x = Array.from({length: 20}, (_, i) => i);
                    const y = window.map(d => d.value);
                    
                    const n = 20;
                    const sumX = x.reduce((a, b) => a + b, 0);
                    const sumY = y.reduce((a, b) => a + b, 0);
                    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                    
                    let slope = 0;
                    if ((n * sumX2 - sumX * sumX) !== 0) {
                        slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    }
                    
                    trendStrength = (slope / item.value) * 10000;
                    
                    // Calculate trend acceleration
                    if (index >= 40) {
                        const prevWindow = data.slice(index - 39, index - 19);
                        const prevY = prevWindow.map(d => d.value);
                        const prevSumY = prevY.reduce((a, b) => a + b, 0);
                        const prevSumXY = x.reduce((sum, xi, i) => sum + xi * prevY[i], 0);
                        
                        let prevSlope = 0;
                        if ((n * sumX2 - sumX * sumX) !== 0) {
                            prevSlope = (n * prevSumXY - sumX * prevSumY) / (n * sumX2 - sumX * sumX);
                        }
                        
                        const prevTrendStrength = (prevSlope / data[index - 20].value) * 10000;
                        trendAcceleration = trendStrength - prevTrendStrength;
                    }
                }
                
                // Volume analysis with breakout detection
                let volumeMA = null;
                let volumeRatio = null;
                let volumeBreakout = null;
                if (index >= 20 && item.volume > 0) {
                    const volumeSlice = data.slice(index - 19, index + 1).map(d => d.volume);
                    volumeMA = volumeSlice.reduce((sum, vol) => sum + vol, 0) / 20;
                    volumeRatio = volumeMA > 0 ? item.volume / volumeMA : 0;
                    
                    // Detect volume breakouts (2x average with price movement)
                    if (volumeRatio > 2 && index > 0) {
                        const priceChange = (item.value - data[index - 1].value) / data[index - 1].value;
                        if (Math.abs(priceChange) > 0.01) { // 1% price move with high volume
                            volumeBreakout = priceChange > 0 ? 1 : -1;
                        } else {
                            volumeBreakout = 0;
                        }
                    } else {
                        volumeBreakout = 0;
                    }
                }
                
                // Enhanced trading signals combining multiple indicators
                let signal = null;
                let signalStrength = 0;
                const rsi = rsiValues[index];
                const stochK = stochastic.stochK[index];
                const stochD = stochastic.stochD[index];
                const macd = macdLine[index];
                const macdSignal = signalLineValues[index];
                const macdCross = macdCrossover[index];
                const rsiDiv = rsiDivergence[index];
                const stochRev = stochastic.stochReversal[index];
                const bbSqueeze = bollinger.squeeze[index];
                
                if (rsi !== null && stochK !== null && macd !== null && macdSignal !== null) {
                    // MACD crossover signals (weighted heavily)
                    if (macdCross === 1) signalStrength += 3;
                    else if (macdCross === -1) signalStrength -= 3;
                    
                    // RSI divergence signals
                    if (rsiDiv === 1) signalStrength += 2;
                    else if (rsiDiv === -1) signalStrength -= 2;
                    
                    // RSI extreme levels
                    if (rsi < 30) signalStrength += 2;
                    else if (rsi > 70) signalStrength -= 2;
                    else if (rsi < 40) signalStrength += 1;
                    else if (rsi > 60) signalStrength -= 1;
                    
                    // Stochastic signals
                    if (stochRev === 1 && stochK > stochD) signalStrength += 2;
                    else if (stochRev === -1 && stochK < stochD) signalStrength -= 2;
                    
                    // Bollinger Band squeeze breakout potential
                    if (bbSqueeze === 1) {
                        if (item.value > bollinger.upperBand[index]) signalStrength += 2;
                        else if (item.value < bollinger.lowerBand[index]) signalStrength -= 2;
                    }
                    
                    // Volume confirmation
                    if (volumeBreakout === 1) signalStrength += 1;
                    else if (volumeBreakout === -1) signalStrength -= 1;
                    
                    // YoY momentum shifts
                    if (yoyMomentum !== null) {
                        if (yoyMomentum > 5) signalStrength += 1;
                        else if (yoyMomentum < -5) signalStrength -= 1;
                    }
                    
                    // Trend acceleration
                    if (trendAcceleration !== null) {
                        if (trendAcceleration > 0.5) signalStrength += 1;
                        else if (trendAcceleration < -0.5) signalStrength -= 1;
                    }
                    
                    // Final signal determination
                    if (signalStrength >= 4) signal = 2; // Strong buy
                    else if (signalStrength >= 2) signal = 1; // Buy
                    else if (signalStrength <= -4) signal = -2; // Strong sell
                    else if (signalStrength <= -2) signal = -1; // Sell
                    else signal = 0; // Neutral
                }
                
                return {
                    ...item,
                    yoy_change: yoyChange,
                    yoy_momentum: yoyMomentum,
                    trend_strength: trendStrength,
                    trend_acceleration: trendAcceleration,
                    ema12: ema12Values[index],
                    ema26: ema26Values[index],
                    ema50: ema50Values[index],
                    ema200: ema200Values[index],
                    macd: macdLine[index],
                    macd_signal: signalLineValues[index],
                    macd_histogram: macdHistogram[index],
                    macd_crossover: macdCross,
                    rsi: rsiValues[index],
                    rsi_divergence: rsiDiv,
                    stoch_k: stochastic.stochK[index],
                    stoch_d: stochastic.stochD[index],
                    stoch_reversal: stochRev,
                    bb_sma: bollinger.sma[index],
                    bb_upper: bollinger.upperBand[index],
                    bb_lower: bollinger.lowerBand[index],
                    bb_width: bollinger.bandWidth[index],
                    bb_squeeze: bbSqueeze,
                    volume_ma: volumeMA,
                    volume_ratio: volumeRatio,
                    volume_breakout: volumeBreakout,
                    signal: signal,
                    signal_strength: signalStrength
                };
            });
        }
        
        // Enhanced chart rendering with all display modes
        function updateChartRender(chartId) {
            const chart = charts[chartId];
            const canvasElement = document.getElementById(`${chartId}_canvas`);
            
            if (!canvasElement || !chart) return;
            
            if (chart.symbols.length === 0) {
                canvasElement.innerHTML = '<div class="chart-message">🔍 Search for a financial instrument to add to this chart</div>';
                return;
            }
            
            try {
                const traces = [];
                const displayMode = chart.displayMode || 'raw';
                let yLabel = 'Value';
                let layout = {};
                
                chart.symbols.forEach((s, index) => {
                    const symbolData = chart.data[s.symbol];
                    if (!symbolData || symbolData.length === 0) return;
                    
                    const filteredData = filterDataByTimeframe(symbolData, chart.timeframe);
                    if (filteredData.length === 0) return;
                    
                    const lineColor = colorPalette[index % colorPalette.length];
                    let yData, hoverTemplate, processedData;
                    
                    switch (displayMode) {
                        case 'raw':
                            yData = filteredData.map(d => d.value);
                            yLabel = 'Price/Value';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                            processedData = filteredData;
                            break;
                            
                        case 'pct_change':
                            processedData = filteredData.filter(d => d.yoy_change !== null && !isNaN(d.yoy_change));
                            if (processedData.length === 0) return;
                            
                            yData = processedData.map(d => d.yoy_change);
                            yLabel = 'Year-over-Year % Change (Reversal Indicator)';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>YoY Change: %{y:.2f}%<br>Momentum: %{customdata:.2f}<extra></extra>`;
                            
                            // Add momentum as custom data
                            trace.customdata = processedData.map(d => d.yoy_momentum || 0);
                            
                            if (index === 0) {
                                // Zero line
                                traces.push({
                                    x: processedData.map(d => d.date),
                                    y: processedData.map(() => 0),
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: 'Zero Line',
                                    line: { color: '#888', width: 2, dash: 'solid' },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                                
                                // Highlight momentum shifts
                                const momentumShifts = processedData.filter(d => 
                                    d.yoy_momentum !== null && Math.abs(d.yoy_momentum) > 5
                                );
                                if (momentumShifts.length > 0) {
                                    traces.push({
                                        x: momentumShifts.map(d => d.date),
                                        y: momentumShifts.map(d => d.yoy_change),
                                        type: 'scatter',
                                        mode: 'markers',
                                        name: 'Momentum Shifts',
                                        marker: { 
                                            color: momentumShifts.map(d => d.yoy_momentum > 0 ? '#00ff88' : '#ff4444'),
                                            size: 12,
                                            symbol: 'diamond'
                                        },
                                        showlegend: false,
                                        hovertemplate: `<b>MOMENTUM SHIFT</b><br>Date: %{x}<br>YoY: %{y:.2f}%<extra></extra>`
                                    });
                                }
                            }
                            break;
                            
                        case 'trend':
                            processedData = filteredData.map((item, idx) => {
                                if (idx < 20) return { ...item, trend_strength: null };
                                
                                const window = filteredData.slice(idx - 19, idx + 1);
                                const x = Array.from({length: 20}, (_, i) => i);
                                const y = window.map(d => d.value);
                                
                                const n = 20;
                                const sumX = x.reduce((a, b) => a + b, 0);
                                const sumY = y.reduce((a, b) => a + b, 0);
                                const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                                const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                                
                                let slope = 0;
                                if ((n * sumX2 - sumX * sumX) !== 0) {
                                    slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                                }
                                
                                const trendStrength = (slope / item.value) * 10000;
                                return { ...item, trend_strength: trendStrength };
                            }).filter(d => d.trend_strength !== null && !isNaN(d.trend_strength));
                            
                            if (processedData.length === 0) return;
                            
                            yData = processedData.map(d => d.trend_strength);
                            yLabel = 'Trend Strength';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Trend: %{y:.3f}<extra></extra>`;
                            break;
                            
                        case 'rsi':
                            processedData = filteredData.filter(d => d.rsi !== null && !isNaN(d.rsi));
                            if (processedData.length === 0) return;
                            
                            yData = processedData.map(d => d.rsi);
                            yLabel = 'RSI (%) - Overbought/Oversold Reversal Zones';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>RSI: %{y:.1f}%<br>Zone: %{text}<extra></extra>`;
                            
                            // Add zone text
                            trace.text = processedData.map(d => {
                                if (d.rsi < 30) return 'OVERSOLD (Bullish Reversal Zone)';
                                else if (d.rsi > 70) return 'OVERBOUGHT (Bearish Reversal Zone)';
                                else if (d.rsi < 40) return 'Near Oversold';
                                else if (d.rsi > 60) return 'Near Overbought';
                                else return 'Neutral';
                            });
                            
                            if (index === 0) {
                                // Critical reversal zones
                                [70, 50, 30].forEach((level, i) => {
                                    const colors = ['#ff4444', '#888888', '#00ff88'];
                                    const names = ['Overbought (70)', 'Neutral (50)', 'Oversold (30)'];
                                    traces.push({
                                        x: processedData.map(d => d.date),
                                        y: processedData.map(() => level),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: names[i],
                                        line: { color: colors[i], width: 1, dash: 'dash' },
                                        showlegend: false,
                                        hoverinfo: 'skip'
                                    });
                                });
                                
                                // Highlight RSI divergences
                                const divergences = processedData.filter(d => d.rsi_divergence !== 0);
                                if (divergences.length > 0) {
                                    traces.push({
                                        x: divergences.map(d => d.date),
                                        y: divergences.map(d => d.rsi),
                                        type: 'scatter',
                                        mode: 'markers',
                                        name: 'RSI Divergence',
                                        marker: { 
                                            color: divergences.map(d => d.rsi_divergence > 0 ? '#00ff88' : '#ff4444'),
                                            size: 14,
                                            symbol: 'star',
                                            line: { color: '#ffffff', width: 2 }
                                        },
                                        showlegend: true,
                                        hovertemplate: `<b>%{text} DIVERGENCE</b><br>Date: %{x}<br>RSI: %{y:.1f}%<extra></extra>`,
                                        text: divergences.map(d => d.rsi_divergence > 0 ? 'BULLISH' : 'BEARISH')
                                    });
                                }
                            }
                            break;
                            
                        case 'macd':
                            processedData = filteredData.filter(d => d.macd !== null && !isNaN(d.macd));
                            if (processedData.length === 0) return;
                            
                            // MACD Line
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.macd),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} MACD`,
                                line: { color: lineColor, width: 2 },
                                hovertemplate: `<b>${s.symbol} MACD</b><br>Date: %{x}<br>MACD: %{y:.4f}<extra></extra>`
                            });
                            
                            // Signal Line
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.macd_signal),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} Signal`,
                                line: { color: lineColor, width: 1, dash: 'dash' },
                                hovertemplate: `<b>${s.symbol} Signal</b><br>Date: %{x}<br>Signal: %{y:.4f}<extra></extra>`
                            });
                            
                            // Histogram with color coding
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.macd_histogram),
                                type: 'bar',
                                name: `${s.symbol} Histogram`,
                                marker: { 
                                    color: processedData.map(d => {
                                        if (d.macd_histogram > 0) return '#00ff88';
                                        else return '#ff4444';
                                    }),
                                    opacity: 0.7
                                },
                                hovertemplate: `<b>${s.symbol} Histogram</b><br>Date: %{x}<br>Histogram: %{y:.4f}<extra></extra>`
                            });
                            
                            // Highlight MACD crossovers
                            const crossovers = processedData.filter(d => d.macd_crossover !== 0 && d.macd_crossover !== null);
                            if (crossovers.length > 0) {
                                traces.push({
                                    x: crossovers.map(d => d.date),
                                    y: crossovers.map(d => d.macd),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: 'MACD Crossovers',
                                    marker: { 
                                        color: crossovers.map(d => d.macd_crossover > 0 ? '#00ff88' : '#ff4444'),
                                        size: 16,
                                        symbol: 'circle-open',
                                        line: { width: 3 }
                                    },
                                    showlegend: true,
                                    hovertemplate: `<b>%{text} CROSSOVER</b><br>Date: %{x}<br>MACD: %{y:.4f}<extra></extra>`,
                                    text: crossovers.map(d => d.macd_crossover > 0 ? 'BULLISH' : 'BEARISH')
                                });
                            }
                            
                            yLabel = 'MACD - Trend Change Detection';
                            return;
                            
                        case 'bollinger':
                            processedData = filteredData.filter(d => d.bb_sma !== null && !isNaN(d.bb_sma));
                            if (processedData.length === 0) return;
                            
                            // Upper Band
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.bb_upper),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} Upper BB`,
                                line: { color: lineColor, width: 1, dash: 'dot' },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                            
                            // SMA (Middle Band)
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.bb_sma),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} BB SMA`,
                                line: { color: lineColor, width: 2 },
                                hovertemplate: `<b>${s.symbol} SMA</b><br>Date: %{x}<br>SMA: %{y:.4f}<extra></extra>`
                            });
                            
                            // Lower Band
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.bb_lower),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} Lower BB`,
                                line: { color: lineColor, width: 1, dash: 'dot' },
                                fill: 'tonexty',
                                fillcolor: `${lineColor}20`,
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                            
                            // Price line with squeeze detection
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.value),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} Price`,
                                line: { color: '#ffffff', width: 2 },
                                hovertemplate: `<b>${s.symbol} Price</b><br>Date: %{x}<br>Price: %{y:.4f}<br>Band Width: %{customdata:.4f}<extra></extra>`,
                                customdata: processedData.map(d => d.bb_width || 0)
                            });
                            
                            // Highlight Bollinger Band squeezes
                            const squeezes = processedData.filter(d => d.bb_squeeze === 1);
                            if (squeezes.length > 0) {
                                traces.push({
                                    x: squeezes.map(d => d.date),
                                    y: squeezes.map(d => d.value),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: 'BB Squeeze (Breakout Alert)',
                                    marker: { 
                                        color: '#ffaa00',
                                        size: 10,
                                        symbol: 'triangle-up',
                                        line: { color: '#ffffff', width: 1 }
                                    },
                                    showlegend: true,
                                    hovertemplate: `<b>BOLLINGER SQUEEZE</b><br>Date: %{x}<br>Price: %{y:.4f}<br>Potential breakout coming<extra></extra>`
                                });
                            }
                            
                            yLabel = 'Bollinger Bands - Volatility & Breakout Detection';
                            return;
                            
                        case 'stochastic':
                            processedData = filteredData.filter(d => d.stoch_k !== null && !isNaN(d.stoch_k));
                            if (processedData.length === 0) return;
                            
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.stoch_k),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} %K`,
                                line: { color: lineColor, width: 2 },
                                hovertemplate: `<b>${s.symbol} %K</b><br>Date: %{x}<br>%K: %{y:.1f}<extra></extra>`
                            });
                            
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.stoch_d),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} %D`,
                                line: { color: lineColor, width: 1, dash: 'dash' },
                                hovertemplate: `<b>${s.symbol} %D</b><br>Date: %{x}<br>%D: %{y:.1f}<extra></extra>`
                            });
                            
                            if (index === 0) {
                                [80, 20].forEach((level, i) => {
                                    traces.push({
                                        x: processedData.map(d => d.date),
                                        y: processedData.map(() => level),
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: level === 80 ? 'Overbought (80)' : 'Oversold (20)',
                                        line: { color: level === 80 ? 'red' : 'green', width: 1, dash: 'dash' },
                                        showlegend: false,
                                        hoverinfo: 'skip'
                                    });
                                });
                            }
                            
                            yLabel = 'Stochastic %';
                            return;
                            
                        case 'volume':
                            if (!s.symbol.includes('RATE') && !s.symbol.includes('GDP') && !s.symbol.includes('DGS')) {
                                processedData = filteredData.filter(d => d.volume > 0 && d.volume_ma !== null);
                                if (processedData.length === 0) {
                                    yData = filteredData.map(d => d.value);
                                    yLabel = `${s.symbol} (No Volume Data)`;
                                    hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                                    processedData = filteredData;
                                    break;
                                }
                                
                                // Volume bars with breakout coloring
                                traces.push({
                                    x: processedData.map(d => d.date),
                                    y: processedData.map(d => d.volume),
                                    type: 'bar',
                                    name: `${s.symbol} Volume`,
                                    marker: { 
                                        color: processedData.map((d, i) => {
                                            if (d.volume_breakout === 1) return '#00ff88'; // Bullish volume breakout
                                            else if (d.volume_breakout === -1) return '#ff4444'; // Bearish volume breakout
                                            else if (d.volume_ratio > 1.5) return '#ffaa00'; // High volume
                                            else return '#888888'; // Normal volume
                                        }),
                                        opacity: 0.7
                                    },
                                    hovertemplate: `<b>${s.symbol} Volume</b><br>Date: %{x}<br>Volume: %{y:,.0f}<br>Ratio: %{customdata:.2f}x<extra></extra>`,
                                    customdata: processedData.map(d => d.volume_ratio || 0),
                                    yaxis: 'y'
                                });
                                
                                // Volume MA
                                traces.push({
                                    x: processedData.map(d => d.date),
                                    y: processedData.map(d => d.volume_ma),
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: `${s.symbol} Volume MA`,
                                    line: { color: lineColor, width: 2 },
                                    hovertemplate: `<b>${s.symbol} Volume MA</b><br>Date: %{x}<br>Volume MA: %{y:,.0f}<extra></extra>`,
                                    yaxis: 'y'
                                });
                                
                                // Price on secondary y-axis
                                traces.push({
                                    x: processedData.map(d => d.date),
                                    y: processedData.map(d => d.value),
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: `${s.symbol} Price`,
                                    line: { color: '#ffffff', width: 2 },
                                    hovertemplate: `<b>${s.symbol} Price</b><br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>`,
                                    yaxis: 'y2'
                                });
                                
                                // Highlight volume breakouts
                                const volumeBreakouts = processedData.filter(d => d.volume_breakout !== 0);
                                if (volumeBreakouts.length > 0) {
                                    traces.push({
                                        x: volumeBreakouts.map(d => d.date),
                                        y: volumeBreakouts.map(d => d.value),
                                        type: 'scatter',
                                        mode: 'markers',
                                        name: 'Volume Breakouts',
                                        marker: { 
                                            color: volumeBreakouts.map(d => d.volume_breakout > 0 ? '#00ff88' : '#ff4444'),
                                            size: 12,
                                            symbol: 'star',
                                            line: { color: '#ffffff', width: 1 }
                                        },
                                        yaxis: 'y2',
                                        showlegend: true,
                                        hovertemplate: `<b>VOLUME BREAKOUT</b><br>Date: %{x}<br>Price: %{y:.2f}<br>Direction: %{text}<extra></extra>`,
                                        text: volumeBreakouts.map(d => d.volume_breakout > 0 ? 'BULLISH' : 'BEARISH')
                                    });
                                }
                                
                                yLabel = 'Volume Analysis - Trend Confirmation';
                                layout.yaxis2 = {
                                    title: 'Price',
                                    overlaying: 'y',
                                    side: 'right',
                                    gridcolor: '#22222250',
                                    tickfont: { color: '#888' }
                                };
                                return;
                            } else {
                                yData = filteredData.map(d => d.value);
                                yLabel = `${s.symbol} (Volume N/A)`;
                                hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                                processedData = filteredData;
                            }
                            break;
                            
                        case 'multi_indicator':
                            processedData = filteredData.filter(d => 
                                d.rsi !== null && d.macd !== null && !isNaN(d.rsi) && !isNaN(d.macd)
                            );
                            if (processedData.length === 0) {
                                yData = filteredData.map(d => d.value);
                                yLabel = `${s.symbol} (Multi-Indicator N/A)`;
                                hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                                processedData = filteredData;
                                break;
                            }
                            
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.value),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} Price`,
                                line: { color: lineColor, width: 2 },
                                hovertemplate: `<b>${s.symbol} Price</b><br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>`,
                                yaxis: 'y'
                            });
                            
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.rsi),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} RSI`,
                                line: { color: '#ff6600', width: 1 },
                                hovertemplate: `<b>${s.symbol} RSI</b><br>Date: %{x}<br>RSI: %{y:.1f}%<extra></extra>`,
                                yaxis: 'y2'
                            });
                            
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.macd),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} MACD`,
                                line: { color: '#00ff88', width: 1 },
                                hovertemplate: `<b>${s.symbol} MACD</b><br>Date: %{x}<br>MACD: %{y:.4f}<extra></extra>`,
                                yaxis: 'y3'
                            });
                            
                            yLabel = 'Price';
                            layout.yaxis2 = {
                                title: 'RSI (%)',
                                overlaying: 'y',
                                side: 'right',
                                position: 0.85,
                                gridcolor: '#22222250',
                                tickfont: { color: '#888' }
                            };
                            layout.yaxis3 = {
                                title: 'MACD',
                                overlaying: 'y',
                                side: 'right',
                                position: 1,
                                gridcolor: '#22222250',
                                tickfont: { color: '#888' }
                            };
                            return;
                            
                        case 'signals':
                            processedData = filteredData.filter(d => d.signal !== null);
                            if (processedData.length === 0) {
                                yData = filteredData.map(d => d.value);
                                yLabel = `${s.symbol} (Signals N/A)`;
                                hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                                processedData = filteredData;
                                break;
                            }
                            
                            // Price line
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(d => d.value),
                                type: 'scatter',
                                mode: 'lines',
                                name: `${s.symbol} Price`,
                                line: { color: lineColor, width: 2 },
                                hovertemplate: `<b>${s.symbol}</b><br>Date: %{x}<br>Price: %{y:.4f}<extra></extra>`
                            });
                            
                            // Strong buy signals
                            const strongBuySignals = processedData.filter(d => d.signal === 2);
                            if (strongBuySignals.length > 0) {
                                traces.push({
                                    x: strongBuySignals.map(d => d.date),
                                    y: strongBuySignals.map(d => d.value),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: `${s.symbol} Strong Buy`,
                                    marker: { 
                                        color: '#00ff88',
                                        size: 16,
                                        symbol: 'triangle-up',
                                        line: { color: '#ffffff', width: 2 }
                                    },
                                    hovertemplate: `<b>STRONG BUY SIGNAL</b><br>Date: %{x}<br>Price: %{y:.4f}<br>Strength: %{customdata}<extra></extra>`,
                                    customdata: strongBuySignals.map(d => d.signal_strength)
                                });
                            }
                            
                            // Buy signals
                            const buySignals = processedData.filter(d => d.signal === 1);
                            if (buySignals.length > 0) {
                                traces.push({
                                    x: buySignals.map(d => d.date),
                                    y: buySignals.map(d => d.value),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: `${s.symbol} Buy`,
                                    marker: { 
                                        color: '#00ff88',
                                        size: 10,
                                        symbol: 'triangle-up'
                                    },
                                    hovertemplate: `<b>BUY SIGNAL</b><br>Date: %{x}<br>Price: %{y:.4f}<br>Strength: %{customdata}<extra></extra>`,
                                    customdata: buySignals.map(d => d.signal_strength)
                                });
                            }
                            
                            // Strong sell signals
                            const strongSellSignals = processedData.filter(d => d.signal === -2);
                            if (strongSellSignals.length > 0) {
                                traces.push({
                                    x: strongSellSignals.map(d => d.date),
                                    y: strongSellSignals.map(d => d.value),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: `${s.symbol} Strong Sell`,
                                    marker: { 
                                        color: '#ff4444',
                                        size: 16,
                                        symbol: 'triangle-down',
                                        line: { color: '#ffffff', width: 2 }
                                    },
                                    hovertemplate: `<b>STRONG SELL SIGNAL</b><br>Date: %{x}<br>Price: %{y:.4f}<br>Strength: %{customdata}<extra></extra>`,
                                    customdata: strongSellSignals.map(d => d.signal_strength)
                                });
                            }
                            
                            // Sell signals
                            const sellSignals = processedData.filter(d => d.signal === -1);
                            if (sellSignals.length > 0) {
                                traces.push({
                                    x: sellSignals.map(d => d.date),
                                    y: sellSignals.map(d => d.value),
                                    type: 'scatter',
                                    mode: 'markers',
                                    name: `${s.symbol} Sell`,
                                    marker: { 
                                        color: '#ff4444',
                                        size: 10,
                                        symbol: 'triangle-down'
                                    },
                                    hovertemplate: `<b>SELL SIGNAL</b><br>Date: %{x}<br>Price: %{y:.4f}<br>Strength: %{customdata}<extra></extra>`,
                                    customdata: sellSignals.map(d => d.signal_strength)
                                });
                            }
                            
                            yLabel = 'Trading Signals - Multi-Indicator Reversal Detection';
                            return;
                            
                        default:
                            yData = filteredData.map(d => d.value);
                            yLabel = 'Value';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                            processedData = filteredData;
                    }
                    
                    if (!yData || yData.length === 0) return;
                    
                    // Create trace with chart type
                    const chartType = chart.chartType || 'line';
                    const comparisonMode = chart.comparisonMode || 'absolute';
                    let trace;
                    
                    if (chartType === 'candlestick' && displayMode === 'raw' && processedData[0]?.open !== undefined) {
                        trace = {
                            x: processedData.map(d => d.date),
                            open: processedData.map(d => d.open),
                            high: processedData.map(d => d.high),
                            low: processedData.map(d => d.low),
                            close: processedData.map(d => d.close),
                            type: 'candlestick',
                            name: s.symbol,
                            increasing: { line: { color: '#00ff88' } },
                            decreasing: { line: { color: '#ff4444' } }
                        };
                    } else if (chartType === 'ohlc' && displayMode === 'raw' && processedData[0]?.open !== undefined) {
                        trace = {
                            x: processedData.map(d => d.date),
                            open: processedData.map(d => d.open),
                            high: processedData.map(d => d.high),
                            low: processedData.map(d => d.low),
                            close: processedData.map(d => d.close),
                            type: 'ohlc',
                            name: s.symbol,
                            increasing: { line: { color: '#00ff88' } },
                            decreasing: { line: { color: '#ff4444' } }
                        };
                    } else if (chartType === 'area') {
                        trace = {
                            x: processedData.map(d => d.date),
                            y: yData,
                            type: 'scatter',
                            mode: 'lines',
                            name: s.symbol,
                            hovertemplate: hoverTemplate,
                            line: { color: lineColor, width: 2 },
                            fill: 'tozeroy',
                            fillcolor: `${lineColor}40`
                        };
                    } else if (chartType === 'mountain') {
                        trace = {
                            x: processedData.map(d => d.date),
                            y: yData,
                            type: 'scatter',
                            mode: 'lines',
                            name: s.symbol,
                            hovertemplate: hoverTemplate,
                            line: { color: lineColor, width: 2 },
                            fill: 'tonexty',
                            fillcolor: `${lineColor}30`
                        };
                        
                        if (index === 0) {
                            const minValue = Math.min(...yData);
                            traces.push({
                                x: processedData.map(d => d.date),
                                y: processedData.map(() => minValue),
                                type: 'scatter',
                                mode: 'lines',
                                line: { color: 'transparent' },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    } else {
                        // Default line chart
                        trace = {
                            x: processedData.map(d => d.date),
                            y: yData,
                            type: 'scatter',
                            mode: 'lines',
                            name: s.symbol,
                            hovertemplate: hoverTemplate,
                            line: { color: lineColor, width: 2 }
                        };
                    }
                    
                    // Apply comparison mode transformations
                    if (comparisonMode === 'percentage' && trace.y && displayMode === 'raw') {
                        const baseValue = trace.y[0];
                        if (baseValue && baseValue !== 0) {
                            trace.y = trace.y.map(v => ((v - baseValue) / Math.abs(baseValue)) * 100);
                            yLabel = 'Percentage Change from Start (%)';
                            trace.hovertemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Change: %{y:.2f}%<extra></extra>`;
                        }
                    } else if (comparisonMode === 'indexed' && trace.y && displayMode === 'raw') {
                        const baseValue = trace.y[0];
                        if (baseValue && baseValue !== 0) {
                            trace.y = trace.y.map(v => (v / baseValue) * 100);
                            yLabel = 'Indexed (Base = 100)';
                            trace.hovertemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Index: %{y:.2f}<extra></extra>`;
                        }
                    }
                    
                    traces.push(trace);
                });
                
                if (traces.length === 0) {
                    canvasElement.innerHTML = '<div class="chart-message">No data to display for selected timeframe and mode</div>';
                    return;
                }
                
                const finalLayout = {
                    title: {
                        text: `${displayMode.replace('_', ' ').toUpperCase()} VIEW - ${chart.chartType?.toUpperCase() || 'LINE'} - ${chart.comparisonMode?.toUpperCase() || 'ABSOLUTE'}`,
                        font: { color: '#fff', size: 14 },
                        x: 0.5
                    },
                    paper_bgcolor: 'rgba(10, 10, 26, 0.8)',
                    plot_bgcolor: 'rgba(10, 10, 26, 0.8)',
                    font: { color: '#aaa', size: 12 },
                    margin: { t: 60, r: 80, b: 60, l: 80 },
                    xaxis: {
                        type: 'date',
                        gridcolor: 'rgba(255, 255, 255, 0.1)',
                        tickfont: { color: '#888' },
                        rangeslider: { visible: false }
                    },
                    yaxis: {
                        title: { text: yLabel, font: { color: '#aaa' } },
                        gridcolor: 'rgba(255, 255, 255, 0.1)',
                        tickfont: { color: '#888' },
                        zeroline: true,
                        zerolinecolor: '#444',
                        zerolinewidth: 1
                    },
                    hovermode: 'x unified',
                    showlegend: true,
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1,
                        bgcolor: 'rgba(10, 10, 26, 0.8)',
                        bordercolor: '#00ff88',
                        borderwidth: 1,
                        font: { size: 11, color: '#fff' }
                    },
                    height: chart.isFullscreen ? window.innerHeight - 120 : 550,
                    autosize: true,
                    ...layout
                };
                
                const config = {
                    responsive: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['select2d', 'lasso2d'],
                    displayModeBar: true
                };
                
                if (canvasElement.querySelector('.chart-message')) {
                    canvasElement.innerHTML = '';
                }
                
                Plotly.react(canvasElement, traces, finalLayout, config)
                    .then(gd => {
                        charts[chartId].chartInstance = gd;
                        console.log(`✅ Chart ${chartId} rendered successfully`);
                    })
                    .catch(err => {
                        console.error("❌ Plotly rendering error:", err);
                        canvasElement.innerHTML = `
                            <div class="chart-message" style="color: #ff4444;">
                                ❌ Chart rendering error<br>
                                <small>${err.message}</small>
                            </div>
                        `;
                    });
                    
            } catch (error) {
                console.error("❌ Chart render failure:", error);
                canvasElement.innerHTML = `
                    <div class="chart-message" style="color: #ff4444;">
                        ❌ Chart system error<br>
                        <small>${error.message}</small>
                    </div>
                `;
            }
        }
        
        // Display mode toggle
        function toggleChartDisplay(event, chartId, displayMode) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.displayMode = displayMode;
            
            const controlsDiv = event.target.parentElement;
            controlsDiv.querySelectorAll('.display-toggle').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            updateChartRender(chartId);
        }
        
        // Chart type change
        function changeChartType(chartId, chartType) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.chartType = chartType;
            
            const chartWindow = document.getElementById(chartId);
            chartWindow.querySelectorAll('.chart-type-btn').forEach(btn => btn.classList.remove('active'));
            chartWindow.querySelector(`[data-type="${chartType}"]`).classList.add('active');
            
            updateChartRender(chartId);
        }
        
        // Comparison mode change
        function changeComparisonMode(chartId, mode) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.comparisonMode = mode;
            
            const chartWindow = document.getElementById(chartId);
            chartWindow.querySelectorAll('[data-comparison]').forEach(btn => btn.classList.remove('active'));
            chartWindow.querySelector(`[data-comparison="${mode}"]`).classList.add('active');
            
            updateChartRender(chartId);
        }
        
        // Timeframe change
        function changeTimeframe(event, chartId, timeframe) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
            chart.timeframe = timeframe;
            
            const buttonContainer = document.getElementById(`${chartId}_timeframe_buttons`);
            if (buttonContainer) {
                buttonContainer.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
                if(event.target.tagName === 'BUTTON') event.target.classList.add('active');
            }
            updateChartRender(chartId);
        }
        
        // Fullscreen toggle
        function toggleFullscreen(chartId) {
            const chart = charts[chartId];
            const chartWindow = document.getElementById(chartId);
            if (!chart || !chartWindow) return;
            
            chart.isFullscreen = !chart.isFullscreen;
            
            if (chart.isFullscreen) {
                chartWindow.classList.add('fullscreen');
                document.body.style.overflow = 'hidden';
            } else {
                chartWindow.classList.remove('fullscreen');
                document.body.style.overflow = 'auto';
            }
            
            setTimeout(() => {
                updateChartRender(chartId);
            }, 100);
        }
        
        // Update chart symbols display
        function updateChartSymbols(chartId) {
            const chart = charts[chartId];
            if (!chart) return;
            const symbolsDiv = document.getElementById(`${chartId}_symbols`);
            if (!symbolsDiv) return;
            
            symbolsDiv.innerHTML = chart.symbols.map((s, i) => `
                <div class="chart-symbol-tag">
                    <span class="symbol-color-dot" style="background-color: ${colorPalette[i % colorPalette.length]};"></span>
                    ${s.symbol}
                    <span class="remove-symbol" onclick="removeSymbolFromChart(event, '${chartId}', '${s.symbol}')">×</span>
                </div>`).join('');
        }
        
        // Remove symbol from chart
        function removeSymbolFromChart(event, chartId, symbolToRemove) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;

            chart.symbols = chart.symbols.filter(s => s.symbol !== symbolToRemove);
            delete chart.data[symbolToRemove];
            
            updateChartRender(chartId);
            updateChartSymbols(chartId);
            
            if (chart.symbols.length === 0) {
                document.getElementById(`${chartId}_canvas`).innerHTML = '<div class="chart-message">🔍 Search for a financial instrument to add to this chart</div>';
            }
        }
        
        // Filter data by timeframe
        function filterDataByTimeframe(data, timeframe) {
            if (!data || data.length === 0) return data;
            
            const now = new Date();
            let cutoffDate = new Date();
            
            switch(timeframe) {
                case '1D':
                    cutoffDate.setDate(now.getDate() - 1);
                    break;
                case '1W':
                    cutoffDate.setDate(now.getDate() - 7);
                    break;
                case '1M':
                    cutoffDate.setMonth(now.getMonth() - 1);
                    break;
                case '3M':
                    cutoffDate.setMonth(now.getMonth() - 3);
                    break;
                case '6M':
                    cutoffDate.setMonth(now.getMonth() - 6);
                    break;
                case '1Y':
                    cutoffDate.setFullYear(now.getFullYear() - 1);
                    break;
                case '2Y':
                    cutoffDate.setFullYear(now.getFullYear() - 2);
                    break;
                case '5Y':
                    cutoffDate.setFullYear(now.getFullYear() - 5);
                    break;
                case '10Y':
                    cutoffDate.setFullYear(now.getFullYear() - 10);
                    break;
                case '20Y':
                    cutoffDate.setFullYear(now.getFullYear() - 20);
                    break;
                case 'MAX':
                    return data;
            }
            
            return data.filter(item => new Date(item.date) >= cutoffDate);
        }
        
        // Utility functions
        function showTemporaryMessage(text, type = 'info') {
            const popup = document.createElement('div');
            popup.className = `message-popup ${type}`;
            popup.textContent = text;
            document.body.appendChild(popup);
            
            setTimeout(() => popup.remove(), 4000);
        }
        
        // Hide search results when clicking outside
        document.addEventListener('click', function(event) {
            const searchBox = document.getElementById('searchBox');
            const searchResults = document.getElementById('searchResults');
            
            if (!searchBox.contains(event.target) && !searchResults.contains(event.target)) {
                searchResults.style.display = 'none';
            }
        });
        
        // Handle escape key for fullscreen
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                Object.keys(charts).forEach(chartId => {
                    if (charts[chartId].isFullscreen) {
                        toggleFullscreen(chartId);
                    }
                });
            }
        });
        
        // Initialize on page load
        window.onload = init;
    </script>
</body>
</html>