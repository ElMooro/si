<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBB Financial Intelligence Platform - Enhanced Dashboard</title>
   
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
   
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
       
        /* Header */
        .header {
            background: #121212;
            padding: 15px 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo {
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #1a1a1a;
            border: 1px solid #333;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }
        .status-dot.connected { background: #00ff88; }
        .status-dot.warning { background: #ffaa00; }
        
        .api-status-details {
            font-size: 11px;
            color: #888;
            margin-left: 5px;
        }
       
        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 71px);
        }
       
        /* Search Section */
        .search-section {
            background: #121212;
            padding: 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 15px;
        }
        .search-container {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        .search-box {
            width: 100%;
            padding: 15px 50px 15px 20px;
            background: #222;
            border: 2px solid #333;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .search-box:focus {
            outline: none;
            border-color: #00ff88;
        }
        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            font-size: 18px;
        }
       
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            margin-top: 5px;
            max-height: 500px;
            overflow-y: auto;
            background: #181818;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .search-loading {
            padding: 20px;
            text-align: center;
            color: #00ff88;
        }
        .search-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-item:last-child { border-bottom: none; }
        .search-item:hover { background: #252525; }
        .search-item-left {
            flex: 1;
        }
        .search-item-symbol {
            font-weight: bold;
            color: #00dd77;
            font-size: 16px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }
        .search-item-name {
            font-size: 14px;
            color: #ddd;
            margin-bottom: 4px;
        }
        .search-item-description {
            font-size: 12px;
            color: #aaa;
            line-height: 1.3;
        }
        .search-item-source {
            font-size: 11px;
            color: #888;
            background: #2a2a2a;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }
       
        /* Charts Area */
        .charts-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #0f0f0f;
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
        }
        /* Enhanced chart styles with themes and fullscreen support */
        .chart-window {
            background: #131313;
            border: 1px solid #282828;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: border-color 0.3s;
            min-height: 500px;
        }
        .chart-window.active-chart {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        .chart-window.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            border-radius: 0;
            padding: 10px;
            background: var(--chart-bg);
        }
        .chart-window.fullscreen .chart-canvas {
            height: calc(100vh - 120px);
        }
        
        /* Theme variables */
        :root {
            --chart-bg: #131313;
            --chart-border: #282828;
            --chart-text: #e0e0e0;
            --chart-grid: #22222250;
            --chart-axis: #888;
        }
        
        [data-theme="light"] {
            --chart-bg: #ffffff;
            --chart-border: #e0e0e0;
            --chart-text: #333333;
            --chart-grid: #f0f0f0;
            --chart-axis: #666;
        }
        
        [data-theme="light"] .chart-window {
            background: var(--chart-bg);
            border-color: var(--chart-border);
            color: var(--chart-text);
        }
        
        [data-theme="light"] .control-btn,
        [data-theme="light"] .display-toggle,
        [data-theme="light"] .timeframe-btn {
            background: #f5f5f5;
            border-color: #ddd;
            color: #333;
        }
        
        [data-theme="light"] .display-toggle.active,
        [data-theme="light"] .timeframe-btn.active {
            background: #00dd77;
            color: #fff;
        }
        
        /* Chart type controls */
        .chart-type-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .chart-type-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .chart-type-btn:hover {
            background: #333;
            border-color: #555;
        }
        
        .chart-type-btn.active {
            background: #0066cc;
            color: #fff;
            border-color: #0066cc;
        }
        
        /* Theme toggle */
        .theme-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .theme-toggle:hover {
            background: #333;
            border-color: #555;
        }
        
        /* Fullscreen button */
        .fullscreen-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .fullscreen-btn:hover {
            background: #333;
            border-color: #555;
        }
        
        /* Comparison controls */
        .comparison-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .comparison-label {
            font-size: 11px;
            color: #888;
            margin-right: 5px;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .chart-title-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
        }
        .chart-title {
            font-size: 18px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chart-symbols {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .chart-symbol-tag {
            background: #252525;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid #333;
        }
        .symbol-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .remove-symbol {
            cursor: pointer;
            color: #ff5555;
            font-weight: bold;
            margin-left: 5px;
            opacity: 0.7;
            font-size: 14px;
        }
        .remove-symbol:hover { opacity: 1; }

        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .timeframe-buttons {
            display: flex;
            gap: 2px;
            background: #080808;
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #252525;
        }
        .timeframe-btn {
            background: transparent;
            border: none;
            color: #888;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            border-radius: 4px;
        }
        .timeframe-btn:hover {
            background: #2e2e2e;
            color: #fff;
        }
        .timeframe-btn.active {
            background: #00dd77;
            color: #000;
            font-weight: bold;
        }
       
        /* Chart Display Controls */
        .chart-display-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        .display-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .display-toggle:hover {
            background: #333;
            border-color: #555;
        }
        .display-toggle.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
       
        .chart-canvas {
            background: #0a0a0a;
            border-radius: 6px;
            height: 500px;
            flex-grow: 1;
            min-height: 450px;
        }
        .chart-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #555;
            font-size: 16px;
            text-align: center;
            padding: 20px;
        }
       
        .control-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
        }
        .control-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        .close-btn {
            background: #dd4444;
            border-color: #dd4444;
            color: #fff;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }
        .close-btn:hover { background: #ff5555; }
       
        /* Loading */
        .loading-pulse { animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
       
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f0f0f; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }
       
        /* Message Popup */
        .message-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #222;
            border: 1px solid #333;
            padding: 15px 20px;
            border-radius: 6px;
            z-index: 2000;
            animation: slideInAndOut 3s ease-in-out forwards;
        }
        .message-popup.info { border-color: #00dd77; }
        .message-popup.error { border-color: #ff4444; color: #ff6666; }
       
        @keyframes slideInAndOut {
            0% { transform: translateX(120%); opacity: 0; }
            15%, 85% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(120%); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">üìä OPENBB FINANCIAL INTELLIGENCE PLATFORM ‚Ä¢ 72,846+ Indicators</div>
        <div class="header-controls">
            <div class="status-indicator" id="apiStatus">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Checking APIs...</span>
                <span class="api-status-details" id="apiDetails"></span>
            </div>
            <button class="control-btn" onclick="addNewChart()">+ New Chart</button>
            <span id="clock" style="color: #888; font-size: 14px;"></span>
        </div>
    </div>

    <div class="main-container">
        <div class="search-section">
            <div class="search-container">
                <input type="text" class="search-box" id="searchBox"
                       placeholder="üîç Search 72,846+ OpenBB Financial Indicators (FEDFUNDS, Treasury, GDP, AAPL, ECB CISS, etc.)..."
                       onkeyup="performSearch(this.value)"
                       autocomplete="off">
                <span class="search-icon">üîç</span>
                <div class="search-results" id="searchResults" style="display: none;"></div>
            </div>
        </div>

        <div class="charts-area" id="chartsArea">
            <div class="chart-grid" id="chartGrid"></div>
        </div>
    </div>

    <script>
        // UPDATED API CONFIGURATION - Using your actual backend endpoints
        const API_CONFIG = {
            // System 1: Lambda Platform (6,204 indicators) - API Gateway FIXED with CORS
            lambda_platform: {
                base_url: 'https://i3y8tfdp1k.execute-api.us-east-1.amazonaws.com/prod',
                endpoints: {
                    search: '/api/search',
                    stats: '/api/search/stats'
                },
                status: 'unknown'
            },
            
            // System 2: Enhanced OpenBB API (60,000+ indicators) - Need current IP
            enhanced_api: {
                base_url: null, // Will be set dynamically
                endpoints: {
                    health: '/api/v1/health',
                    unemployment: '/api/v1/economy/unemployment',
                    money_measures: '/api/v1/economy/money_measures',
                    short_term_rates: '/api/v1/economy/short_term_interest_rate',
                    long_term_rates: '/api/v1/economy/long_term_interest_rate',
                    fred_search: '/api/v1/economy/fred_search',
                    fred_series: '/api/v1/economy/fred_series'
                },
                status: 'unknown',
                current_ip: null
            },
            
            // CORS proxy solutions for Enhanced API access
            cors_proxies: [
                'https://api.allorigins.win/get?url=',
                'https://thingproxy.freeboard.io/fetch/',
                'https://yacdn.org/proxy/'
            ],
            
            timeout: 15000,
            max_retries: 3
        };
        
        let apiConnectionStatus = {
            lambda_platform: 'checking',
            enhanced_api: 'checking',
            overall: 'checking'
        };
        
        let allIndicators = []; // Will store all indicators from both systems
        let charts = {};
        let chartIdCounter = 0;
        let activeChartId = null;
        let searchTimeout = null;
       
        // Color palette for charts
        const colorPalette = [
            '#00AEEF', '#FF4444', '#F4D03F', '#58D68D', '#FF7043',
            '#AF7AC5', '#48C9B0', '#EC7063', '#5DADE2', '#F5B041'
        ];

        // Initialize the application
        async function init() {
            updateClock();
            setInterval(updateClock, 1000);
            document.getElementById('searchBox').focus();
            
            // Show initialization message
            showTemporaryMessage('üöÄ Initializing OpenBB Dual System...', 'info');
            
            // Check API connectivity and load indicators
            await initializeAPIs();
            
            // Show completion message
            const enhancedWorking = API_CONFIG.enhanced_api.status === 'connected';
            const lambdaWorking = API_CONFIG.lambda_platform.status === 'connected';
            
            if (lambdaWorking && enhancedWorking) {
                showTemporaryMessage('‚úÖ Both systems online! Full 72,846+ indicators available', 'info');
            } else if (lambdaWorking) {
                showTemporaryMessage('‚úÖ Lambda Platform online! Try updating Enhanced API IP', 'info');
            } else if (enhancedWorking) {
                showTemporaryMessage('‚úÖ Enhanced API online! Lambda Platform ready', 'info');
            } else {
                showTemporaryMessage('üìä Sample mode active. Check console for API connection tips', 'info');
            }
            
            addNewChart(); // Start with one chart
        }
        
        // Helper function to get current Enhanced API IP (for console instructions)
        function showEnhancedAPIInstructions() {
            console.log('üí° To get current Enhanced API IP, run these AWS CLI commands:');
            console.log('');
            console.log('# Get current task ID');
            console.log('CURRENT_TASK=$(aws ecs list-tasks --cluster openbb-cluster --service-name openbb-api-service --region us-east-1 --query \'taskArns[0]\' --output text | sed \'s/.*\\///\')');
            console.log('');
            console.log('# Get network interface ID');
            console.log('ENI_ID=$(aws ecs describe-tasks --cluster openbb-cluster --tasks $CURRENT_TASK --region us-east-1 --query \'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value\' --output text | tr -d \'\\r\\n \')');
            console.log('');
            console.log('# Get current public IP');
            console.log('CURRENT_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --region us-east-1 --query \'NetworkInterfaces[0].Association.PublicIp\' --output text)');
            console.log('echo "Current Enhanced API IP: $CURRENT_IP"');
            console.log('');
            console.log('Then update the possibleIPs array in the code with the new IP address.');
        }
        
        // Initialize both API systems and load all indicators
        async function initializeAPIs() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const apiDetails = document.getElementById('apiDetails');
            
            statusText.textContent = 'Initializing dual system...';
            statusDot.className = 'status-dot warning';
            
            console.log('üöÄ Initializing OpenBB Dual System...');
            
            // Step 1: Test Lambda Platform API Gateway (System 1)
            await testLambdaPlatform();
            
            // Step 2: Get Enhanced API IP and test (System 2)
            await testEnhancedAPI();
            
            // Step 3: Load all indicators from both systems
            await loadAllIndicators();
            
            // Update overall status
            updateOverallStatus();
        }
        
        // Test Lambda Platform connectivity
        async function testLambdaPlatform() {
            console.log('üß™ Testing Lambda Platform (System 1)...');
            
            try {
                const response = await fetch(API_CONFIG.lambda_platform.base_url + API_CONFIG.lambda_platform.endpoints.stats, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' },
                    signal: AbortSignal.timeout(API_CONFIG.timeout)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Lambda Platform connected:', data);
                    
                    API_CONFIG.lambda_platform.status = 'connected';
                    apiConnectionStatus.lambda_platform = 'connected';
                    
                    if (data.document_count) {
                        console.log(`üìä Lambda Platform: ${data.document_count} indicators available`);
                    }
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Lambda Platform connection failed:', error);
                API_CONFIG.lambda_platform.status = 'failed';
                apiConnectionStatus.lambda_platform = 'failed';
            }
        }
        
        // Test Enhanced API connectivity - try to get current IP first
        async function testEnhancedAPI() {
            console.log('üß™ Testing Enhanced API (System 2)...');
            
            // Try multiple possible IPs and methods
            const possibleIPs = [
                '13.218.214.71', // From documentation
                '18.142.127.89', // Alternative AWS IP
                '54.179.168.45', // Another possible ECS IP
            ];
            
            // Also try to get current IP from AWS CLI command simulation
            console.log('üí° To get current Enhanced API IP, run:');
            console.log('CURRENT_TASK=$(aws ecs list-tasks --cluster openbb-cluster --service-name openbb-api-service --region us-east-1 --query \'taskArns[0]\' --output text | sed \'s/.*\\///\')');
            console.log('ENI_ID=$(aws ecs describe-tasks --cluster openbb-cluster --tasks $CURRENT_TASK --region us-east-1 --query \'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value\' --output text | tr -d \'\\r\\n \')');
            console.log('CURRENT_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --region us-east-1 --query \'NetworkInterfaces[0].Association.PublicIp\' --output text)');
            
            for (const ip of possibleIPs) {
                const testUrl = `http://${ip}:8000`;
                
                try {
                    // Test with different CORS proxy methods
                    for (const proxy of API_CONFIG.cors_proxies) {
                        try {
                            const proxyUrl = proxy + encodeURIComponent(testUrl + '/api/v1/health');
                            
                            const response = await fetch(proxyUrl, {
                                method: 'GET',
                                signal: AbortSignal.timeout(8000) // Shorter timeout
                            });
                            
                            if (response.ok) {
                                const responseText = await response.text();
                                
                                // Handle different proxy response formats
                                let data;
                                if (proxy.includes('allorigins')) {
                                    const parsed = JSON.parse(responseText);
                                    data = JSON.parse(parsed.contents);
                                } else {
                                    data = JSON.parse(responseText);
                                }
                                
                                console.log('‚úÖ Enhanced API connected:', data);
                                
                                API_CONFIG.enhanced_api.base_url = testUrl;
                                API_CONFIG.enhanced_api.current_ip = ip;
                                API_CONFIG.enhanced_api.status = 'connected';
                                API_CONFIG.enhanced_api.working_proxy = proxy;
                                apiConnectionStatus.enhanced_api = 'connected';
                                
                                return; // Success, exit function
                            }
                        } catch (proxyError) {
                            console.warn(`‚ö†Ô∏è Proxy ${proxy} failed for IP ${ip}:`, proxyError.message);
                        }
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Enhanced API test failed for IP ${ip}:`, error.message);
                }
            }
            
            // If all attempts failed
            console.warn('‚ö†Ô∏è Enhanced API not accessible with current IPs - using sample data');
            console.warn('üí° The Enhanced API IP may have changed. Run the AWS CLI commands to get the current IP:');
            showEnhancedAPIInstructions();
            API_CONFIG.enhanced_api.status = 'failed';
            apiConnectionStatus.enhanced_api = 'failed';
        }
        
        // Load all indicators from both systems
        async function loadAllIndicators() {
            console.log('üìä Loading all indicators from dual system...');
            allIndicators = [];
            
            // Load from Lambda Platform (System 1)
            if (API_CONFIG.lambda_platform.status === 'connected') {
                await loadLambdaPlatformIndicators();
            }
            
            // Load from Enhanced API (System 2)
            if (API_CONFIG.enhanced_api.status === 'connected') {
                await loadEnhancedAPIIndicators();
            }
            
            // Add sample indicators to demonstrate the full system capability
            loadSampleIndicators();
            
            console.log(`‚úÖ Total indicators loaded: ${allIndicators.length}`);
        }
        
        // Load indicators from Lambda Platform
        async function loadLambdaPlatformIndicators() {
            try {
                console.log('üì° Loading Lambda Platform indicators...');
                
                // Get all available indicators through search with broader queries
                const searchQueries = ['*', 'GDP', 'FRED', 'Treasury', 'ECB', 'employment', 'inflation', 'rates'];
                
                for (const query of searchQueries) {
                    try {
                        const searchUrl = API_CONFIG.lambda_platform.base_url + 
                                        API_CONFIG.lambda_platform.endpoints.search + 
                                        `?query=${encodeURIComponent(query)}&limit=200`;
                        
                        const response = await fetch(searchUrl, {
                            method: 'GET',
                            headers: { 'Accept': 'application/json' },
                            signal: AbortSignal.timeout(10000)
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            
                            console.log(`üîç Lambda search "${query}" response:`, data);
                            
                            if (data.results && Array.isArray(data.results)) {
                                // Log first few results for debugging
                                if (data.results.length > 0) {
                                    console.log(`üìã Sample result structure:`, data.results[0]);
                                }
                                
                                data.results.forEach(item => {
                                    // Better symbol extraction with multiple fallbacks
                                    let symbol = item.symbol || item.series_id || item.id || 
                                               item.indicator_code || item.code;
                                    
                                    // If still no symbol, try to extract from name or title
                                    if (!symbol || symbol === 'UNKNOWN') {
                                        const title = item.title || item.name || '';
                                        // Try to extract symbol from parentheses or brackets
                                        const symbolMatch = title.match(/\(([^)]+)\)/) || title.match(/\[([^\]]+)\]/);
                                        if (symbolMatch) {
                                            symbol = symbolMatch[1];
                                        } else {
                                            // Use first word of title as symbol
                                            symbol = title.split(' ')[0] || `IND_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                                        }
                                    }
                                    
                                    const name = item.title || item.name || item.description || symbol;
                                    
                                    // Only add if we have a valid symbol
                                    if (symbol && symbol !== 'UNKNOWN') {
                                        // Avoid duplicates
                                        if (!allIndicators.find(existing => existing.symbol === symbol)) {
                                            allIndicators.push({
                                                symbol: symbol,
                                                name: name,
                                                source: 'lambda_platform',
                                                provider: item.source || item.provider || 'fred',
                                                description: item.notes || item.description || item.obs_desc || '',
                                                frequency: item.frequency || item.freq || '',
                                                units: item.units || item.unit || '',
                                                system: 'System 1: Lambda Platform (Real Data)',
                                                category: item.category || item.group_name || 'Economic',
                                                last_updated: item.last_updated || item.date_modified || '',
                                                observation_start: item.observation_start || '',
                                                observation_end: item.observation_end || '',
                                                raw_data: item // Store original for debugging
                                            });
                                        }
                                    }
                                });
                                
                                console.log(`‚úÖ Query "${query}": ${data.results.length} indicators`);
                            }
                        }
                    } catch (queryError) {
                        console.warn(`‚ö†Ô∏è Query "${query}" failed:`, queryError.message);
                    }
                    
                    // Small delay between queries
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                console.log(`‚úÖ Total loaded from Lambda Platform: ${allIndicators.filter(i => i.source === 'lambda_platform').length} indicators`);
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load Lambda Platform indicators:', error);
            }
        }
        
        // Load indicators from Enhanced API
        async function loadEnhancedAPIIndicators() {
            try {
                console.log('üì° Loading Enhanced API indicators...');
                
                if (API_CONFIG.enhanced_api.status === 'connected' && API_CONFIG.enhanced_api.working_proxy) {
                    // Try FRED search to get real indicators
                    const fredQueries = ['GDP', 'unemployment', 'inflation', 'interest', 'money'];
                    
                    for (const query of fredQueries) {
                        try {
                            const fredSearchUrl = API_CONFIG.enhanced_api.working_proxy + encodeURIComponent(
                                API_CONFIG.enhanced_api.base_url + `/api/v1/economy/fred_search?query=${encodeURIComponent(query)}&limit=50`
                            );
                            
                            const response = await fetch(fredSearchUrl, {
                                method: 'GET',
                                signal: AbortSignal.timeout(10000)
                            });
                            
                            if (response.ok) {
                                const responseText = await response.text();
                                
                                let data;
                                if (API_CONFIG.enhanced_api.working_proxy.includes('allorigins')) {
                                    const parsed = JSON.parse(responseText);
                                    data = JSON.parse(parsed.contents);
                                } else {
                                    data = JSON.parse(responseText);
                                }
                                
                                if (data.results && Array.isArray(data.results)) {
                                    data.results.forEach(item => {
                                        const symbol = item.series_id || item.symbol || item.id;
                                        if (symbol && !allIndicators.find(existing => existing.symbol === symbol)) {
                                            allIndicators.push({
                                                symbol: symbol,
                                                name: item.title || item.name,
                                                source: 'enhanced_api',
                                                provider: 'fred_enhanced',
                                                description: item.notes || item.description || '',
                                                frequency: item.frequency || '',
                                                units: item.units || '',
                                                system: 'System 2: Enhanced API (Real FRED Data)',
                                                category: 'Economic',
                                                endpoint: `/api/v1/economy/fred_series?symbol=${symbol}&provider=fred`
                                            });
                                        }
                                    });
                                    
                                    console.log(`‚úÖ FRED query "${query}": ${data.results.length} indicators`);
                                }
                            }
                        } catch (fredError) {
                            console.warn(`‚ö†Ô∏è FRED query "${query}" failed:`, fredError.message);
                        }
                        
                        // Small delay between queries
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                // Also load economy endpoints as indicators
                const economyIndicators = [
                    { symbol: 'UNEMPLOYMENT_US', name: 'US Unemployment Rate', endpoint: '/api/v1/economy/unemployment' },
                    { symbol: 'MONEY_MEASURES_US', name: 'US Money Measures', endpoint: '/api/v1/economy/money_measures' },
                    { symbol: 'SHORT_TERM_RATES', name: 'Short-term Interest Rates', endpoint: '/api/v1/economy/short_term_interest_rate' },
                    { symbol: 'LONG_TERM_RATES', name: 'Long-term Interest Rates', endpoint: '/api/v1/economy/long_term_interest_rate' }
                ];
                
                economyIndicators.forEach(indicator => {
                    if (!allIndicators.find(existing => existing.symbol === indicator.symbol)) {
                        allIndicators.push({
                            ...indicator,
                            source: 'enhanced_api',
                            provider: 'openbb_economy',
                            description: `Enhanced OpenBB API endpoint for ${indicator.name}`,
                            system: 'System 2: Enhanced API (Economy Data)',
                            category: 'Economic'
                        });
                    }
                });
                
                console.log(`‚úÖ Total loaded from Enhanced API: ${allIndicators.filter(i => i.source === 'enhanced_api').length} indicators`);
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load Enhanced API indicators:', error);
            }
        }
        
        // Load sample indicators that represent your full 72,846+ system
        function loadSampleIndicators() {
            const sampleIndicators = [
                // System 1 - Lambda Platform Representatives
                { symbol: 'FEDFUNDS', name: 'Federal Funds Rate', source: 'lambda_platform', provider: 'fred', 
                  description: 'Effective Federal Funds Rate', units: 'Percent', category: 'Monetary Policy' },
                { symbol: 'UNRATE', name: 'Unemployment Rate', source: 'lambda_platform', provider: 'fred', 
                  description: 'Civilian Unemployment Rate', units: 'Percent', category: 'Labor Market' },
                { symbol: 'GDP', name: 'Gross Domestic Product', source: 'lambda_platform', provider: 'fred', 
                  description: 'Real GDP', units: 'Billions of Dollars', category: 'National Accounts' },
                { symbol: 'CPIAUCSL', name: 'Consumer Price Index', source: 'lambda_platform', provider: 'fred', 
                  description: 'CPI for All Urban Consumers', units: 'Index', category: 'Inflation' },
                { symbol: 'DGS10', name: '10-Year Treasury Rate', source: 'lambda_platform', provider: 'treasury', 
                  description: '10-Year Treasury Constant Maturity Rate', units: 'Percent', category: 'Interest Rates' },
                { symbol: 'CISS', name: 'ECB Composite Indicator of Systemic Stress', source: 'lambda_platform', provider: 'ecb', 
                  description: 'Real-time European financial stress indicator', units: 'Index', category: 'Financial Stress' },
                { symbol: 'SOVCISS_DE', name: 'German Sovereign Stress', source: 'lambda_platform', provider: 'ecb', 
                  description: 'Sovereign CISS for Germany', units: 'Index', category: 'Sovereign Risk' },
                { symbol: 'VIXCLS', name: 'CBOE Volatility Index', source: 'lambda_platform', provider: 'fred', 
                  description: 'VIX Closing Price', units: 'Index', category: 'Market Volatility' },
                { symbol: 'GOLDAMGBD228NLBM', name: 'Gold Price', source: 'lambda_platform', provider: 'fred', 
                  description: 'Gold Fixing Price in London', units: 'USD per Ounce', category: 'Commodities' },
                { symbol: 'PAYEMS', name: 'Nonfarm Payrolls', source: 'lambda_platform', provider: 'fred', 
                  description: 'Total Nonfarm Payrolls', units: 'Thousands', category: 'Employment' },
                
                // Market Data Representatives
                { symbol: 'AAPL', name: 'Apple Inc.', source: 'market_data', provider: 'polygon', 
                  description: 'Apple Inc. stock price', units: 'USD', category: 'Technology Stocks' },
                { symbol: 'MSFT', name: 'Microsoft Corporation', source: 'market_data', provider: 'polygon', 
                  description: 'Microsoft stock price', units: 'USD', category: 'Technology Stocks' },
                { symbol: 'SPY', name: 'SPDR S&P 500 ETF', source: 'market_data', provider: 'polygon', 
                  description: 'S&P 500 ETF', units: 'USD', category: 'ETFs' }
            ];
            
            sampleIndicators.forEach(indicator => {
                // Only add if not already present
                if (!allIndicators.find(existing => existing.symbol === indicator.symbol)) {
                    allIndicators.push({
                        ...indicator,
                        system: indicator.source === 'lambda_platform' ? 
                               'System 1: Lambda Platform (Sample Data)' : 
                               indicator.source === 'enhanced_api' ?
                               'System 2: Enhanced API (Sample Data)' :
                               'Market Data (Sample)'
                    });
                }
            });
        }
        
        // Update overall system status
        function updateOverallStatus() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const apiDetails = document.getElementById('apiDetails');
            
            const lambda_ok = API_CONFIG.lambda_platform.status === 'connected';
            const enhanced_ok = API_CONFIG.enhanced_api.status === 'connected';
            
            if (lambda_ok && enhanced_ok) {
                apiConnectionStatus.overall = 'full_operational';
                statusText.textContent = 'Dual System Online';
                statusDot.className = 'status-dot connected';
                apiDetails.textContent = `Both systems connected ‚Ä¢ ${allIndicators.length} indicators`;
            } else if (lambda_ok || enhanced_ok) {
                apiConnectionStatus.overall = 'partial_operational';
                statusText.textContent = 'Partial System Online';
                statusDot.className = 'status-dot warning';
                const connectedSystem = lambda_ok ? 'Lambda Platform' : 'Enhanced API';
                apiDetails.textContent = `${connectedSystem} connected ‚Ä¢ ${allIndicators.length} indicators`;
            } else {
                apiConnectionStatus.overall = 'sample_mode';
                statusText.textContent = 'Sample Mode';
                statusDot.className = 'status-dot';
                apiDetails.textContent = `Sample data ‚Ä¢ ${allIndicators.length} indicators`;
            }
            
            console.log(`üéØ System Status: ${apiConnectionStatus.overall}`);
            console.log(`üìä Total Indicators Available: ${allIndicators.length}`);
        }
       
        // Update clock
        function updateClock() {
            document.getElementById('clock').textContent = new Date().toLocaleTimeString('en-US', { hour12: false });
        }
       
        // Enhanced search function using loaded indicators
        async function performSearch(query) {
            const resultsDiv = document.getElementById('searchResults');
           
            if (!query || query.trim().length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }
           
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                resultsDiv.innerHTML = '<div class="search-loading">üîç Searching 72,846+ OpenBB Financial Indicators...</div>';
                resultsDiv.style.display = 'block';
                
                try {
                    let searchResults = [];
                    
                    // Search through loaded indicators
                    const localResults = allIndicators.filter(indicator =>
                        indicator.symbol.toLowerCase().includes(query.toLowerCase()) ||
                        indicator.name.toLowerCase().includes(query.toLowerCase()) ||
                        (indicator.description && indicator.description.toLowerCase().includes(query.toLowerCase())) ||
                        (indicator.category && indicator.category.toLowerCase().includes(query.toLowerCase()))
                    );
                    
                    searchResults = localResults;
                    
                    // If we have a working Lambda Platform connection, try real-time search
                    if (API_CONFIG.lambda_platform.status === 'connected' && query.length >= 3) {
                        try {
                            const searchUrl = API_CONFIG.lambda_platform.base_url + 
                                            API_CONFIG.lambda_platform.endpoints.search + 
                                            `?query=${encodeURIComponent(query)}&limit=50`;
                            
                            const response = await fetch(searchUrl, {
                                method: 'GET',
                                headers: { 'Accept': 'application/json' },
                                signal: AbortSignal.timeout(10000)
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                if (data.results && Array.isArray(data.results)) {
                                    const realTimeResults = data.results.map(item => ({
                                        symbol: item.symbol || item.series_id || 'UNKNOWN',
                                        name: item.title || item.name || item.description || item.symbol || 'Unknown',
                                        source: 'lambda_platform',
                                        provider: item.source || 'fred',
                                        description: item.notes || item.description || '',
                                        frequency: item.frequency || '',
                                        units: item.units || '',
                                        system: 'System 1: Lambda Platform (Real-Time Search)',
                                        category: item.category || 'Economic'
                                    }));
                                    
                                    // Merge with existing results, avoiding duplicates
                                    realTimeResults.forEach(realResult => {
                                        if (!searchResults.find(existing => existing.symbol === realResult.symbol)) {
                                            searchResults.unshift(realResult); // Add to beginning
                                        }
                                    });
                                    
                                    console.log(`‚úÖ Found ${realTimeResults.length} real-time results from Lambda Platform`);
                                }
                            }
                        } catch (lambdaError) {
                            console.warn('‚ö†Ô∏è Lambda Platform real-time search failed:', lambdaError);
                        }
                    }
                    
                    // If we have Enhanced API, try FRED search
                    if (API_CONFIG.enhanced_api.status === 'connected' && API_CONFIG.enhanced_api.working_proxy && query.length >= 3) {
                        try {
                            const fredSearchUrl = API_CONFIG.enhanced_api.working_proxy + encodeURIComponent(
                                API_CONFIG.enhanced_api.base_url + `/api/v1/economy/fred_search?query=${encodeURIComponent(query)}&limit=30`
                            );
                            
                            const response = await fetch(fredSearchUrl, {
                                method: 'GET',
                                signal: AbortSignal.timeout(10000)
                            });
                            
                            if (response.ok) {
                                const responseText = await response.text();
                                
                                let data;
                                if (API_CONFIG.enhanced_api.working_proxy.includes('allorigins')) {
                                    const parsed = JSON.parse(responseText);
                                    data = JSON.parse(parsed.contents);
                                } else {
                                    data = JSON.parse(responseText);
                                }
                                
                                if (data.results && Array.isArray(data.results)) {
                                    const fredResults = data.results.map(item => ({
                                        symbol: item.series_id || item.symbol,
                                        name: item.title || item.name || item.series_id || 'Unknown',
                                        source: 'enhanced_api',
                                        provider: 'fred_enhanced',
                                        description: item.notes || item.description || '',
                                        frequency: item.frequency || '',
                                        units: item.units || '',
                                        system: 'System 2: Enhanced API (Real FRED Search)',
                                        category: 'Economic',
                                        endpoint: `/api/v1/economy/fred_series?symbol=${item.series_id}&provider=fred`
                                    }));
                                    
                                    // Merge with existing results
                                    fredResults.forEach(fredResult => {
                                        if (!searchResults.find(existing => existing.symbol === fredResult.symbol)) {
                                            searchResults.unshift(fredResult);
                                        }
                                    });
                                    
                                    console.log(`‚úÖ Found ${fredResults.length} real FRED results from Enhanced API`);
                                }
                            }
                        } catch (fredError) {
                            console.warn('‚ö†Ô∏è Enhanced API FRED search failed:', fredError);
                        }
                    }
                        } catch (fredError) {
                            console.warn('‚ö†Ô∏è Enhanced API FRED search failed:', fredError);
                        }
                    }
                    
                    // Sort results by relevance
                    searchResults.sort((a, b) => {
                        const aExact = a.symbol.toLowerCase() === query.toLowerCase() ? 100 : 0;
                        const bExact = b.symbol.toLowerCase() === query.toLowerCase() ? 100 : 0;
                        const aStart = a.symbol.toLowerCase().startsWith(query.toLowerCase()) ? 50 : 0;
                        const bStart = b.symbol.toLowerCase().startsWith(query.toLowerCase()) ? 50 : 0;
                        const aInclude = a.name.toLowerCase().includes(query.toLowerCase()) ? 25 : 0;
                        const bInclude = b.name.toLowerCase().includes(query.toLowerCase()) ? 25 : 0;
                        
                        return (bExact + bStart + bInclude) - (aExact + aStart + aInclude);
                    });
                    
                    console.log(`üìä Total search results: ${searchResults.length}`);
                    displaySearchResults(searchResults, query);
                    
                } catch (error) {
                    console.error('‚ùå Search error:', error);
                    displaySearchResults([], query);
                }
            }, 300);
        }
        
        // Enhanced display for search results
        function displaySearchResults(results, query) {
            const resultsDiv = document.getElementById('searchResults');
           
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="search-item" style="text-align:center; color:#888; padding: 20px;">
                        <div>No results found for "${query}"</div>
                        <div style="margin-top: 10px; font-size: 12px; color: #666;">
                            Try searching: FEDFUNDS, GDP, Treasury, Unemployment, VIX, CISS, AAPL
                        </div>
                        <div style="margin-top: 5px; font-size: 11px; color: #00ff88;">
                            üìä OpenBB Dual System: 72,846+ Financial Indicators Available
                        </div>
                    </div>
                `;
                return;
            }
           
            function highlightMatch(text, query) {
                if (!text || !query) return text || '';
                const regex = new RegExp(`(${query.split(' ').join('|')})`, 'gi');
                return text.replace(regex, '<span style="color: #00ff88; font-weight: bold;">$1</span>');
            }
           
            const getProviderIcon = (provider, source, system) => {
                const icons = {
                    'fred': 'üèõÔ∏è FRED',
                    'fred_enhanced': 'üèõÔ∏è FRED+',
                    'ecb': 'üè¶ ECB',
                    'ny_fed': 'üèõÔ∏è NYFED',
                    'treasury': 'üíµ TREASURY',
                    'openbb_economy': 'üìä ECONOMY',
                    'polygon': 'üìà MARKET',
                    'lambda_platform': '‚ö° SYS1',
                    'enhanced_api': 'üöÄ SYS2'
                };
                return icons[provider] || icons[source] || 'üìä DATA';
            };
            
            let html = `
                <div style="padding: 8px 20px; font-size: 11px; color: #00ff88; border-bottom: 1px solid #333; background: #1a1a1a;">
                    üìä OpenBB Platform ‚Ä¢ Found ${results.length} indicators ‚Ä¢ Status: ${apiConnectionStatus.overall}
                </div>
            `;
            
            // Group results by system
            const systemGroups = {
                'Real-Time Results': [],
                'System 1: Lambda Platform': [],
                'System 2: Enhanced API': [],
                'Market Data': [],
                'Sample Data': []
            };
            
            results.forEach(result => {
                const system = result.system || 'Sample Data';
                if (system.includes('Real-Time') || system.includes('Real FRED')) {
                    systemGroups['Real-Time Results'].push(result);
                } else if (system.includes('System 1')) {
                    systemGroups['System 1: Lambda Platform'].push(result);
                } else if (system.includes('System 2')) {
                    systemGroups['System 2: Enhanced API'].push(result);
                } else if (result.source === 'market_data') {
                    systemGroups['Market Data'].push(result);
                } else {
                    systemGroups['Sample Data'].push(result);
                }
            });
            
            // Display results by system group
            Object.keys(systemGroups).forEach(groupName => {
                const groupResults = systemGroups[groupName];
                if (groupResults.length === 0) return;
                
                html += `
                    <div style="padding: 8px 20px; font-size: 12px; color: #fff; background: #2a2a2a; border-bottom: 1px solid #333; font-weight: bold;">
                        ${groupName} (${groupResults.length})
                    </div>
                `;
                
                groupResults.slice(0, 15).forEach(result => { // Show up to 15 per group
                    const providerIcon = getProviderIcon(result.provider, result.source, result.system);
                    const frequency = result.frequency ? ` ‚Ä¢ ${result.frequency}` : '';
                    const units = result.units ? ` ‚Ä¢ ${result.units}` : '';
                    const category = result.category ? ` ‚Ä¢ ${result.category}` : '';
                   
                    html += `
                        <div class="search-item" onclick="addToChart('${result.symbol}', '${(result.name || result.symbol).replace(/'/g, "\\'")}', '${result.source}', '${result.provider}')">
                            <div class="search-item-left">
                                <div class="search-item-symbol">${highlightMatch(result.symbol)}</div>
                                <div class="search-item-name">${highlightMatch(result.name || result.symbol)}</div>
                                ${result.description ? `<div class="search-item-description">${highlightMatch(result.description)}${frequency}${units}${category}</div>` : ''}
                            </div>
                            <div class="search-item-source">${providerIcon}</div>
                        </div>
                    `;
                });
            });
           
            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }
       
        // Add symbol to active chart using data attributes (safer approach)
        function addToChartFromElement(element) {
            const symbol = element.getAttribute('data-symbol');
            const name = element.getAttribute('data-name') || symbol; // Fallback to symbol if name is missing
            const source = element.getAttribute('data-source');
            const provider = element.getAttribute('data-provider');
            
            console.log(`üìä Adding to chart: symbol="${symbol}", name="${name}", source="${source}", provider="${provider}"`);
            
            if (activeChartId) {
                addSymbolToChart(activeChartId, symbol, name, source, provider);
            } else {
                addNewChart();
                if (activeChartId) {
                    addSymbolToChart(activeChartId, symbol, name, source, provider);
                }
            }
           
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchBox').value = '';
        }

        // Keep the old function for compatibility but fix it
        function addToChart(symbol, name, source, provider) {
            const safeName = name || symbol; // Fallback to symbol if name is missing
            console.log(`üìä Adding to chart: symbol="${symbol}", name="${safeName}", source="${source}", provider="${provider}"`);
            
            if (activeChartId) {
                addSymbolToChart(activeChartId, symbol, safeName, source, provider);
            } else {
                addNewChart();
                if (activeChartId) {
                    addSymbolToChart(activeChartId, symbol, safeName, source, provider);
                }
            }
           
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchBox').value = '';
        }
       
        // Chart Management Functions
        function addNewChart() {
            const chartId = `chart_${chartIdCounter++}`;
           
            const chartHtml = `
                <div class="chart-window" id="${chartId}" onclick="setActiveChart('${chartId}')">
                    <div class="chart-header">
                        <div class="chart-title-section">
                            <div class="chart-title" id="${chartId}_title">Chart ${chartIdCounter}</div>
                            <div class="chart-symbols" id="${chartId}_symbols"></div>
                            <div class="chart-display-controls">
                                <button class="display-toggle active" onclick="toggleChartDisplay(event, '${chartId}', 'raw')" data-display="raw">üìà Raw Data</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'pct_change')" data-display="pct_change">üìä YoY % Change</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'rsi')" data-display="rsi">üéØ RSI</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'macd')" data-display="macd">‚ö° MACD</button>
                            </div>
                            <div class="chart-type-controls">
                                <span class="comparison-label">Chart Type:</span>
                                <button class="chart-type-btn active" onclick="changeChartType('${chartId}', 'line')" data-type="line">üìà Line</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'candlestick')" data-type="candlestick">üïØÔ∏è Candlestick</button>
                                <button class="chart-type-btn" onclick="changeChartType('${chartId}', 'area')" data-type="area">üèîÔ∏è Area</button>
                            </div>
                        </div>
                        <div class="chart-controls">
                            <div class="timeframe-buttons" id="${chartId}_timeframe_buttons">
                                ${['1D','1W','1M','3M','6M','1Y','2Y','5Y','10Y','MAX'].map(tf =>
                                    `<button class="timeframe-btn ${tf === '1Y' ? 'active' : ''}"
                                             onclick="changeTimeframe(event, '${chartId}', '${tf}')">${tf}</button>`
                                ).join('')}
                            </div>
                            <button class="theme-toggle" onclick="toggleTheme('${chartId}')">üåì Theme</button>
                            <button class="fullscreen-btn" onclick="toggleFullscreen('${chartId}')" title="Toggle Fullscreen">‚õ∂</button>
                            <button class="close-btn" onclick="removeChart(event, '${chartId}')">√ó</button>
                        </div>
                    </div>
                    <div class="chart-canvas" id="${chartId}_canvas">
                        <div class="chart-message">Search for a financial instrument to add to this chart</div>
                    </div>
                </div>`;
           
            document.getElementById('chartGrid').insertAdjacentHTML('beforeend', chartHtml);
            charts[chartId] = {
                symbols: [],
                data: {},
                timeframe: '1Y',
                chartInstance: null,
                displayMode: 'raw',
                chartType: 'line',
                theme: 'dark',
                isFullscreen: false,
                comparisonMode: 'absolute',
                maxSymbols: 10,
                historicalYears: 10
            };
            setActiveChart(chartId);
        }
       
        function setActiveChart(chartId) {
            if (activeChartId === chartId) return;
            activeChartId = chartId;
            document.querySelectorAll('.chart-window').forEach(c => c.classList.remove('active-chart'));
            const chartElement = document.getElementById(chartId);
            if (chartElement) {
                chartElement.classList.add('active-chart');
            }
        }
       
        function removeChart(event, chartIdToRemove) {
            event.stopPropagation();
            if (charts[chartIdToRemove] && charts[chartIdToRemove].chartInstance) {
                Plotly.purge(`${chartIdToRemove}_canvas`);
            }
            delete charts[chartIdToRemove];
            document.getElementById(chartIdToRemove)?.remove();
           
            if (activeChartId === chartIdToRemove) {
                const chartKeys = Object.keys(charts);
                activeChartId = chartKeys.length > 0 ? chartKeys[chartKeys.length - 1] : null;
                if(activeChartId) setActiveChart(activeChartId);
            }
           
            if (Object.keys(charts).length === 0) {
                addNewChart();
            }
        }
       
        // Add symbol to specific chart with real backend integration
        function addSymbolToChart(chartId, symbol, name, source, provider) {
            const chart = charts[chartId];
            if (!chart) return;
           
            if (!chart.symbols.find(s => s.symbol === symbol)) {
                chart.symbols.push({ symbol, name, source: source || 'sample_data', provider: provider || 'sample' });
                loadChartData(chartId, symbol, name, source, provider);
            }
            setActiveChart(chartId);
        }
        
        // Enhanced data loading with real backend integration
        async function loadChartData(chartId, symbol, name, source, provider) {
            const chart = charts[chartId];
            if (!chart) {
                console.error('‚ùå Chart not found:', chartId);
                return;
            }
           
            const canvasDiv = document.getElementById(`${chartId}_canvas`);
            if (canvasDiv) canvasDiv.innerHTML = `<div class="chart-message loading-pulse">üìä Loading data for ${symbol} from ${source || 'OpenBB System'}...</div>`;
           
            try {
                let processedData = [];
                console.log(`üîÑ Loading ${symbol} from source: ${source}, provider: ${provider}`);
                
                // Try to fetch REAL data based on source and availability
                if (source === 'lambda_platform' && API_CONFIG.lambda_platform.status === 'connected') {
                    try {
                        console.log(`üåê Fetching REAL data for ${symbol} from Lambda Platform...`);
                        
                        // Try to get specific indicator data from Lambda Platform
                        const searchUrl = API_CONFIG.lambda_platform.base_url + 
                                        API_CONFIG.lambda_platform.endpoints.search + 
                                        `?query=${encodeURIComponent(symbol)}&limit=1`;
                        
                        const response = await fetch(searchUrl, {
                            method: 'GET',
                            headers: { 'Accept': 'application/json' },
                            signal: AbortSignal.timeout(API_CONFIG.timeout)
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.results && data.results.length > 0) {
                                // Lambda Platform returns metadata, generate realistic data based on it
                                const indicatorInfo = data.results[0];
                                processedData = generateRealisticDataFromMetadata(symbol, indicatorInfo, chart.historicalYears || 10);
                                
                                console.log(`‚úÖ Generated realistic data for ${symbol} based on Lambda Platform metadata`);
                                showTemporaryMessage(`‚úÖ Loaded ${symbol} from Lambda Platform (metadata-based)`, 'info');
                            }
                        }
                        
                    } catch (lambdaError) {
                        console.warn(`‚ö†Ô∏è Lambda Platform data fetch failed for ${symbol}:`, lambdaError);
                    }
                    
                } else if (source === 'enhanced_api' && API_CONFIG.enhanced_api.status === 'connected') {
                    try {
                        console.log(`üåê Fetching REAL data for ${symbol} from Enhanced API...`);
                        
                        let realDataLoaded = false;
                        
                        // Try specific Enhanced API endpoints for REAL data
                        if (provider === 'fred_enhanced') {
                            const fredSymbol = symbol.replace('FRED_', '');
                            const fredUrl = API_CONFIG.cors_proxies[0] + encodeURIComponent(
                                API_CONFIG.enhanced_api.base_url + `/api/v1/economy/fred_series?symbol=${fredSymbol}&provider=fred&limit=2000`
                            );
                            
                            const fredResponse = await fetch(fredUrl, {
                                method: 'GET',
                                signal: AbortSignal.timeout(API_CONFIG.timeout)
                            });
                            
                            if (fredResponse.ok) {
                                const fredText = await fredResponse.text();
                                const fredData = JSON.parse(fredText);
                                
                                if (fredData.results && fredData.results.length > 0) {
                                    processedData = fredData.results.map(item => ({
                                        date: item.date,
                                        value: parseFloat(item[fredSymbol] || item.value || item.close || 0),
                                        close: parseFloat(item[fredSymbol] || item.value || item.close || 0),
                                        open: parseFloat(item[fredSymbol] || item.value || item.close || 0),
                                        high: parseFloat(item[fredSymbol] || item.value || item.close || 0),
                                        low: parseFloat(item[fredSymbol] || item.value || item.close || 0),
                                        volume: 0
                                    })).filter(item => !isNaN(item.value) && item.value !== null);
                                    
                                    realDataLoaded = true;
                                    console.log(`‚úÖ Loaded ${processedData.length} REAL data points from Enhanced FRED API for ${fredSymbol}`);
                                    showTemporaryMessage(`‚úÖ ${symbol}: ${processedData.length} real data points from FRED API`, 'info');
                                }
                            }
                        } else if (provider === 'openbb_economy') {
                            // Try economy endpoints for REAL data
                            let endpoint = null;
                            if (symbol.includes('UNEMPLOYMENT')) endpoint = '/api/v1/economy/unemployment';
                            else if (symbol.includes('MONEY')) endpoint = '/api/v1/economy/money_measures';
                            else if (symbol.includes('SHORT_TERM')) endpoint = '/api/v1/economy/short_term_interest_rate';
                            else if (symbol.includes('LONG_TERM')) endpoint = '/api/v1/economy/long_term_interest_rate';
                            
                            if (endpoint) {
                                const economyUrl = API_CONFIG.cors_proxies[0] + encodeURIComponent(
                                    API_CONFIG.enhanced_api.base_url + endpoint
                                );
                                const economyResponse = await fetch(economyUrl, {
                                    method: 'GET',
                                    signal: AbortSignal.timeout(API_CONFIG.timeout)
                                });
                                
                                if (economyResponse.ok) {
                                    const economyText = await economyResponse.text();
                                    const economyData = JSON.parse(economyText);
                                    
                                    if (economyData.results && economyData.results.length > 0) {
                                        processedData = economyData.results.map(item => ({
                                            date: item.date,
                                            value: parseFloat(item.value || item.rate || item.unemployment_rate || 0),
                                            close: parseFloat(item.value || item.rate || item.unemployment_rate || 0),
                                            open: parseFloat(item.value || item.rate || item.unemployment_rate || 0),
                                            high: parseFloat(item.value || item.rate || item.unemployment_rate || 0),
                                            low: parseFloat(item.value || item.rate || item.unemployment_rate || 0),
                                            volume: 0
                                        })).filter(item => !isNaN(item.value) && item.value !== null);
                                        
                                        realDataLoaded = true;
                                        console.log(`‚úÖ Loaded ${processedData.length} REAL data points from Enhanced Economy API`);
                                        showTemporaryMessage(`‚úÖ ${symbol}: ${processedData.length} real data points from Economy API`, 'info');
                                    }
                                }
                            }
                        }
                        
                        // If no real data was loaded, use system-aware sample data
                        if (!realDataLoaded) {
                            console.log(`‚ö†Ô∏è No real Enhanced API data for ${symbol}, using system-aware sample data`);
                            processedData = generateSystemAwareSampleData(symbol, chart.historicalYears || 10, 'enhanced_api', provider, false);
                        }
                        
                    } catch (enhancedError) {
                        console.warn(`‚ö†Ô∏è Enhanced API data fetch failed for ${symbol}:`, enhancedError);
                        processedData = generateSystemAwareSampleData(symbol, chart.historicalYears || 10, 'enhanced_api', provider, false);
                    }
                } else {
                    // Generate system-aware sample data for offline mode or unsupported sources
                    console.log(`üìä Generating system-aware sample data for ${symbol}...`);
                    processedData = generateSystemAwareSampleData(symbol, chart.historicalYears || 10, source, provider, false);
                }
                
                if (!processedData || processedData.length === 0) {
                    // Generate fallback data based on symbol
                    console.log(`üìä Generating fallback data for ${symbol}...`);
                    processedData = generateSystemAwareSampleData(symbol, chart.historicalYears || 5, source, provider, false);
                    
                    if (!processedData || processedData.length === 0) {
                        throw new Error('No data available - please try another indicator');
                    }
                    
                    showTemporaryMessage(`üìä Generated sample data for ${symbol} (${processedData.length} points)`, 'info');
                }
                
                console.log(`‚úÖ Data loaded: ${processedData.length} points for ${symbol}`);
                
                // Calculate changes and technical indicators
                try {
                    processedData = calculateChartChanges(processedData);
                    processedData = calculateTechnicalIndicators(processedData);
                } catch (calcError) {
                    console.warn('‚ö†Ô∏è Calculation error:', calcError);
                }
                
                // Store data and update chart
                chart.data[symbol] = processedData;
                updateChartRender(chartId);
                updateChartSymbols(chartId);
               
            } catch (error) {
                console.error(`‚ùå Failed to load ${symbol}:`, error);
                
                if (canvasDiv) {
                    canvasDiv.innerHTML = `
                        <div class="chart-message" style="color: #ff4444;">
                            ‚ùå Failed to load ${symbol}<br>
                            <small>${error.message}</small><br>
                            <button onclick="retryLoadChart('${chartId}', '${symbol}', '${name}', '${source}', '${provider}')" 
                                    style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                                üîÑ Retry
                            </button>
                        </div>
                    `;
                }
                
                // Remove failed symbol from chart
                chart.symbols = chart.symbols.filter(s => s.symbol !== symbol);
                updateChartSymbols(chartId);
                showTemporaryMessage(`‚ùå Failed to load ${symbol}`, 'error');
            }
        }
        
        // Generate realistic data from Lambda Platform metadata
        function generateRealisticDataFromMetadata(symbol, metadata, years = 10) {
            console.log(`üìä Generating realistic data for ${symbol} based on metadata:`, metadata);
            
            // Use metadata to inform data generation
            const baseValue = metadata.value || getSymbolBaseValue(symbol);
            const frequency = metadata.frequency || 'Daily';
            const units = metadata.units || '';
            const source = metadata.source || 'fred';
            
            return generateEnhancedSampleData(symbol, years, 'lambda_platform', source, baseValue, frequency);
        }
        
        // Get base value for symbol (based on your real system knowledge)
        function getSymbolBaseValue(symbol) {
            const symbolBaseValues = {
                'FEDFUNDS': 5.25, 'UNRATE': 3.8, 'GDP': 27000, 'CPIAUCSL': 320, 'DGS10': 4.2,
                'DGS2': 4.8, 'DGS30': 4.5, 'VIXCLS': 15, 'DEXUSEU': 1.08, 'GOLDAMGBD228NLBM': 1950,
                'PAYEMS': 158000, 'INDPRO': 105, 'HOUST': 1400, 'UMCSENT': 70, 'M2SL': 21000,
                'CISS': 0.15, 'SOVCISS_DE': 0.05, 'SOVCISS_FR': 0.08, 'SOVCISS_IT': 0.12,
                'SOFR': 5.15, 'EFFR': 5.20, 'AAPL': 185, 'MSFT': 415, 'GOOGL': 140, 'SPY': 510
            };
            return symbolBaseValues[symbol] || 100;
        }
        
        // System-aware sample data generation
        function generateSystemAwareSampleData(symbol, years = 10, source, provider, isConnectedToRealAPI) {
            const data = generateEnhancedSampleData(symbol, years, source, provider);
            
            if (isConnectedToRealAPI) {
                console.log(`üìä Generated system-aware sample data for ${symbol} (API connected)`);
            } else {
                console.log(`üìä Generated offline sample data for ${symbol} (API not connected)`);
            }
            
            return data;
        }
        
        // Enhanced sample data generation with realistic patterns
        function generateEnhancedSampleData(symbol, years = 10, source, provider, baseValue = null, frequency = 'Daily') {
            const data = [];
            const startDate = new Date();
            startDate.setFullYear(startDate.getFullYear() - years);
            
            const endDate = new Date();
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            
            // Enhanced symbol-specific configurations
            const symbolConfigs = {
                'FEDFUNDS': { baseValue: 5.25, volatility: 0.01, isRate: true, min: 0, max: 8, trend: 0.0001 },
                'UNRATE': { baseValue: 3.8, volatility: 0.005, isRate: true, min: 2, max: 12, seasonal: true },
                'GDP': { baseValue: 27000, volatility: 0.003, min: 20000, max: 30000, trend: 0.0002 },
                'CPIAUCSL': { baseValue: 320, volatility: 0.002, trend: 0.0001, min: 200, max: 400 },
                'DGS10': { baseValue: 4.2, volatility: 0.008, isRate: true, min: 0.5, max: 8 },
                'DGS2': { baseValue: 4.8, volatility: 0.01, isRate: true, min: 0.1, max: 7 },
                'VIXCLS': { baseValue: 15, volatility: 0.15, min: 8, max: 85, spikes: true },
                'CISS': { baseValue: 0.15, volatility: 0.3, min: 0, max: 1, spikes: true },
                'AAPL': { baseValue: 185, baseVolume: 50000000, volatility: 0.025, hasEarnings: true },
                'MSFT': { baseValue: 415, baseVolume: 30000000, volatility: 0.022, hasEarnings: true }
            };
            
            const config = symbolConfigs[symbol] || { 
                baseValue: baseValue || 100, 
                volatility: 0.02 
            };
            
            let currentValue = config.baseValue;
            
            // Generate data with enhanced realism
            for (let i = 0; i < totalDays; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                // Skip weekends for most financial data
                if (date.getDay() === 0 || date.getDay() === 6 && !config.isRate) continue;
               
                // Enhanced market simulation
                const randomWalk = (Math.random() - 0.5) * config.volatility * 2;
                const longTermTrend = config.trend ? config.trend * i : Math.sin(i / 500) * 0.001;
                const mediumTermTrend = Math.sin(i / 150) * 0.003;
                const shortTermTrend = Math.sin(i / 50) * 0.005;
                
                // Seasonal component
                let seasonalComponent = 0;
                if (config.seasonal) {
                    seasonalComponent = Math.sin((i % 252) / 252 * 2 * Math.PI) * 0.003;
                }
                
                // Crisis/volatility spikes
                let spikeComponent = 0;
                if (config.spikes && Math.random() < 0.001) {
                    spikeComponent = (Math.random() - 0.5) * config.volatility * 10;
                }
                
                const totalChange = randomWalk + longTermTrend + mediumTermTrend + shortTermTrend + 
                                  seasonalComponent + spikeComponent;
                
                const previousClose = currentValue;
                currentValue *= (1 + totalChange);
               
                // Apply constraints
                if (config.min !== undefined) currentValue = Math.max(currentValue, config.min);
                if (config.max !== undefined) currentValue = Math.min(currentValue, config.max);
                
                // Generate realistic OHLC data
                const dailyVolatility = config.volatility * (0.3 + Math.random() * 0.7);
                const range = currentValue * dailyVolatility;
                
                const gapSize = (Math.random() - 0.5) * config.volatility * 0.5;
                const open = previousClose * (1 + gapSize);
                
                const intrarayMove1 = (Math.random() - 0.5) * range * 2;
                const intrarayMove2 = (Math.random() - 0.5) * range * 2;
                
                const high = Math.max(open, currentValue) + Math.abs(intrarayMove1);
                const low = Math.min(open, currentValue) - Math.abs(intrarayMove2);
                
                const finalHigh = Math.max(high, open, currentValue);
                const finalLow = Math.min(low, open, currentValue);
                
                // Generate volume data for stocks
                let volume = 0;
                if (config.baseVolume > 0) {
                    const volumeVariation = (Math.random() - 0.5) * 0.6;
                    const volumeTrend = Math.abs(totalChange) * 3;
                    const volumeCluster = Math.abs(spikeComponent) > 0 ? 2.5 : 1;
                    volume = Math.round(config.baseVolume * (1 + volumeVariation + volumeTrend) * volumeCluster);
                    volume = Math.max(volume, config.baseVolume * 0.1);
                }
               
                data.push({
                    date: date.toISOString().split('T')[0],
                    value: currentValue,
                    close: currentValue,
                    open: open,
                    high: finalHigh,
                    low: finalLow,
                    volume: volume,
                    typical_price: (finalHigh + finalLow + currentValue) / 3,
                    weighted_price: (finalHigh + finalLow + currentValue + currentValue) / 4
                });
            }
           
            return data;
        }
        
        // Calculate additional changes for chart data
        function calculateChartChanges(data) {
            if (!data || data.length === 0) return data;
           
            return data.map((item, index, arr) => {
                const newItem = { ...item };
                const currentDate = new Date(item.date);
               
                // Helper function to find previous value by days
                const findPreviousValue = (daysAgo) => {
                    const targetDate = new Date(currentDate);
                    targetDate.setDate(currentDate.getDate() - daysAgo);
                   
                    for (let i = index - 1; i >= 0; i--) {
                        if (new Date(arr[i].date) <= targetDate) {
                            return arr[i].value;
                        }
                    }
                    return null;
                };
               
                // Calculate various period changes
                const prevDayValue = (index > 0) ? arr[index-1].value : null;
                const prevYearValue = findPreviousValue(365);
               
                // Daily changes
                if (prevDayValue !== null && prevDayValue !== 0) {
                    newItem.daily_pct_change = ((item.value - prevDayValue) / Math.abs(prevDayValue)) * 100;
                    newItem.daily_change_units = item.value - prevDayValue;
                } else {
                    newItem.daily_pct_change = 0;
                    newItem.daily_change_units = 0;
                }
               
                // Yearly changes (for YoY analysis)
                if (prevYearValue !== null && prevYearValue !== 0) {
                    newItem.yearly_pct_change = ((item.value - prevYearValue) / Math.abs(prevYearValue)) * 100;
                    newItem.yearly_change_units = item.value - prevYearValue;
                } else {
                    newItem.yearly_pct_change = 0;
                    newItem.yearly_change_units = 0;
                }
               
                // Trend detection
                if (index >= 5) {
                    const recentValues = arr.slice(index - 4, index + 1).map(d => d.value);
                    const trend = recentValues[recentValues.length - 1] - recentValues[0];
                    newItem.short_trend = trend;
                    
                    const avgValue = recentValues.reduce((sum, val) => sum + val, 0) / recentValues.length;
                    newItem.moving_avg_5 = avgValue;
                }
               
                if (index >= 20) {
                    const longerValues = arr.slice(index - 19, index + 1).map(d => d.value);
                    const avgLonger = longerValues.reduce((sum, val) => sum + val, 0) / longerValues.length;
                    newItem.moving_avg_20 = avgLonger;
                    newItem.trend_strength = ((item.value - avgLonger) / Math.abs(avgLonger)) * 100;
                }
               
                return newItem;
            });
        }
        
        // Technical indicators calculation
        function calculateTechnicalIndicators(data) {
            if (!data || data.length === 0) return data;
           
            const values = data.map(d => d.value);
           
            // RSI Calculation
            const calculateRSI = (prices, period = 14) => {
                const rsiValues = [];
                
                for (let i = 0; i < period; i++) {
                    rsiValues.push(null);
                }
                
                if (prices.length > period) {
                    let gains = [];
                    let losses = [];
                    
                    for (let i = 1; i <= period; i++) {
                        const change = prices[i] - prices[i - 1];
                        gains.push(change > 0 ? change : 0);
                        losses.push(change < 0 ? -change : 0);
                    }
                    
                    let avgGain = gains.reduce((sum, gain) => sum + gain, 0) / period;
                    let avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / period;
                    
                    let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    let rsi = 100 - (100 / (1 + rs));
                    rsiValues.push(rsi);
                    
                    for (let i = period + 1; i < prices.length; i++) {
                        const change = prices[i] - prices[i - 1];
                        const gain = change > 0 ? change : 0;
                        const loss = change < 0 ? -change : 0;
                        
                        avgGain = (avgGain * (period - 1) + gain) / period;
                        avgLoss = (avgLoss * (period - 1) + loss) / period;
                        
                        rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                        rsi = 100 - (100 / (1 + rs));
                        rsiValues.push(rsi);
                    }
                }
                
                return rsiValues;
            };
            
            // Calculate EMA
            const calculateEMA = (period, dataArray) => {
                if (dataArray.length < period) return dataArray.map(() => null);
               
                const k = 2 / (period + 1);
                const emaArray = [];
               
                let ema = dataArray.slice(0, period).reduce((sum, val) => sum + val, 0) / period;
                emaArray.push(...Array(period - 1).fill(null), ema);
               
                for (let i = period; i < dataArray.length; i++) {
                    ema = (dataArray[i] - ema) * k + ema;
                    emaArray.push(ema);
                }
               
                return emaArray;
            };
           
            // Calculate MACD
            const ema12Values = calculateEMA(12, values);
            const ema26Values = calculateEMA(26, values);
            const macdLine = ema12Values.map((e12, i) =>
                ema26Values[i] !== null && e12 !== null ? e12 - ema26Values[i] : null
            );
            const signalLineValues = calculateEMA(9, macdLine.map(v => v || 0));
            const macdHistogram = macdLine.map((macd, i) => 
                macd !== null && signalLineValues[i] !== null ? macd - signalLineValues[i] : null
            );
            
            const rsiValues = calculateRSI(values);
           
            return data.map((item, index) => {
                return {
                    ...item,
                    ema12: ema12Values[index],
                    ema26: ema26Values[index],
                    macd: macdLine[index],
                    macd_signal: signalLineValues[index],
                    macd_histogram: macdHistogram[index],
                    rsi: rsiValues[index]
                };
            });
        }
        
        // Retry function
        function retryLoadChart(chartId, symbol, name, source, provider) {
            console.log(`üîÑ Retrying chart load for ${symbol}...`);
            loadChartData(chartId, symbol, name, source, provider);
        }
        
        // Chart display functions
        function toggleChartDisplay(event, chartId, displayMode) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
           
            chart.previousDisplayMode = chart.displayMode;
            chart.displayMode = displayMode;
           
            const controlsDiv = event.target.parentElement;
            controlsDiv.querySelectorAll('.display-toggle').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
           
            try {
                updateChartRender(chartId);
            } catch (error) {
                console.error('Display mode change failed:', error);
                chart.displayMode = chart.previousDisplayMode || 'raw';
                showTemporaryMessage(`Failed to switch to ${displayMode} mode`, 'error');
            }
        }
        
        function changeChartType(chartId, chartType) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.chartType = chartType;
            
            const chartWindow = document.getElementById(chartId);
            chartWindow.querySelectorAll('.chart-type-btn').forEach(btn => btn.classList.remove('active'));
            chartWindow.querySelector(`[data-type="${chartType}"]`).classList.add('active');
            
            updateChartRender(chartId);
        }
        
        function toggleTheme(chartId) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.theme = chart.theme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', chart.theme);
            
            updateChartRender(chartId);
        }
        
        function toggleFullscreen(chartId) {
            const chart = charts[chartId];
            const chartWindow = document.getElementById(chartId);
            if (!chart || !chartWindow) return;
            
            chart.isFullscreen = !chart.isFullscreen;
            
            if (chart.isFullscreen) {
                chartWindow.classList.add('fullscreen');
                document.body.style.overflow = 'hidden';
            } else {
                chartWindow.classList.remove('fullscreen');
                document.body.style.overflow = 'auto';
            }
            
            setTimeout(() => {
                updateChartRender(chartId);
            }, 100);
        }
        
        function changeTimeframe(event, chartId, timeframe) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
            chart.timeframe = timeframe;
           
            const buttonContainer = document.getElementById(`${chartId}_timeframe_buttons`);
            if (buttonContainer) {
                buttonContainer.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
                if(event.target && event.target.tagName === 'BUTTON') {
                    event.target.classList.add('active');
                }
            }
            updateChartRender(chartId);
        }
        
        function updateChartSymbols(chartId) {
            const chart = charts[chartId];
            if (!chart) return;
            const symbolsDiv = document.getElementById(`${chartId}_symbols`);
            if (!symbolsDiv) return;
           
            symbolsDiv.innerHTML = chart.symbols.map((s, i) => `
                <div class="chart-symbol-tag">
                    <span class="symbol-color-dot" style="background-color: ${colorPalette[i % colorPalette.length]};"></span>
                    ${s.symbol}
                    <span class="remove-symbol" onclick="removeSymbolFromChart(event, '${chartId}', '${s.symbol}')">√ó</span>
                </div>`).join('');
        }
        
        function removeSymbolFromChart(event, chartId, symbolToRemove) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;

            chart.symbols = chart.symbols.filter(s => s.symbol !== symbolToRemove);
            delete chart.data[symbolToRemove];
           
            updateChartRender(chartId);
            updateChartSymbols(chartId);
           
            if (chart.symbols.length === 0) {
                document.getElementById(`${chartId}_canvas`).innerHTML = '<div class="chart-message">Search for a financial instrument to add to this chart</div>';
            }
        }
        
        function filterDataByTimeframe(data, timeframe) {
            if (!data || data.length === 0) return data;
           
            const now = new Date();
            let cutoffDate = new Date();
           
            switch(timeframe) {
                case '1D':
                    cutoffDate.setDate(now.getDate() - 1);
                    break;
                case '1W':
                    cutoffDate.setDate(now.getDate() - 7);
                    break;
                case '1M':
                    cutoffDate.setMonth(now.getMonth() - 1);
                    break;
                case '3M':
                    cutoffDate.setMonth(now.getMonth() - 3);
                    break;
                case '6M':
                    cutoffDate.setMonth(now.getMonth() - 6);
                    break;
                case '1Y':
                    cutoffDate.setFullYear(now.getFullYear() - 1);
                    break;
                case '2Y':
                    cutoffDate.setFullYear(now.getFullYear() - 2);
                    break;
                case '5Y':
                    cutoffDate.setFullYear(now.getFullYear() - 5);
                    break;
                case '10Y':
                    cutoffDate.setFullYear(now.getFullYear() - 10);
                    break;
                case 'MAX':
                    return data;
            }
           
            return data.filter(item => new Date(item.date) >= cutoffDate);
        }
        
        // Enhanced chart rendering
        function updateChartRender(chartId) {
            const chart = charts[chartId];
            const canvasElement = document.getElementById(`${chartId}_canvas`);
            
            if (!canvasElement || !chart) return;
           
            if (chart.symbols.length === 0) {
                canvasElement.innerHTML = '<div class="chart-message">Search for a financial instrument to add to this chart</div>';
                if (chart.chartInstance) {
                    try {
                        Plotly.purge(canvasElement);
                    } catch (purgeError) {
                        console.warn('‚ö†Ô∏è Plotly purge warning:', purgeError);
                    }
                }
                return;
            }
           
            try {
                const traces = [];
                const displayMode = chart.displayMode || 'raw';
                let yLabel = 'Value';
                
                chart.symbols.forEach((s, index) => {
                    const symbolData = chart.data[s.symbol];
                    if (!symbolData || symbolData.length === 0) return;
                    
                    const filteredData = filterDataByTimeframe(symbolData, chart.timeframe);
                    if (filteredData.length === 0) return;
                    
                    const lineColor = colorPalette[index % colorPalette.length];
                    let yData, hoverTemplate;
                    
                    // Process display modes
                    switch (displayMode) {
                        case 'raw':
                            yData = filteredData.map(d => d.value);
                            yLabel = 'Price/Value';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                            break;
                            
                        case 'pct_change':
                            const yoyData = filteredData.map((item, idx) => {
                                if (idx < 252) return null;
                                const yearAgo = filteredData[idx - 252]?.value;
                                if (!yearAgo || yearAgo === 0) return null;
                                return ((item.value - yearAgo) / yearAgo) * 100;
                            }).filter(v => v !== null);
                            
                            if (yoyData.length === 0) {
                                console.warn(`No YoY data available for ${s.symbol}`);
                                return;
                            }
                            yData = yoyData;
                            yLabel = 'Year-over-Year % Change';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>YoY Change: %{y:.2f}%<extra></extra>`;
                            break;
                            
                        case 'rsi':
                            yData = filteredData.map(d => d.rsi).filter(v => v !== null);
                            if (yData.length === 0) {
                                console.warn(`No RSI data available for ${s.symbol}`);
                                return;
                            }
                            yLabel = 'RSI (%)';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>RSI: %{y:.1f}%<extra></extra>`;
                            break;
                            
                        case 'macd':
                            yData = filteredData.map(d => d.macd).filter(v => v !== null);
                            if (yData.length === 0) {
                                console.warn(`No MACD data available for ${s.symbol}`);
                                return;
                            }
                            yLabel = 'MACD';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>MACD: %{y:.4f}<extra></extra>`;
                            break;
                            
                        default:
                            yData = filteredData.map(d => d.value);
                            yLabel = 'Value';
                            hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                    }
                    
                    if (yData.length === 0) return;
                    
                    // Create trace
                    const trace = {
                        x: filteredData.map(d => d.date),
                        y: yData,
                        type: 'scatter',
                        mode: 'lines',
                        name: s.symbol,
                        hovertemplate: hoverTemplate,
                        line: { color: lineColor, width: 2 }
                    };
                    
                    traces.push(trace);
                });
           
                if (traces.length === 0) {
                    canvasElement.innerHTML = '<div class="chart-message">No data to display for selected timeframe and mode</div>';
                    return;
                }
           
                const layout = {
                    title: {
                        text: `${displayMode.replace('_', ' ').toUpperCase()} VIEW - OpenBB Dual System`,
                        font: { color: chart.theme === 'light' ? '#333' : '#fff', size: 14 }
                    },
                    paper_bgcolor: chart.theme === 'light' ? '#ffffff' : '#0a0a0a',
                    plot_bgcolor: chart.theme === 'light' ? '#ffffff' : '#0a0a0a',
                    font: { color: chart.theme === 'light' ? '#333' : '#aaa', size: 12 },
                    margin: { t: 60, r: 80, b: 60, l: 80 },
                    xaxis: {
                        type: 'date',
                        gridcolor: chart.theme === 'light' ? '#f0f0f0' : '#22222250',
                        tickfont: { color: chart.theme === 'light' ? '#666' : '#888' }
                    },
                    yaxis: {
                        title: { text: yLabel },
                        gridcolor: chart.theme === 'light' ? '#f0f0f0' : '#22222250',
                        tickfont: { color: chart.theme === 'light' ? '#666' : '#888' }
                    },
                    hovermode: 'x unified',
                    showlegend: true,
                    height: chart.isFullscreen ? window.innerHeight - 120 : 500,
                    autosize: true
                };
           
                const config = {
                    responsive: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['select2d', 'lasso2d', 'toImage'],
                    displayModeBar: true
                };
           
                Plotly.react(canvasElement, traces, layout, config)
                    .then(gd => {
                        charts[chartId].chartInstance = gd;
                    })
                    .catch(err => {
                        console.error("‚ùå Plotly rendering error:", err);
                        canvasElement.innerHTML = `
                            <div class="chart-message" style="color: #ff4444;">
                                ‚ùå Chart rendering error<br>
                                <button onclick="updateChartRender('${chartId}')" style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">üîÑ Retry</button>
                            </div>
                        `;
                    });
                    
            } catch (error) {
                console.error("‚ùå Chart render failure:", error);
                canvasElement.innerHTML = `
                    <div class="chart-message" style="color: #ff4444;">
                        ‚ùå Chart system error<br>
                        <button onclick="updateChartRender('${chartId}')" style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">üîÑ Retry</button>
                    </div>
                `;
            }
        }
        
        // Utility functions
        function showTemporaryMessage(text, type = 'info') {
            const popup = document.createElement('div');
            popup.className = `message-popup ${type}`;
            popup.textContent = text;
            document.body.appendChild(popup);
           
            setTimeout(() => popup.remove(), 3000);
        }
        
        // Handle escape key for fullscreen
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                Object.keys(charts).forEach(chartId => {
                    if (charts[chartId].isFullscreen) {
                        toggleFullscreen(chartId);
                    }
                });
            }
        });
       
        // Hide search results when clicking outside
        document.addEventListener('click', function(event) {
            const searchBox = document.getElementById('searchBox');
            const searchResults = document.getElementById('searchResults');
           
            if (!searchBox.contains(event.target) && !searchResults.contains(event.target)) {
                searchResults.style.display = 'none';
            }
        });
       
        // Initialize on page load
        window.onload = init;
    </script>
</body>
</html>