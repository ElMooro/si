<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JustHodl Charts | Professional Trading Terminal</title>
<script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg0:#0c0e15;--bg1:#131722;--bg2:#1e222d;--bg3:#2a2e39;--bg4:#363a45;
  --brd:#2a2e39;--brd2:#434651;
  --t1:#d1d4dc;--t2:#787b86;--t3:#5d606b;--t4:#434651;
  --blue:#2962ff;--blue2:#1e53e5;--green:#26a69a;--red:#ef5350;
  --yellow:#f7a21b;--purple:#7b61ff;--cyan:#00bcd4;--orange:#ff6d00;
  --white:#fff;
}
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;overflow:hidden}
body{background:var(--bg1);color:var(--t1);font-family:'Inter',sans-serif;font-size:13px}
.mono{font-family:'JetBrains Mono',monospace}
::selection{background:var(--blue);color:var(--white)}
::-webkit-scrollbar{width:5px;height:5px}
::-webkit-scrollbar-track{background:var(--bg1)}
::-webkit-scrollbar-thumb{background:var(--bg4);border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:var(--t3)}
input,select,textarea{font-family:'Inter',sans-serif}
button{cursor:pointer;font-family:'Inter',sans-serif}

/* ========== APP LAYOUT ========== */
.app{display:flex;flex-direction:column;height:100vh;width:100vw}

/* TOP BAR */
.topbar{
  display:flex;align-items:center;height:38px;min-height:38px;
  background:var(--bg2);border-bottom:1px solid var(--brd);
  padding:0 8px;gap:2px;z-index:100;
}
.topbar .logo{
  font-weight:700;font-size:15px;padding:0 12px 0 4px;
  background:linear-gradient(135deg,#2962ff,#00bcd4);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  letter-spacing:-.5px;cursor:pointer;white-space:nowrap;
}
.topbar .sep{width:1px;height:20px;background:var(--brd);margin:0 4px}
.topbar-right{margin-left:auto;display:flex;align-items:center;gap:2px}
.icon-btn{
  width:30px;height:30px;display:flex;align-items:center;justify-content:center;
  background:transparent;border:none;color:var(--t2);border-radius:4px;font-size:14px;
}
.icon-btn:hover{background:var(--bg3);color:var(--t1)}
.icon-btn.active{color:var(--blue);background:rgba(41,98,255,.15)}
.icon-btn svg{width:16px;height:16px;fill:currentColor}

/* Symbol Button */
.sym-btn{
  display:flex;align-items:center;gap:6px;padding:4px 10px;
  background:var(--bg3);border:1px solid var(--brd);border-radius:4px;
  color:var(--t1);cursor:pointer;font-size:14px;font-weight:600;
  font-family:'JetBrains Mono',monospace;
}
.sym-btn:hover{background:var(--bg4)}
.sym-btn .chg{font-size:11px;font-weight:500;margin-left:4px}
.sym-btn .chg.up{color:var(--green)}.sym-btn .chg.dn{color:var(--red)}
.sym-btn .price{font-size:12px;color:var(--t2);margin-left:8px}

/* Search Dropdown */
.search-drop{
  position:absolute;top:100%;left:0;width:480px;max-height:500px;
  background:var(--bg2);border:1px solid var(--brd);border-radius:8px;
  box-shadow:0 12px 48px rgba(0,0,0,.6);z-index:500;display:none;
  overflow:hidden;margin-top:4px;
}
.search-drop.show{display:block}
.search-drop .search-head{display:flex;align-items:center;border-bottom:1px solid var(--brd)}
.search-drop input{
  flex:1;padding:12px 14px;background:transparent;border:none;
  color:var(--t1);font-size:14px;outline:none;
}
.search-drop input::placeholder{color:var(--t3)}
.search-tabs{display:flex;border-bottom:1px solid var(--brd);padding:0 8px}
.search-tab{
  padding:6px 12px;font-size:11px;color:var(--t2);cursor:pointer;
  border-bottom:2px solid transparent;text-transform:uppercase;letter-spacing:.5px;
}
.search-tab:hover{color:var(--t1)}.search-tab.active{color:var(--blue);border-color:var(--blue)}
.search-results{max-height:380px;overflow-y:auto}
.search-item{
  display:flex;align-items:center;padding:8px 14px;cursor:pointer;
  border-bottom:1px solid rgba(42,46,57,.5);gap:10px;
}
.search-item:hover,.search-item.active{background:var(--bg3)}
.search-item .si-icon{width:28px;height:28px;border-radius:6px;background:var(--bg4);display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700;color:var(--t2)}
.search-item .si-info{flex:1;min-width:0}
.search-item .si-ticker{font-weight:600;font-family:'JetBrains Mono',monospace;font-size:13px}
.search-item .si-name{color:var(--t2);font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.search-item .si-exchange{font-size:10px;padding:2px 6px;border-radius:3px;background:var(--bg4);color:var(--t3)}
.search-item .si-type{font-size:10px;color:var(--t3);text-transform:uppercase}

/* Timeframe Buttons */
.tf-group{display:flex;align-items:center;gap:1px}
.tf-btn{
  padding:4px 8px;background:transparent;border:none;color:var(--t2);
  cursor:pointer;font-size:12px;border-radius:3px;
}
.tf-btn:hover{color:var(--t1);background:var(--bg3)}
.tf-btn.active{color:var(--blue);background:rgba(41,98,255,.15)}

/* Chart Type Buttons */
.ct-btn{padding:4px 7px;background:transparent;border:none;color:var(--t2);cursor:pointer;font-size:14px;border-radius:3px}
.ct-btn:hover{color:var(--t1);background:var(--bg3)}.ct-btn.active{color:var(--blue);background:rgba(41,98,255,.15)}

/* Indicator Button */
.ind-btn{
  padding:4px 10px;background:transparent;border:none;color:var(--t2);
  cursor:pointer;font-size:12px;border-radius:3px;display:flex;align-items:center;gap:4px;
}
.ind-btn:hover{color:var(--t1);background:var(--bg3)}

/* Compare Button */
.cmp-btn{padding:4px 10px;background:transparent;border:none;color:var(--t2);cursor:pointer;font-size:12px;border-radius:3px}
.cmp-btn:hover{color:var(--t1);background:var(--bg3)}

/* ========== MAIN AREA ========== */
.main-area{display:flex;flex:1;overflow:hidden}

/* LEFT TOOLBAR (Drawing Tools) */
.left-toolbar{
  width:44px;min-width:44px;background:var(--bg2);
  border-right:1px solid var(--brd);display:flex;flex-direction:column;
  align-items:center;padding:6px 0;gap:2px;overflow-y:auto;
}
.tool-btn{
  width:36px;height:32px;display:flex;align-items:center;justify-content:center;
  background:transparent;border:none;color:var(--t2);border-radius:4px;
  cursor:pointer;font-size:14px;position:relative;
}
.tool-btn:hover{background:var(--bg3);color:var(--t1)}
.tool-btn.active{color:var(--blue);background:rgba(41,98,255,.15)}
.tool-btn .badge{position:absolute;top:2px;right:2px;width:5px;height:5px;border-radius:50%;background:var(--blue)}
.tool-divider{width:24px;height:1px;background:var(--brd);margin:4px 0}
.tool-btn[title]:hover::after{
  content:attr(title);position:absolute;left:110%;top:50%;transform:translateY(-50%);
  background:var(--bg0);color:var(--t1);padding:4px 8px;border-radius:4px;
  font-size:11px;white-space:nowrap;z-index:100;border:1px solid var(--brd);
  pointer-events:none;
}

/* CENTER (Charts) */
.chart-area{flex:1;display:flex;flex-direction:column;position:relative;overflow:hidden}
.chart-header{
  display:flex;align-items:center;padding:4px 10px;gap:8px;
  background:var(--bg1);border-bottom:1px solid var(--brd);min-height:28px;
}
.chart-header .sym-label{font-weight:700;font-family:'JetBrains Mono',monospace;font-size:15px}
.chart-header .price-info{display:flex;gap:12px;font-size:12px;font-family:'JetBrains Mono',monospace}
.chart-header .price-info .lbl{color:var(--t3);margin-right:3px}
.chart-header .price-info .val{color:var(--t1)}
.chart-header .price-info .val.up{color:var(--green)}.chart-header .price-info .val.dn{color:var(--red)}
.chart-container{flex:1;position:relative;background:var(--bg1)}
.chart-container canvas{position:absolute;top:0;left:0}

/* Watermark */
.chart-watermark{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  font-size:64px;font-weight:800;font-family:'JetBrains Mono',monospace;
  color:rgba(42,46,57,.25);pointer-events:none;z-index:1;letter-spacing:-3px;
}

/* ========== RIGHT PANEL ========== */
.right-panel{
  width:0;min-width:0;background:var(--bg2);border-left:1px solid var(--brd);
  display:flex;flex-direction:column;transition:width .2s,min-width .2s;overflow:hidden;
}
.right-panel.open{width:320px;min-width:320px}
.right-panel.wide{width:420px;min-width:420px}
.panel-tabs{
  display:flex;border-bottom:1px solid var(--brd);min-height:32px;
  background:var(--bg2);overflow-x:auto;
}
.panel-tab{
  padding:8px 14px;font-size:11px;color:var(--t2);cursor:pointer;
  border-bottom:2px solid transparent;white-space:nowrap;
  text-transform:uppercase;letter-spacing:.5px;
}
.panel-tab:hover{color:var(--t1)}.panel-tab.active{color:var(--blue);border-color:var(--blue)}
.panel-content{flex:1;overflow-y:auto;padding:0}
.panel-section{padding:12px}
.panel-section-title{
  font-size:11px;color:var(--t3);text-transform:uppercase;letter-spacing:1px;
  margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;
}

/* Watchlist Styles */
.wl-header{
  display:flex;align-items:center;justify-content:space-between;
  padding:8px 12px;border-bottom:1px solid var(--brd);
}
.wl-select{
  background:var(--bg3);border:1px solid var(--brd);color:var(--t1);
  padding:4px 8px;border-radius:4px;font-size:12px;outline:none;
}
.wl-actions{display:flex;gap:4px}
.wl-actions button{
  width:24px;height:24px;display:flex;align-items:center;justify-content:center;
  background:var(--bg3);border:1px solid var(--brd);color:var(--t2);
  border-radius:4px;font-size:12px;cursor:pointer;
}
.wl-actions button:hover{color:var(--t1);background:var(--bg4)}
.wl-table{width:100%}
.wl-row{
  display:grid;grid-template-columns:80px 1fr 70px 70px;align-items:center;
  padding:6px 12px;cursor:pointer;border-bottom:1px solid rgba(42,46,57,.3);font-size:12px;
}
.wl-row:hover{background:var(--bg3)}
.wl-row.header{color:var(--t3);font-size:10px;text-transform:uppercase;letter-spacing:.5px;cursor:default}
.wl-row.header:hover{background:transparent}
.wl-row .sym{font-weight:600;font-family:'JetBrains Mono',monospace}
.wl-row .name{color:var(--t2);font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.wl-row .prc{text-align:right;font-family:'JetBrains Mono',monospace}
.wl-row .chg{text-align:right;font-family:'JetBrains Mono',monospace;font-size:11px}
.wl-row .chg.up{color:var(--green)}.wl-row .chg.dn{color:var(--red)}
.wl-row .remove-sym{opacity:0;color:var(--t3);cursor:pointer;font-size:14px;margin-left:4px}
.wl-row:hover .remove-sym{opacity:1}
.wl-add{padding:8px 12px}
.wl-add input{
  width:100%;padding:6px 10px;background:var(--bg1);border:1px solid var(--brd);
  border-radius:4px;color:var(--t1);font-size:12px;outline:none;
}
.wl-add input:focus{border-color:var(--blue)}
.wl-add input::placeholder{color:var(--t3)}

/* Alerts Panel */
.alert-item{
  display:flex;align-items:center;justify-content:space-between;
  padding:8px 12px;border-bottom:1px solid rgba(42,46,57,.3);
}
.alert-item .alert-info{flex:1}
.alert-item .alert-sym{font-weight:600;font-family:'JetBrains Mono',monospace;font-size:12px}
.alert-item .alert-cond{color:var(--t2);font-size:11px}
.alert-item .alert-del{color:var(--t3);cursor:pointer;font-size:14px}
.alert-item .alert-del:hover{color:var(--red)}
.alert-form{padding:12px;display:flex;flex-direction:column;gap:8px}
.alert-form label{font-size:11px;color:var(--t2)}
.alert-form input,.alert-form select{
  padding:6px 10px;background:var(--bg1);border:1px solid var(--brd);
  border-radius:4px;color:var(--t1);font-size:12px;outline:none;
}
.alert-form input:focus,.alert-form select:focus{border-color:var(--blue)}
.alert-form .btn-add-alert{
  padding:8px;background:var(--blue);color:var(--white);border:none;
  border-radius:4px;font-size:12px;font-weight:600;cursor:pointer;
}
.alert-form .btn-add-alert:hover{background:var(--blue2)}

/* News Panel */
.news-item{padding:10px 12px;border-bottom:1px solid rgba(42,46,57,.3);cursor:pointer}
.news-item:hover{background:var(--bg3)}
.news-item .news-time{font-size:10px;color:var(--t3);margin-bottom:2px}
.news-item .news-title{font-size:12px;color:var(--t1);line-height:1.4}
.news-item .news-source{font-size:10px;color:var(--blue);margin-top:3px}

/* Details Panel */
.detail-grid{display:grid;grid-template-columns:1fr 1fr;gap:1px}
.detail-cell{
  padding:8px 12px;background:var(--bg1);
}
.detail-cell .dl{font-size:10px;color:var(--t3);text-transform:uppercase;letter-spacing:.5px;margin-bottom:2px}
.detail-cell .dv{font-size:13px;font-family:'JetBrains Mono',monospace}

/* Screener Panel */
.screener-tabs{display:flex;gap:4px;padding:8px 12px;border-bottom:1px solid var(--brd)}
.screener-tab{
  padding:4px 10px;background:var(--bg3);border:none;border-radius:4px;
  color:var(--t2);cursor:pointer;font-size:11px;
}
.screener-tab:hover{color:var(--t1)}.screener-tab.active{color:var(--white);background:var(--blue)}
.screener-row{
  display:grid;grid-template-columns:70px 1fr 70px 60px;
  padding:6px 12px;border-bottom:1px solid rgba(42,46,57,.3);
  font-size:12px;cursor:pointer;align-items:center;
}
.screener-row:hover{background:var(--bg3)}
.screener-row .sr-sym{font-weight:600;font-family:'JetBrains Mono',monospace}
.screener-row .sr-name{color:var(--t2);font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.screener-row .sr-prc{text-align:right;font-family:'JetBrains Mono',monospace}
.screener-row .sr-chg{text-align:right;font-family:'JetBrains Mono',monospace;font-weight:500;font-size:11px;padding:2px 6px;border-radius:3px}
.screener-row .sr-chg.up{color:var(--green);background:rgba(38,166,154,.1)}
.screener-row .sr-chg.dn{color:var(--red);background:rgba(239,83,80,.1)}

/* Technical Analysis Panel */
.ta-gauge{text-align:center;padding:20px}
.ta-meter{width:200px;height:100px;margin:0 auto;position:relative}
.ta-label{font-size:24px;font-weight:700;margin-top:10px}
.ta-label.buy{color:var(--green)}.ta-label.sell{color:var(--red)}.ta-label.neutral{color:var(--yellow)}
.ta-summary{display:grid;grid-template-columns:1fr 1fr 1fr;gap:1px;margin-top:12px}
.ta-box{background:var(--bg1);padding:10px;text-align:center}
.ta-box .ta-count{font-size:20px;font-weight:700;font-family:'JetBrains Mono',monospace}
.ta-box .ta-type{font-size:10px;color:var(--t3);text-transform:uppercase;margin-top:2px}
.ta-box.buy .ta-count{color:var(--green)}.ta-box.sell .ta-count{color:var(--red)}.ta-box.neutral .ta-count{color:var(--yellow)}
.ta-table{width:100%}
.ta-row{display:grid;grid-template-columns:1fr 80px 80px;padding:6px 12px;border-bottom:1px solid rgba(42,46,57,.3);font-size:12px}
.ta-row.header{color:var(--t3);font-size:10px;text-transform:uppercase}
.ta-row .signal{text-align:center;font-weight:600;font-size:11px}
.ta-row .signal.buy{color:var(--green)}.ta-row .signal.sell{color:var(--red)}.ta-row .signal.neutral{color:var(--yellow)}

/* Hotkeys Panel */
.hk-row{display:flex;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(42,46,57,.3)}
.hk-row .hk-key{
  display:inline-flex;align-items:center;gap:4px;
}
.hk-row .hk-key kbd{
  background:var(--bg3);border:1px solid var(--brd);padding:2px 6px;
  border-radius:3px;font-family:'JetBrains Mono',monospace;font-size:11px;
  color:var(--t1);min-width:20px;text-align:center;
}
.hk-row .hk-desc{color:var(--t2);font-size:12px}

/* Notes Panel */
.notes-area{padding:12px}
.notes-area textarea{
  width:100%;min-height:200px;background:var(--bg1);border:1px solid var(--brd);
  border-radius:6px;color:var(--t1);padding:10px;font-size:12px;
  resize:vertical;outline:none;font-family:'Inter',sans-serif;line-height:1.6;
}
.notes-area textarea:focus{border-color:var(--blue)}
.notes-saved{font-size:11px;color:var(--green);padding:4px 0;display:none}

/* ========== BOTTOM BAR ========== */
.bottom-bar{
  display:flex;align-items:center;height:26px;min-height:26px;
  background:var(--bg2);border-top:1px solid var(--brd);
  padding:0 10px;font-size:11px;color:var(--t2);gap:16px;
}
.bottom-bar .market-status{display:flex;align-items:center;gap:4px}
.bottom-bar .market-status .dot{width:6px;height:6px;border-radius:50%}
.bottom-bar .market-status .dot.open{background:var(--green);box-shadow:0 0 6px var(--green)}
.bottom-bar .market-status .dot.closed{background:var(--red)}
.bottom-bar .market-status .dot.pre{background:var(--yellow)}
.bottom-bar .tz-select{background:transparent;border:none;color:var(--t2);font-size:11px;cursor:pointer;outline:none}
.bottom-bar .spacer{flex:1}
.bottom-bar .perf{font-family:'JetBrains Mono',monospace;font-size:10px}
.bottom-bar .perf.up{color:var(--green)}.bottom-bar .perf.dn{color:var(--red)}

/* ========== MODALS ========== */
.modal-overlay{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,.6);z-index:1000;display:none;
  align-items:center;justify-content:center;backdrop-filter:blur(2px);
}
.modal-overlay.show{display:flex}
.modal{
  background:var(--bg2);border:1px solid var(--brd);border-radius:10px;
  width:520px;max-height:80vh;overflow:hidden;box-shadow:0 16px 64px rgba(0,0,0,.5);
}
.modal-header{
  display:flex;align-items:center;justify-content:space-between;
  padding:14px 18px;border-bottom:1px solid var(--brd);
}
.modal-header h3{font-size:15px;font-weight:600}
.modal-close{background:none;border:none;color:var(--t2);font-size:18px;cursor:pointer}
.modal-close:hover{color:var(--t1)}
.modal-body{padding:16px 18px;overflow-y:auto;max-height:60vh}
.modal-footer{padding:12px 18px;border-top:1px solid var(--brd);display:flex;justify-content:flex-end;gap:8px}
.btn{
  padding:8px 16px;border:none;border-radius:4px;font-size:12px;
  font-weight:600;cursor:pointer;
}
.btn-primary{background:var(--blue);color:var(--white)}.btn-primary:hover{background:var(--blue2)}
.btn-secondary{background:var(--bg3);color:var(--t1);border:1px solid var(--brd)}.btn-secondary:hover{background:var(--bg4)}
.btn-danger{background:var(--red);color:var(--white)}.btn-danger:hover{background:#d32f2f}
.btn-sm{padding:4px 10px;font-size:11px}

/* Indicator Modal */
.ind-modal{width:600px}
.ind-search{
  width:100%;padding:10px 14px;background:var(--bg1);border:1px solid var(--brd);
  border-radius:6px;color:var(--t1);font-size:13px;outline:none;margin-bottom:12px;
}
.ind-search:focus{border-color:var(--blue)}
.ind-cats{display:flex;gap:4px;margin-bottom:12px;flex-wrap:wrap}
.ind-cat{
  padding:4px 10px;background:var(--bg3);border:none;border-radius:4px;
  color:var(--t2);cursor:pointer;font-size:11px;
}
.ind-cat:hover{color:var(--t1)}.ind-cat.active{color:var(--white);background:var(--blue)}
.ind-list{display:flex;flex-direction:column;gap:2px;max-height:300px;overflow-y:auto}
.ind-item{
  display:flex;align-items:center;justify-content:space-between;
  padding:8px 12px;border-radius:4px;cursor:pointer;
}
.ind-item:hover{background:var(--bg3)}
.ind-item.active{background:rgba(41,98,255,.1);border:1px solid rgba(41,98,255,.3)}
.ind-item .ind-name{font-size:13px}
.ind-item .ind-desc{font-size:11px;color:var(--t3)}
.ind-item .ind-check{color:var(--blue);font-weight:700;display:none}
.ind-item.active .ind-check{display:block}

/* Template Modal */
.tmpl-item{
  display:flex;align-items:center;justify-content:space-between;
  padding:10px 12px;border-bottom:1px solid rgba(42,46,57,.3);cursor:pointer;
}
.tmpl-item:hover{background:var(--bg3)}
.tmpl-item .tmpl-name{font-weight:500;font-size:13px}
.tmpl-item .tmpl-info{font-size:11px;color:var(--t3)}
.tmpl-item .tmpl-del{color:var(--t3);cursor:pointer}.tmpl-item .tmpl-del:hover{color:var(--red)}

/* Context Menu */
.ctx-menu{
  position:fixed;background:var(--bg2);border:1px solid var(--brd);
  border-radius:6px;padding:4px 0;min-width:180px;z-index:600;
  box-shadow:0 8px 32px rgba(0,0,0,.5);display:none;
}
.ctx-menu.show{display:block}
.ctx-item{
  padding:7px 14px;font-size:12px;color:var(--t1);cursor:pointer;
  display:flex;align-items:center;gap:8px;
}
.ctx-item:hover{background:var(--bg3)}
.ctx-item.danger{color:var(--red)}
.ctx-divider{height:1px;background:var(--brd);margin:4px 0}
.ctx-item .ctx-key{margin-left:auto;font-size:10px;color:var(--t3);font-family:'JetBrains Mono',monospace}

/* Layout Grid */
.chart-grid{display:grid;flex:1;gap:1px;background:var(--brd)}
.chart-grid.layout-1{grid-template-columns:1fr;grid-template-rows:1fr}
.chart-grid.layout-2h{grid-template-columns:1fr 1fr;grid-template-rows:1fr}
.chart-grid.layout-2v{grid-template-columns:1fr;grid-template-rows:1fr 1fr}
.chart-grid.layout-4{grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr}
.chart-grid.layout-3{grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr}
.chart-grid.layout-3 .chart-cell:first-child{grid-column:1/3}
.chart-grid.layout-6{grid-template-columns:1fr 1fr 1fr;grid-template-rows:1fr 1fr}
.chart-cell{background:var(--bg1);display:flex;flex-direction:column;position:relative;overflow:hidden}
.chart-cell.active{outline:1px solid var(--blue)}
.chart-cell .cell-header{
  display:flex;align-items:center;padding:2px 8px;gap:6px;
  background:var(--bg1);font-size:11px;min-height:22px;
}
.chart-cell .cell-sym{font-weight:600;font-family:'JetBrains Mono',monospace;cursor:pointer}
.chart-cell .cell-sym:hover{color:var(--blue)}
.chart-cell .cell-price{color:var(--t2);font-family:'JetBrains Mono',monospace;font-size:11px}
.chart-cell .cell-chart{flex:1;position:relative}

/* Toast Notifications */
.toast-container{position:fixed;top:50px;right:20px;z-index:2000;display:flex;flex-direction:column;gap:8px}
.toast{
  background:var(--bg2);border:1px solid var(--brd);border-radius:6px;
  padding:10px 16px;min-width:250px;box-shadow:0 8px 32px rgba(0,0,0,.4);
  display:flex;align-items:center;gap:10px;animation:slideIn .3s;
}
.toast.success{border-left:3px solid var(--green)}.toast.error{border-left:3px solid var(--red)}
.toast.info{border-left:3px solid var(--blue)}.toast.warning{border-left:3px solid var(--yellow)}
.toast .toast-msg{font-size:12px;flex:1}
.toast .toast-close{color:var(--t3);cursor:pointer;font-size:14px}
@keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}

/* Compare Overlay */
.compare-legend{
  position:absolute;top:8px;left:8px;z-index:10;display:flex;gap:12px;
  background:rgba(19,23,34,.8);padding:4px 10px;border-radius:4px;
}
.compare-item{display:flex;align-items:center;gap:4px;font-size:11px;font-family:'JetBrains Mono',monospace}
.compare-item .dot{width:8px;height:8px;border-radius:50%}
.compare-item .compare-remove{cursor:pointer;color:var(--t3);font-size:12px}
.compare-item .compare-remove:hover{color:var(--red)}

/* Replay Controls */
.replay-bar{
  display:none;align-items:center;gap:8px;padding:4px 10px;
  background:var(--bg2);border-bottom:1px solid var(--brd);
}
.replay-bar.show{display:flex}
.replay-bar button{
  padding:4px 10px;background:var(--bg3);border:1px solid var(--brd);
  border-radius:4px;color:var(--t1);font-size:11px;cursor:pointer;
}
.replay-bar button:hover{background:var(--bg4)}
.replay-bar .replay-date{font-size:12px;font-family:'JetBrains Mono',monospace;color:var(--t2)}
.replay-bar .replay-speed{font-size:11px;color:var(--blue)}

/* Loading Spinner */
.loading-overlay{
  position:absolute;top:0;left:0;right:0;bottom:0;
  display:flex;align-items:center;justify-content:center;
  background:rgba(19,23,34,.7);z-index:10;
}
.spinner{
  width:32px;height:32px;border:3px solid var(--bg4);border-top-color:var(--blue);
  border-radius:50%;animation:spin .8s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}

/* Fullscreen */
.app.fullscreen .topbar,.app.fullscreen .bottom-bar,.app.fullscreen .left-toolbar{display:none}

/* Print */
@media print{.topbar,.bottom-bar,.left-toolbar,.right-panel{display:none!important}.chart-area{height:100vh}}
</style>
</head>
<body>
<div class="app" id="app">
  <!-- TOP BAR -->
  <div class="topbar">
    <span class="logo" onclick="location.href='index.html'">JustHodl</span>
    <div class="sep"></div>

    <!-- Symbol Search -->
    <div class="sym-search" id="symSearch">
      <button class="sym-btn" id="symBtn" onclick="toggleSearch()">
        <span id="symTicker">AAPL</span>
        <span class="price" id="symPrice"></span>
        <span class="chg" id="symChg"></span>
      </button>
      <div class="search-drop" id="searchDrop">
        <div class="search-head">
          <input type="text" id="searchInput" placeholder="Search symbol, name, or ISIN..." autocomplete="off">
        </div>
        <div class="search-tabs">
          <div class="search-tab active" data-filter="all">All</div>
          <div class="search-tab" data-filter="stocks">Stocks</div>
          <div class="search-tab" data-filter="crypto">Crypto</div>
          <div class="search-tab" data-filter="forex">Forex</div>
          <div class="search-tab" data-filter="etf">ETFs</div>
          <div class="search-tab" data-filter="indices">Indices</div>
        </div>
        <div class="search-results" id="searchResults"></div>
      </div>
    </div>
    <div class="sep"></div>

    <!-- Timeframes -->
    <div class="tf-group" id="tfGroup">
      <button class="tf-btn" data-m="1" data-t="minute">1m</button>
      <button class="tf-btn" data-m="2" data-t="minute">2m</button>
      <button class="tf-btn" data-m="3" data-t="minute">3m</button>
      <button class="tf-btn" data-m="5" data-t="minute">5m</button>
      <button class="tf-btn" data-m="10" data-t="minute">10m</button>
      <button class="tf-btn" data-m="15" data-t="minute">15m</button>
      <button class="tf-btn" data-m="30" data-t="minute">30m</button>
      <button class="tf-btn" data-m="1" data-t="hour">1H</button>
      <button class="tf-btn" data-m="2" data-t="hour">2H</button>
      <button class="tf-btn" data-m="4" data-t="hour">4H</button>
      <button class="tf-btn active" data-m="1" data-t="day">1D</button>
      <button class="tf-btn" data-m="3" data-t="day">3D</button>
      <button class="tf-btn" data-m="1" data-t="week">1W</button>
      <button class="tf-btn" data-m="1" data-t="month">1M</button>
      <button class="tf-btn" data-m="3" data-t="month">3M</button>
      <button class="tf-btn" data-m="1" data-t="quarter">Q</button>
      <button class="tf-btn" data-m="1" data-t="year">1Y</button>
    </div>
    <!-- Date Range -->
    <div class="sep"></div>
    <div style="display:flex;align-items:center;gap:4px">
      <select id="histRange" onchange="setHistoryRange(this.value)" style="background:var(--bg3);border:1px solid var(--brd);color:var(--t2);padding:3px 6px;border-radius:3px;font-size:11px;cursor:pointer">
        <option value="auto">Auto Range</option>
        <option value="1d">1 Day</option>
        <option value="5d">5 Days</option>
        <option value="1m">1 Month</option>
        <option value="3m">3 Months</option>
        <option value="6m">6 Months</option>
        <option value="ytd">YTD</option>
        <option value="1y">1 Year</option>
        <option value="2y">2 Years</option>
        <option value="5y" selected>5 Years</option>
        <option value="10y">10 Years</option>
        <option value="20y">20 Years</option>
        <option value="max">Max (All History)</option>
        <option value="custom">Custom Range...</option>
      </select>
    </div>
    <div class="sep"></div>

    <!-- Chart Types -->
    <div class="ct-group" id="ctGroup">
      <button class="ct-btn active" data-type="candles" title="Candlestick">üïØ</button>
      <button class="ct-btn" data-type="bars" title="Bars">üìä</button>
      <button class="ct-btn" data-type="line" title="Line">üìà</button>
      <button class="ct-btn" data-type="area" title="Area">üèî</button>
      <button class="ct-btn" data-type="heikin" title="Heikin-Ashi">‚õ©</button>
      <button class="ct-btn" data-type="baseline" title="Baseline">‚öñ</button>
      <button class="ct-btn" data-type="hollow" title="Hollow Candles">üî≤</button>
      <button class="ct-btn" data-type="renko" title="Renko">üß±</button>
      <button class="ct-btn" data-type="linebreak" title="Line Break">üìâ</button>
      <button class="ct-btn" data-type="columns" title="Columns">‚ñê</button>
      <button class="ct-btn" data-type="stepline" title="Step Line">‚åê</button>
      <button class="ct-btn" data-type="hlcarea" title="HLC Area">‚óá</button>
      <button class="ct-btn" data-type="renko" title="Renko">üß±</button>
      <button class="ct-btn" data-type="range" title="Range">üìè</button>
    </div>
    <div class="sep"></div>

    <!-- Indicators -->
    <button class="ind-btn" onclick="openIndicatorModal()">
      <span>∆íx</span> Indicators
    </button>
    <div class="sep"></div>

    <!-- Compare -->
    <button class="cmp-btn" onclick="openCompareModal()">‚äï Compare</button>
    <button class="cmp-btn" onclick="openSpreadDialog()">√∑ Spread/Ratio</button>
    <div class="sep"></div>

    <!-- Replay -->
    <button class="icon-btn" id="replayBtn" onclick="toggleReplay()" title="Replay">‚è™</button>

    <!-- Templates -->
    <button class="icon-btn" id="tmplBtn" onclick="openTemplateModal()" title="Chart Templates">üìã</button>

    <!-- Alerts -->
    <button class="icon-btn" id="alertBtnTop" onclick="openAlertModal()" title="Alerts">üîî</button>

    <!-- Screenshot -->
    <button class="icon-btn" onclick="takeScreenshot()" title="Screenshot">üì∑</button>

    <!-- Export -->
    <button class="icon-btn" onclick="exportCSV()" title="Export CSV">üíæ</button>

    <div class="topbar-right">
      <!-- Layout Buttons -->
      <button class="icon-btn" onclick="setLayout(1)" title="Single Chart">‚óª</button>
      <button class="icon-btn" onclick="setLayout('2h')" title="Split Horizontal">‚ó´</button>
      <button class="icon-btn" onclick="setLayout('2v')" title="Split Vertical">‚¨í</button>
      <button class="icon-btn" onclick="setLayout(4)" title="Quad">‚äû</button>
      <button class="icon-btn" onclick="setLayout(6)" title="Six Charts">‚äü</button>
      <div class="sep"></div>
      <!-- Panel Toggles -->
      <button class="icon-btn" id="panelWatchlist" onclick="togglePanel('watchlist')" title="Watchlist">‚ò∞</button>
      <button class="icon-btn" id="panelScreener" onclick="togglePanel('screener')" title="Screener">üîç</button>
      <button class="icon-btn" id="panelNews" onclick="togglePanel('news')" title="News">üì∞</button>
      <button class="icon-btn" id="panelDetails" onclick="togglePanel('details')" title="Details">‚Ñπ</button>
      <button class="icon-btn" id="panelFinancials" onclick="togglePanel('financials')" title="Financials">üí∞</button>
      <button class="icon-btn" id="panelDividends" onclick="togglePanel('dividends')" title="Dividends & Splits">üíµ</button>
      <button class="icon-btn" id="panelTA" onclick="togglePanel('ta')" title="Tech Analysis">üìê</button>
      <button class="icon-btn" id="panelHeatmap" onclick="togglePanel('heatmap')" title="Sector Heatmap">üó∫</button>
      <button class="icon-btn" id="panelNotes" onclick="togglePanel('notes')" title="Notes">üìù</button>
      <button class="icon-btn" id="panelHotkeys" onclick="togglePanel('hotkeys')" title="Hotkeys">‚å®</button>
      <div class="sep"></div>
      <button class="icon-btn" onclick="toggleFullscreen()" title="Fullscreen">‚õ∂</button>
      <button class="icon-btn" onclick="openSettings()" title="Settings">‚öô</button>
    </div>
  </div>

  <!-- REPLAY BAR -->
  <div class="replay-bar" id="replayBar">
    <button onclick="replayStep(-10)">‚èÆ</button>
    <button onclick="replayStep(-1)">‚óÄ</button>
    <button id="replayPlayBtn" onclick="replayToggle()">‚ñ∂ Play</button>
    <button onclick="replayStep(1)">‚ñ∂</button>
    <button onclick="replayStep(10)">‚è≠</button>
    <span class="replay-date" id="replayDate">--</span>
    <span class="replay-speed" id="replaySpeed">1x</span>
    <button onclick="replayChangeSpeed()">Speed</button>
    <div style="flex:1"></div>
    <button onclick="toggleReplay()">‚úï Exit Replay</button>
  </div>

  <div class="main-area">
    <!-- LEFT TOOLBAR -->
    <div class="left-toolbar" id="leftToolbar">
      <button class="tool-btn" data-tool="crosshair" title="Crosshair" onclick="setTool('crosshair')">+</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" data-tool="trendline" title="Trend Line" onclick="setTool('trendline')">‚ï≤</button>
      <button class="tool-btn" data-tool="ray" title="Ray" onclick="setTool('ray')">‚ï±</button>
      <button class="tool-btn" data-tool="hline" title="Horizontal Line" onclick="setTool('hline')">‚îÄ</button>
      <button class="tool-btn" data-tool="vline" title="Vertical Line" onclick="setTool('vline')">‚îÇ</button>
      <button class="tool-btn" data-tool="channel" title="Parallel Channel" onclick="setTool('channel')">‚ñ¨</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" data-tool="fib" title="Fibonacci Retracement" onclick="setTool('fib')">F</button>
      <button class="tool-btn" data-tool="fibext" title="Fibonacci Extension" onclick="setTool('fibext')">F‚Çë</button>
      <button class="tool-btn" data-tool="fibfan" title="Fibonacci Fan" onclick="setTool('fibfan')">F‚åø</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" data-tool="rect" title="Rectangle" onclick="setTool('rect')">‚ñ≠</button>
      <button class="tool-btn" data-tool="circle" title="Circle" onclick="setTool('circle')">‚óã</button>
      <button class="tool-btn" data-tool="triangle" title="Triangle" onclick="setTool('triangle')">‚ñ≥</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" data-tool="text" title="Text" onclick="setTool('text')">T</button>
      <button class="tool-btn" data-tool="arrow" title="Arrow" onclick="setTool('arrow')">‚Üó</button>
      <button class="tool-btn" data-tool="callout" title="Callout" onclick="setTool('callout')">üí¨</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" data-tool="measure" title="Price Range" onclick="setTool('measure')">üìè</button>
      <button class="tool-btn" data-tool="ruler" title="Date Range" onclick="setTool('ruler')">üìê</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" data-tool="brush" title="Brush" onclick="setTool('brush')">üñå</button>
      <button class="tool-btn" data-tool="highlighter" title="Highlighter" onclick="setTool('highlighter')">üñç</button>
      <div class="tool-divider"></div>
      <button class="tool-btn" title="Lock Drawings" onclick="toggleLockDrawings()">üîí</button>
      <button class="tool-btn" title="Show/Hide Drawings" onclick="toggleDrawingsVisible()">üëÅ</button>
      <button class="tool-btn" title="Delete All Drawings" onclick="deleteAllDrawings()" style="color:var(--red)">üóë</button>
      <div style="flex:1"></div>
      <button class="tool-btn" title="Magnet Mode" onclick="toggleMagnet()">üß≤</button>
      <button class="tool-btn" title="Stay in Drawing Mode" onclick="toggleStayInDrawing()">üìå</button>
    </div>

    <!-- CHART AREA -->
    <div class="chart-area" id="chartArea">
      <div class="chart-header" id="chartHeader">
        <span class="sym-label" id="headerSym">AAPL</span>
        <div class="price-info" id="priceInfo">
          <span><span class="lbl">O</span><span class="val" id="piO">-</span></span>
          <span><span class="lbl">H</span><span class="val" id="piH">-</span></span>
          <span><span class="lbl">L</span><span class="val" id="piL">-</span></span>
          <span><span class="lbl">C</span><span class="val" id="piC">-</span></span>
          <span><span class="lbl">Vol</span><span class="val" id="piV">-</span></span>
        </div>
        <div class="compare-legend" id="compareLegend" style="display:none"></div>
      </div>
      <div class="chart-grid layout-1" id="chartGrid">
        <div class="chart-cell active" id="cell0" onclick="setActiveCell(0)">
          <div class="chart-watermark" id="watermark0">AAPL</div>
          <div class="cell-chart" id="chartDiv0"></div>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="right-panel" id="rightPanel">
      <div class="panel-tabs" id="panelTabs"></div>
      <div class="panel-content" id="panelContent"></div>
    </div>
  </div>

  <!-- BOTTOM BAR -->
  <div class="bottom-bar">
    <div class="market-status">
      <div class="dot" id="mktDot"></div>
      <span id="mktStatus">--</span>
    </div>
    <span id="mktTime" class="mono" style="font-size:10px">--</span>
    <select class="tz-select" id="tzSelect" onchange="setTimezone(this.value)">
      <option value="America/New_York">ET</option>
      <option value="America/Chicago">CT</option>
      <option value="America/Denver">MT</option>
      <option value="America/Los_Angeles">PT</option>
      <option value="UTC">UTC</option>
      <option value="Europe/London">GMT</option>
      <option value="Europe/Berlin">CET</option>
      <option value="Asia/Tokyo">JST</option>
      <option value="Asia/Shanghai">CST</option>
      <option value="Asia/Kolkata">IST</option>
    </select>
    <div class="spacer"></div>
    <span id="crossInfo" class="mono" style="font-size:10px;color:var(--t3)"></span>
    <div class="spacer"></div>
    <span id="dailyPerf" class="perf mono">--</span>
    <span class="mono" style="font-size:10px;color:var(--t3)">|</span>
    <span id="weekPerf" class="perf mono">--</span>
    <span class="mono" style="font-size:10px;color:var(--t3)">|</span>
    <span id="monthPerf" class="perf mono">--</span>
  </div>
</div>

<!-- TOAST CONTAINER -->
<div class="toast-container" id="toastContainer"></div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctxMenu">
  <div class="ctx-item" onclick="ctxAction('addAlert')">üîî Add Alert<span class="ctx-key">Alt+A</span></div>
  <div class="ctx-item" onclick="ctxAction('addToWatchlist')">‚äï Add to Watchlist</div>
  <div class="ctx-divider"></div>
  <div class="ctx-item" onclick="ctxAction('hline')">‚îÄ Add Horizontal Line</div>
  <div class="ctx-item" onclick="ctxAction('trendline')">‚ï≤ Add Trend Line</div>
  <div class="ctx-item" onclick="ctxAction('fib')">F Fibonacci Retracement</div>
  <div class="ctx-divider"></div>
  <div class="ctx-item" onclick="ctxAction('resetZoom')">üîÑ Reset Zoom<span class="ctx-key">Home</span></div>
  <div class="ctx-item" onclick="ctxAction('screenshot')">üì∑ Screenshot<span class="ctx-key">Alt+S</span></div>
  <div class="ctx-item" onclick="ctxAction('export')">üíæ Export Data</div>
  <div class="ctx-divider"></div>
  <div class="ctx-item danger" onclick="ctxAction('removeAll')">üóë Remove All Drawings</div>
</div>

<!-- INDICATOR MODAL -->
<div class="modal-overlay" id="indicatorModal">
  <div class="modal ind-modal">
    <div class="modal-header">
      <h3>Indicators, Metrics & Strategies</h3>
      <button class="modal-close" onclick="closeModal('indicatorModal')">‚úï</button>
    </div>
    <div class="modal-body">
      <input class="ind-search" id="indSearch" placeholder="Search indicators..." oninput="filterIndicators()">
      <div class="ind-cats" id="indCats"></div>
      <div class="ind-list" id="indList"></div>
    </div>
  </div>
</div>

<!-- COMPARE MODAL -->
<div class="modal-overlay" id="compareModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Compare Symbols</h3>
      <button class="modal-close" onclick="closeModal('compareModal')">‚úï</button>
    </div>
    <div class="modal-body">
      <div style="display:flex;align-items:center;gap:8px;padding:0 0 8px">
        <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:var(--t2);cursor:pointer">
          <input type="checkbox" id="comparePctMode" onchange="reloadCompareOverlays()">
          <span>% Performance Mode</span>
        </label>
        <span style="font-size:10px;color:var(--t3)">(Normalize all symbols to % change)</span>
      </div>
      <input class="ind-search" id="compareSearch" placeholder="Enter symbol to compare..." oninput="searchCompare()">
      <div class="ind-list" id="compareResults"></div>
    </div>
  </div>
</div>

<!-- TEMPLATE MODAL -->
<div class="modal-overlay" id="templateModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Chart Templates</h3>
      <button class="modal-close" onclick="closeModal('templateModal')">‚úï</button>
    </div>
    <div class="modal-body">
      <div style="display:flex;gap:8px;margin-bottom:12px">
        <input class="ind-search" id="tmplName" placeholder="Template name..." style="margin:0;flex:1">
        <button class="btn btn-primary" onclick="saveTemplate()">Save Current</button>
      </div>
      <div id="tmplList"></div>
    </div>
  </div>
</div>

<!-- ALERT MODAL -->
<div class="modal-overlay" id="alertModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Create Alert</h3>
      <button class="modal-close" onclick="closeModal('alertModal')">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="alert-form">
        <label>Symbol</label>
        <input id="alertSym" value="AAPL">
        <label>Condition</label>
        <select id="alertCond">
          <option value="crosses_above">Price Crosses Above</option>
          <option value="crosses_below">Price Crosses Below</option>
          <option value="greater_than">Price Greater Than</option>
          <option value="less_than">Price Less Than</option>
          <option value="pct_up">% Change Up</option>
          <option value="pct_down">% Change Down</option>
        </select>
        <label>Value</label>
        <input id="alertVal" type="number" step="0.01" placeholder="Enter price or %">
        <label>Message (optional)</label>
        <input id="alertMsg" placeholder="Alert message...">
        <button class="btn-add-alert" onclick="createAlert()">Create Alert</button>
      </div>
    </div>
  </div>
</div>

<!-- SETTINGS MODAL -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Chart Settings</h3>
      <button class="modal-close" onclick="closeModal('settingsModal')">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="panel-section">
        <div class="panel-section-title">Appearance</div>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setGrid" checked onchange="updateSettings()"> Show Grid Lines
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setCrosshair" checked onchange="updateSettings()"> Show Crosshair
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setWatermark" checked onchange="updateSettings()"> Show Watermark
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setVolume" checked onchange="updateSettings()"> Show Volume
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setAutoScale" checked onchange="updateSettings()"> Auto Scale
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setLogScale" onchange="updateSettings()"> Logarithmic Scale
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setExtHours" onchange="updateSettings()"> Extended Hours
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setShowPatterns" checked onchange="updateSettings()"> Candlestick Patterns
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          <input type="checkbox" id="setAutoSR" checked onchange="updateSettings()"> Auto Support/Resistance
        </label>
      </div>
      <div class="panel-section">
        <div class="panel-section-title">Colors</div>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          Up Color: <input type="color" id="colorUp" value="#26a69a" onchange="updateSettings()">
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          Down Color: <input type="color" id="colorDn" value="#ef5350" onchange="updateSettings()">
        </label>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          Background: <input type="color" id="colorBg" value="#131722" onchange="updateSettings()">
        </label>
      </div>
      <div class="panel-section">
        <div class="panel-section-title">Data</div>
        <label style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:12px;color:var(--t2)">
          Auto-Refresh: 
          <select id="setRefresh" onchange="updateSettings()" style="background:var(--bg3);border:1px solid var(--brd);color:var(--t1);padding:2px 6px;border-radius:4px;font-size:12px">
            <option value="0">Off</option>
            <option value="15" selected>15s</option>
            <option value="30">30s</option>
            <option value="60">1m</option>
            <option value="300">5m</option>
          </select>
        </label>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="resetSettings()">Reset Defaults</button>
      <button class="btn btn-primary" onclick="closeModal('settingsModal')">Done</button>
    </div>
  </div>
</div>

<script>
// ==========================================
// CONFIGURATION & STATE
// ==========================================
const POLYGON_KEY = 'zvEY_KYYMHoAN0JqY7n2Ze6q0kBuJX_d';
const API_BASE = 'https://api.polygon.io';
const COMPARE_COLORS = ['#f7a21b','#7b61ff','#00bcd4','#ff6d00','#e91e63','#4caf50'];

const STATE = {
  symbol: 'AAPL',
  timeframe: { multiplier: 1, timespan: 'day' },
  chartType: 'candles',
  layout: 1,
  activeCell: 0,
  indicators: ['vol'],
  compareSymbols: [],
  drawingTool: 'crosshair',
  drawingsLocked: false,
  drawingsVisible: true,
  magnetMode: false,
  stayInDrawing: false,
  timezone: 'America/New_York',
  replayMode: false,
  replayIndex: 0,
  replaySpeed: 1,
  replayPlaying: false,
  cells: [
    { symbol:'AAPL', chart:null, series:null, volumeSeries:null, indicatorSeries:{}, data:[] },
    { symbol:'MSFT', chart:null, series:null, volumeSeries:null, indicatorSeries:{}, data:[] },
    { symbol:'GOOGL', chart:null, series:null, volumeSeries:null, indicatorSeries:{}, data:[] },
    { symbol:'AMZN', chart:null, series:null, volumeSeries:null, indicatorSeries:{}, data:[] },
    { symbol:'TSLA', chart:null, series:null, volumeSeries:null, indicatorSeries:{}, data:[] },
    { symbol:'NVDA', chart:null, series:null, volumeSeries:null, indicatorSeries:{}, data:[] },
  ],
  allData: [],
  settings: {
    grid: true, crosshair: true, watermark: true, volume: true,
    autoScale: true, logScale: false, extHours: false,
    colorUp: '#26a69a', colorDn: '#ef5350', colorBg: '#131722',
    refreshInterval: 15
  }
};

// ==========================================
// WATCHLISTS (Persisted to localStorage)
// ==========================================
const DEFAULT_WATCHLISTS = {
  'Main': ['AAPL','MSFT','GOOGL','AMZN','TSLA','NVDA','META','NFLX','BRK.B','JPM'],
  'Crypto': ['X:BTCUSD','X:ETHUSD','X:SOLUSD','X:ADAUSD','X:DOGEUSD','X:MATICUSD'],
  'ETFs': ['SPY','QQQ','IWM','DIA','VTI','ARKK','GLD','SLV','TLT','XLF'],
  'Forex': ['C:EURUSD','C:GBPUSD','C:USDJPY','C:AUDUSD','C:USDCAD','C:USDCHF'],
  'Leveraged': ['TQQQ','SQQQ','UPRO','SPXU','TECL','SOXL','FNGU','LABU'],
  'My Picks': ['AAPL','NVDA','PLTR','COIN','MSTR']
};

let watchlists = JSON.parse(localStorage.getItem('jh_watchlists')) || JSON.parse(JSON.stringify(DEFAULT_WATCHLISTS));
let activeWatchlist = localStorage.getItem('jh_active_wl') || 'Main';

// ==========================================
// ALERTS (Persisted)
// ==========================================
let alerts = JSON.parse(localStorage.getItem('jh_alerts')) || [];

// ==========================================
// TEMPLATES (Persisted)
// ==========================================
let templates = JSON.parse(localStorage.getItem('jh_templates')) || {
  'Default': { chartType:'candles', indicators:['vol'], settings:{} },
  'Swing Trading': { chartType:'candles', indicators:['vol','sma20','sma50','sma200','rsi','macd'], settings:{} },
  'Scalping': { chartType:'candles', indicators:['vol','ema12','ema26','bb','vwap','stoch'], settings:{} },
  'Ichimoku': { chartType:'candles', indicators:['vol','ichi'], settings:{} },
};

// ==========================================
// NOTES (Persisted per symbol)
// ==========================================
let symbolNotes = JSON.parse(localStorage.getItem('jh_notes')) || {};

// ==========================================
// DRAWINGS (Persisted per symbol)
// ==========================================
let symbolDrawings = JSON.parse(localStorage.getItem('jh_drawings')) || {};

// ==========================================
// INDICATOR DEFINITIONS
// ==========================================
const INDICATORS = [
  // Moving Averages
  { id:'sma7', name:'SMA 7', cat:'Moving Averages', desc:'Simple Moving Average (7)' },
  { id:'sma9', name:'SMA 9', cat:'Moving Averages', desc:'Simple Moving Average (9)' },
  { id:'sma20', name:'SMA 20', cat:'Moving Averages', desc:'Simple Moving Average (20)' },
  { id:'sma50', name:'SMA 50', cat:'Moving Averages', desc:'Simple Moving Average (50)' },
  { id:'sma100', name:'SMA 100', cat:'Moving Averages', desc:'Simple Moving Average (100)' },
  { id:'sma200', name:'SMA 200', cat:'Moving Averages', desc:'Simple Moving Average (200)' },
  { id:'ema9', name:'EMA 9', cat:'Moving Averages', desc:'Exponential Moving Average (9)' },
  { id:'ema12', name:'EMA 12', cat:'Moving Averages', desc:'Exponential Moving Average (12)' },
  { id:'ema21', name:'EMA 21', cat:'Moving Averages', desc:'Exponential Moving Average (21)' },
  { id:'ema26', name:'EMA 26', cat:'Moving Averages', desc:'Exponential Moving Average (26)' },
  { id:'ema50', name:'EMA 50', cat:'Moving Averages', desc:'Exponential Moving Average (50)' },
  { id:'wma20', name:'WMA 20', cat:'Moving Averages', desc:'Weighted Moving Average (20)' },
  { id:'dema20', name:'DEMA 20', cat:'Moving Averages', desc:'Double Exponential MA (20)' },
  { id:'tema20', name:'TEMA 20', cat:'Moving Averages', desc:'Triple Exponential MA (20)' },
  { id:'hull20', name:'Hull MA 20', cat:'Moving Averages', desc:'Hull Moving Average (20)' },
  { id:'alma', name:'ALMA', cat:'Moving Averages', desc:'Arnaud Legoux MA (20, 0.85, 6)' },
  { id:'smma20', name:'SMMA 20', cat:'Moving Averages', desc:'Smoothed Moving Average (20)' },
  { id:'lsma20', name:'LSMA 20', cat:'Moving Averages', desc:'Least Squares MA (20)' },
  { id:'mcginley', name:'McGinley Dynamic', cat:'Moving Averages', desc:'McGinley Dynamic (14)' },
  { id:'vwma20', name:'VWMA 20', cat:'Moving Averages', desc:'Volume-Weighted MA (20)' },
  { id:'envma', name:'MA Envelope', cat:'Moving Averages', desc:'SMA 20 ¬± 2.5%' },
  { id:'machannel', name:'MA Channel', cat:'Moving Averages', desc:'High/Low MA Channel (20)' },
  { id:'guppy', name:'Guppy MMA', cat:'Moving Averages', desc:'Guppy Multiple Moving Average' },
  { id:'alligator', name:'Williams Alligator', cat:'Moving Averages', desc:'Alligator (13,8,5)' },
  // Volatility
  { id:'bb', name:'Bollinger Bands', cat:'Volatility', desc:'BB (20,2)' },
  { id:'bb2', name:'Bollinger Bands (2,3)', cat:'Volatility', desc:'BB (20,3)' },
  { id:'bbpct', name:'BB %B', cat:'Volatility', desc:'Bollinger Bands %B (20,2)' },
  { id:'bbw', name:'BB Width', cat:'Volatility', desc:'Bollinger Bands Width (20,2)' },
  { id:'kc', name:'Keltner Channel', cat:'Volatility', desc:'KC (20,1.5)' },
  { id:'dc', name:'Donchian Channel', cat:'Volatility', desc:'DC (20)' },
  { id:'atr', name:'ATR', cat:'Volatility', desc:'Average True Range (14)' },
  { id:'stddev', name:'Std Deviation', cat:'Volatility', desc:'Standard Deviation (20)' },
  { id:'squeeze', name:'TTM Squeeze', cat:'Volatility', desc:'Squeeze Momentum' },
  { id:'histvol', name:'Historical Volatility', cat:'Volatility', desc:'HV (20)' },
  { id:'chvol', name:'Chaikin Volatility', cat:'Volatility', desc:'Chaikin Vol (10, 10)' },
  { id:'stderror', name:'Std Error Bands', cat:'Volatility', desc:'Standard Error Bands (20)' },
  // Oscillators
  { id:'rsi', name:'RSI', cat:'Oscillators', desc:'Relative Strength Index (14)' },
  { id:'macd', name:'MACD', cat:'Oscillators', desc:'MACD (12,26,9)' },
  { id:'stoch', name:'Stochastic', cat:'Oscillators', desc:'Stochastic (14,3,3)' },
  { id:'stochrsi', name:'Stochastic RSI', cat:'Oscillators', desc:'StochRSI (14,14,3,3)' },
  { id:'cci', name:'CCI', cat:'Oscillators', desc:'Commodity Channel Index (20)' },
  { id:'willr', name:'Williams %R', cat:'Oscillators', desc:'Williams %R (14)' },
  { id:'roc', name:'ROC', cat:'Oscillators', desc:'Rate of Change (12)' },
  { id:'mfi', name:'MFI', cat:'Oscillators', desc:'Money Flow Index (14)' },
  { id:'uo', name:'Ultimate Oscillator', cat:'Oscillators', desc:'UO (7,14,28)' },
  { id:'tsi', name:'TSI', cat:'Oscillators', desc:'True Strength Index (25,13)' },
  { id:'ao', name:'Awesome Oscillator', cat:'Oscillators', desc:'AO' },
  { id:'cmo', name:'Chande Momentum', cat:'Oscillators', desc:'CMO (14)' },
  { id:'dpo', name:'Detrended Price', cat:'Oscillators', desc:'DPO (21)' },
  { id:'fisher', name:'Fisher Transform', cat:'Oscillators', desc:'Fisher (10)' },
  { id:'trix', name:'TRIX', cat:'Oscillators', desc:'TRIX (18)' },
  { id:'mom', name:'Momentum', cat:'Oscillators', desc:'Momentum (10)' },
  { id:'bop', name:'Balance of Power', cat:'Oscillators', desc:'Balance of Power' },
  { id:'crsi', name:'Connors RSI', cat:'Oscillators', desc:'CRSI (3,2,100)' },
  { id:'coppock', name:'Coppock Curve', cat:'Oscillators', desc:'Coppock (14,11,10)' },
  { id:'rvi', name:'Rel. Vigor Index', cat:'Oscillators', desc:'RVI (10)' },
  { id:'rvol', name:'Rel. Volatility', cat:'Oscillators', desc:'RVI (14)' },
  { id:'klinger', name:'Klinger Oscillator', cat:'Oscillators', desc:'KVO (34,55,13)' },
  { id:'elderforce', name:"Elder's Force", cat:'Oscillators', desc:'Elder Force Index (13)' },
  { id:'eom', name:'Ease of Movement', cat:'Oscillators', desc:'EOM (14)' },
  { id:'ppo', name:'Price Oscillator', cat:'Oscillators', desc:'PPO (12,26,9)' },
  { id:'massindex', name:'Mass Index', cat:'Oscillators', desc:'Mass Index (25)' },
  { id:'chop', name:'Choppiness Index', cat:'Oscillators', desc:'CHOP (14)' },
  { id:'smierg', name:'SMI Ergodic', cat:'Oscillators', desc:'SMI Ergodic (5,20,5)' },
  // Volume
  { id:'vol', name:'Volume', cat:'Volume', desc:'Volume bars' },
  { id:'vwap', name:'VWAP', cat:'Volume', desc:'Volume-Weighted Avg Price' },
  { id:'obv', name:'OBV', cat:'Volume', desc:'On-Balance Volume' },
  { id:'ad', name:'A/D Line', cat:'Volume', desc:'Accumulation/Distribution' },
  { id:'cmf', name:'CMF', cat:'Volume', desc:'Chaikin Money Flow (20)' },
  { id:'vp', name:'Volume Profile', cat:'Volume', desc:'Volume by Price' },
  { id:'netvol', name:'Net Volume', cat:'Volume', desc:'Net Volume (up-down)' },
  { id:'pvt', name:'Price Volume Trend', cat:'Volume', desc:'PVT' },
  { id:'volosc', name:'Volume Oscillator', cat:'Volume', desc:'VolOsc (5,10)' },
  { id:'chaikinosc', name:'Chaikin Oscillator', cat:'Volume', desc:'Chaikin Osc (3,10)' },
  // Trend
  { id:'ichi', name:'Ichimoku Cloud', cat:'Trend', desc:'Ichimoku Kinko Hyo' },
  { id:'psar', name:'Parabolic SAR', cat:'Trend', desc:'PSAR (0.02, 0.2)' },
  { id:'dmi', name:'DMI', cat:'Trend', desc:'Directional Movement Index (14)' },
  { id:'adx', name:'ADX', cat:'Trend', desc:'Average Directional Index (14)' },
  { id:'supertrend', name:'SuperTrend', cat:'Trend', desc:'SuperTrend (10, 3)' },
  { id:'aroon', name:'Aroon', cat:'Trend', desc:'Aroon (25)' },
  { id:'vortex', name:'Vortex Indicator', cat:'Trend', desc:'VI (14)' },
  { id:'kst', name:'Know Sure Thing', cat:'Trend', desc:'KST' },
  { id:'chandekroll', name:'Chande Kroll Stop', cat:'Trend', desc:'CKS (10,1,9)' },
  { id:'zigzag', name:'Zig Zag', cat:'Trend', desc:'Zig Zag (5%)' },
  { id:'fractal', name:'Williams Fractal', cat:'Trend', desc:'Fractals (2)' },
  // Support/Resistance
  { id:'pivot', name:'Pivot Points', cat:'S/R', desc:'Standard Pivots' },
  { id:'pivotfib', name:'Fibonacci Pivots', cat:'S/R', desc:'Fibonacci-based Pivots' },
  { id:'pivotwoodie', name:'Woodie Pivots', cat:'S/R', desc:'Woodie-style Pivots' },
  { id:'pivotcam', name:'Camarilla Pivots', cat:'S/R', desc:'Camarilla Pivots' },
  { id:'hilo52w', name:'52W High/Low', cat:'S/R', desc:'52-Week High & Low lines' },
  { id:'pricechannel', name:'Price Channel', cat:'S/R', desc:'Price Channel (20)' },
  // Statistics
  { id:'linreg', name:'Linear Regression', cat:'Statistics', desc:'Linear Regression (20)' },
  { id:'linregslope', name:'LR Slope', cat:'Statistics', desc:'Linear Regression Slope (20)' },
  { id:'correl', name:'Correlation', cat:'Statistics', desc:'Correlation with SPY' },
  { id:'beta', name:'Beta', cat:'Statistics', desc:'Beta vs SPY (60)' },
  // Patterns
  { id:'candlepatterns', name:'Candle Patterns', cat:'Patterns', desc:'Auto-detect candlestick patterns' },
  { id:'chartpatterns', name:'Chart Patterns', cat:'Patterns', desc:'Auto-detect chart patterns' },
  { id:'divergence', name:'RSI Divergence', cat:'Patterns', desc:'Detect RSI divergences' },
];

const IND_COLORS = {
  sma7:'#ff9800',sma9:'#ff9800',sma20:'#2196f3',sma50:'#ff5722',sma100:'#9c27b0',sma200:'#e91e63',
  ema9:'#4caf50',ema12:'#2196f3',ema21:'#ff9800',ema26:'#ff5722',ema50:'#9c27b0',
  wma20:'#00bcd4',dema20:'#cddc39',tema20:'#ff4081',hull20:'#7c4dff',
  alma:'#e040fb',smma20:'#26c6da',lsma20:'#d4e157',mcginley:'#ff6e40',vwma20:'#69f0ae',
  vwap:'#f7a21b',linreg:'#00e5ff',supertrend:'#26a69a',
  bbpct:'#2196f3',bbw:'#2196f3',histvol:'#ff9800',chvol:'#e91e63',
  stochrsi:'#7c4dff',cmo:'#ff6d00',dpo:'#ff4081',fisher:'#00bfa5',trix:'#651fff',
  mom:'#ff9100',bop:'#00e676',crsi:'#d500f9',coppock:'#00b0ff',rvi:'#ffab40',
  rvol:'#ff6e40',klinger:'#1de9b6',elderforce:'#ff1744',eom:'#00e5ff',ppo:'#f50057',
  massindex:'#aa00ff',chop:'#ffd600',smierg:'#76ff03',
  netvol:'#26a69a',pvt:'#ff9800',volosc:'#e91e63',chaikinosc:'#7c4dff',
  vortex:'#00bcd4',kst:'#ff5722',chandekroll:'#e91e63',zigzag:'#ffffff',
  linregslope:'#00e5ff',pricechannel:'#ff9800',
};

// ==========================================
// INITIALIZATION
// ==========================================
function init() {
  loadSettings();
  createChart(0);
  loadSymbol(STATE.symbol, 0);
  setupEventListeners();
  updateMarketStatus();
  setInterval(updateMarketStatus, 30000);
  startAutoRefresh();
  toast('JustHodl Charts loaded', 'success');
}

function loadSettings() {
  const saved = localStorage.getItem('jh_settings');
  if (saved) Object.assign(STATE.settings, JSON.parse(saved));
  document.getElementById('setGrid').checked = STATE.settings.grid;
  document.getElementById('setCrosshair').checked = STATE.settings.crosshair;
  document.getElementById('setWatermark').checked = STATE.settings.watermark;
  document.getElementById('setVolume').checked = STATE.settings.volume;
  document.getElementById('setAutoScale').checked = STATE.settings.autoScale;
  document.getElementById('setLogScale').checked = STATE.settings.logScale;
  document.getElementById('setExtHours').checked = STATE.settings.extHours;
  document.getElementById('setShowPatterns').checked = STATE.settings.showPatterns !== false;
  document.getElementById('setAutoSR').checked = STATE.settings.autoSR !== false;
  document.getElementById('colorUp').value = STATE.settings.colorUp;
  document.getElementById('colorDn').value = STATE.settings.colorDn;
  document.getElementById('colorBg').value = STATE.settings.colorBg;
  document.getElementById('setRefresh').value = STATE.settings.refreshInterval;
}

function saveSettings() {
  localStorage.setItem('jh_settings', JSON.stringify(STATE.settings));
}

function updateSettings() {
  STATE.settings.grid = document.getElementById('setGrid').checked;
  STATE.settings.crosshair = document.getElementById('setCrosshair').checked;
  STATE.settings.watermark = document.getElementById('setWatermark').checked;
  STATE.settings.volume = document.getElementById('setVolume').checked;
  STATE.settings.autoScale = document.getElementById('setAutoScale').checked;
  STATE.settings.logScale = document.getElementById('setLogScale').checked;
  STATE.settings.extHours = document.getElementById('setExtHours').checked;
  STATE.settings.showPatterns = document.getElementById('setShowPatterns').checked;
  STATE.settings.autoSR = document.getElementById('setAutoSR').checked;
  STATE.settings.colorUp = document.getElementById('colorUp').value;
  STATE.settings.colorDn = document.getElementById('colorDn').value;
  STATE.settings.colorBg = document.getElementById('colorBg').value;
  STATE.settings.refreshInterval = parseInt(document.getElementById('setRefresh').value);
  saveSettings();
  rebuildAllCharts();
  startAutoRefresh();
}

function resetSettings() {
  STATE.settings = { grid:true, crosshair:true, watermark:true, volume:true, autoScale:true, logScale:false, extHours:false, colorUp:'#26a69a', colorDn:'#ef5350', colorBg:'#131722', refreshInterval:15 };
  loadSettings();
  saveSettings();
  rebuildAllCharts();
}

function openSettings() { document.getElementById('settingsModal').classList.add('show'); }

// ==========================================
// CHART CREATION
// ==========================================
function createChart(cellIdx) {
  const cell = STATE.cells[cellIdx];
  const container = document.getElementById(`chartDiv${cellIdx}`);
  if (!container) return;
  if (cell.chart) { cell.chart.remove(); cell.chart = null; }
  container.innerHTML = '';

  const s = STATE.settings;
  const chart = LightweightCharts.createChart(container, {
    width: container.clientWidth,
    height: container.clientHeight,
    layout: { background: { color: s.colorBg }, textColor: '#787b86', fontFamily: "'JetBrains Mono', monospace", fontSize: 11 },
    grid: { vertLines: { color: s.grid ? '#1e222d' : 'transparent' }, horzLines: { color: s.grid ? '#1e222d' : 'transparent' } },
    crosshair: {
      mode: s.crosshair ? LightweightCharts.CrosshairMode.Normal : LightweightCharts.CrosshairMode.Hidden,
      vertLine: { color: 'rgba(42,46,57,.8)', width: 1, style: 0, labelBackgroundColor: '#2962ff' },
      horzLine: { color: 'rgba(42,46,57,.8)', width: 1, style: 0, labelBackgroundColor: '#2962ff' },
    },
    rightPriceScale: { borderColor: '#2a2e39', scaleMargins: { top: 0.1, bottom: 0.2 }, autoScale: s.autoScale, mode: s.logScale ? 1 : 0 },
    timeScale: { borderColor: '#2a2e39', timeVisible: true, secondsVisible: false, rightOffset: 5, barSpacing: 8 },
    handleScroll: true,
    handleScale: true,
  });

  cell.chart = chart;

  // Create main series based on chart type
  createMainSeries(cellIdx);

  // Volume
  if (s.volume) {
    cell.volumeSeries = chart.addHistogramSeries({
      color: '#26a69a',
      priceFormat: { type: 'volume' },
      priceScaleId: 'vol',
      scaleMargins: { top: 0.85, bottom: 0 },
    });
    chart.priceScale('vol').applyOptions({ scaleMargins: { top: 0.85, bottom: 0 } });
  }

  // Crosshair handler
  chart.subscribeCrosshairMove(param => {
    if (!param.time || !param.seriesData) return;
    const d = param.seriesData.get(cell.series);
    if (!d) return;
    const o = d.open || d.value || 0;
    const h = d.high || d.value || 0;
    const l = d.low || d.value || 0;
    const c = d.close || d.value || 0;
    if (cellIdx === STATE.activeCell) {
      document.getElementById('piO').textContent = o.toFixed(2);
      document.getElementById('piH').textContent = h.toFixed(2);
      document.getElementById('piL').textContent = l.toFixed(2);
      document.getElementById('piC').textContent = c.toFixed(2);
      const cls = c >= o ? 'up' : 'dn';
      ['piO','piH','piL','piC'].forEach(id => { document.getElementById(id).className = 'val ' + cls; });
      const vol = param.seriesData.get(cell.volumeSeries);
      if (vol) document.getElementById('piV').textContent = formatVol(vol.value);
    }
  });

  // Resize observer
  new ResizeObserver(() => {
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
    }
  }).observe(container);

  return chart;
}

function createMainSeries(cellIdx) {
  const cell = STATE.cells[cellIdx];
  const s = STATE.settings;
  if (cell.series && cell.chart) {
    try { cell.chart.removeSeries(cell.series); } catch(e) {}
  }

  switch (STATE.chartType) {
    case 'line':
      cell.series = cell.chart.addLineSeries({ color: '#2962ff', lineWidth: 2, crosshairMarkerRadius: 4 });
      break;
    case 'stepline':
      cell.series = cell.chart.addLineSeries({ color: '#7b61ff', lineWidth: 2, crosshairMarkerRadius: 4, lineType: 1 });
      break;
    case 'area':
      cell.series = cell.chart.addAreaSeries({ topColor: 'rgba(41,98,255,.4)', bottomColor: 'rgba(41,98,255,.0)', lineColor: '#2962ff', lineWidth: 2 });
      break;
    case 'hlcarea':
      cell.series = cell.chart.addLineSeries({ color: '#2962ff', lineWidth: 2, crosshairMarkerRadius: 4 });
      break;
    case 'bars':
      cell.series = cell.chart.addBarSeries({ upColor: s.colorUp, downColor: s.colorDn });
      break;
    case 'baseline':
      cell.series = cell.chart.addBaselineSeries({ topLineColor: s.colorUp, bottomLineColor: s.colorDn, topFillColor1: 'rgba(38,166,154,.2)', topFillColor2: 'rgba(38,166,154,.0)', bottomFillColor1: 'rgba(239,83,80,.0)', bottomFillColor2: 'rgba(239,83,80,.2)' });
      break;
    case 'hollow':
      cell.series = cell.chart.addCandlestickSeries({ upColor: 'transparent', downColor: s.colorDn, borderUpColor: s.colorUp, borderDownColor: s.colorDn, wickUpColor: s.colorUp, wickDownColor: s.colorDn });
      break;
    case 'columns':
      cell.series = cell.chart.addHistogramSeries({ color: '#2962ff', priceFormat: { type: 'price' } });
      break;
    case 'renko':
      cell.series = cell.chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderUpColor: '#26a69a', borderDownColor: '#ef5350', wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
      break;
    case 'linebreak':
      cell.series = cell.chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderUpColor: '#26a69a', borderDownColor: '#ef5350', wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
      break;
    default: // candles, heikin
      cell.series = cell.chart.addCandlestickSeries({ upColor: s.colorUp, downColor: s.colorDn, borderUpColor: s.colorUp, borderDownColor: s.colorDn, wickUpColor: s.colorUp, wickDownColor: s.colorDn });
  }
}

function rebuildAllCharts() {
  const grid = document.getElementById('chartGrid');
  const cells = grid.querySelectorAll('.chart-cell');
  cells.forEach((_, i) => {
    if (STATE.cells[i] && STATE.cells[i].chart) {
      createChart(i);
      if (STATE.cells[i].data.length) {
        setChartData(i, STATE.cells[i].data);
      }
    }
  });
}

// ==========================================
// DATA FETCHING - ENTERPRISE GRADE
// ==========================================
const HISTORY_RANGES = {
  '1d': { days: 1 },
  '5d': { days: 5 },
  '1m': { months: 1 },
  '3m': { months: 3 },
  '6m': { months: 6 },
  'ytd': { ytd: true },
  '1y': { years: 1 },
  '2y': { years: 2 },
  '5y': { years: 5 },
  '10y': { years: 10 },
  '20y': { years: 20 },
  'max': { years: 50 },
};
let selectedRange = '5y';
let customDateFrom = null, customDateTo = null;

function setHistoryRange(range) {
  if (range === 'custom') {
    const fromStr = prompt('From date (YYYY-MM-DD):', '2000-01-01');
    const toStr = prompt('To date (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
    if (fromStr && toStr) { customDateFrom = fromStr; customDateTo = toStr; selectedRange = 'custom'; }
    else { document.getElementById('histRange').value = selectedRange; return; }
  } else {
    selectedRange = range;
    customDateFrom = null; customDateTo = null;
  }
  loadSymbol(STATE.symbol, STATE.activeCell);
}

function getDateRange(timespan) {
  const to = customDateTo ? new Date(customDateTo + 'T23:59:59') : new Date();
  const from = new Date();

  if (customDateFrom) {
    return { from: new Date(customDateFrom), to };
  }

  if (selectedRange === 'auto') {
    // Auto-determine range based on timeframe
    if (timespan === 'minute') from.setDate(to.getDate() - 7);
    else if (timespan === 'hour') from.setMonth(to.getMonth() - 3);
    else if (timespan === 'day') from.setFullYear(to.getFullYear() - 5);
    else if (timespan === 'week') from.setFullYear(to.getFullYear() - 15);
    else if (timespan === 'month' || timespan === 'quarter' || timespan === 'year') from.setFullYear(to.getFullYear() - 30);
    else from.setFullYear(to.getFullYear() - 5);
    return { from, to };
  }

  const r = HISTORY_RANGES[selectedRange];
  if (!r) { from.setFullYear(to.getFullYear() - 5); return { from, to }; }

  if (r.ytd) { from.setMonth(0); from.setDate(1); from.setHours(0,0,0,0); }
  else {
    if (r.days) from.setDate(to.getDate() - r.days);
    if (r.months) from.setMonth(to.getMonth() - r.months);
    if (r.years) from.setFullYear(to.getFullYear() - r.years);
  }
  return { from, to };
}

// Paginated fetch - gets ALL data by chaining requests
async function fetchBars(symbol, multiplier, timespan) {
  const range = getDateRange(timespan);
  const fmtDate = d => d.toISOString().split('T')[0];

  // For quarter/year timeframes, fetch daily and resample
  let actualTimespan = timespan;
  let actualMultiplier = multiplier;
  let needsResample = false;
  if (timespan === 'quarter') { actualTimespan = 'day'; actualMultiplier = 1; needsResample = true; }
  if (timespan === 'year') { actualTimespan = 'week'; actualMultiplier = 1; needsResample = true; }

  let allResults = [];
  let currentFrom = new Date(range.from);
  let attempts = 0;
  const maxAttempts = 20; // Safety limit - up to 1M bars

  // Paginated fetching loop
  while (attempts < maxAttempts) {
    attempts++;
    const url = `${API_BASE}/v2/aggs/ticker/${symbol}/range/${actualMultiplier}/${actualTimespan}/${fmtDate(currentFrom)}/${fmtDate(range.to)}?adjusted=true&sort=asc&limit=50000&apiKey=${POLYGON_KEY}`;

    try {
      const resp = await fetch(url);
      if (!resp.ok) { console.warn(`API ${resp.status} for ${symbol}`); break; }
      const json = await resp.json();

      if (!json.results || json.results.length === 0) break;

      allResults = allResults.concat(json.results);

      // Check if we got all data or need another page
      if (json.results.length < 50000 || !json.next_url) break;

      // Move from date forward past last result
      const lastTimestamp = json.results[json.results.length - 1].t;
      currentFrom = new Date(lastTimestamp + 1);

      // Throttle to avoid rate limits
      await new Promise(r => setTimeout(r, 250));
    } catch (e) {
      console.error('Fetch error:', e);
      break;
    }
  }

  if (!allResults.length) return [];

  // Deduplicate by timestamp
  const seen = new Set();
  let bars = allResults.filter(bar => {
    const key = bar.t;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  }).map(bar => ({
    time: Math.floor(bar.t / 1000),
    open: bar.o, high: bar.h, low: bar.l, close: bar.c,
    volume: bar.v || 0, vwap: bar.vw || 0, trades: bar.n || 0
  }));

  // Resample if needed (quarter/year)
  if (needsResample && timespan === 'quarter') bars = resampleBars(bars, 'quarter');
  if (needsResample && timespan === 'year') bars = resampleBars(bars, 'year');

  console.log(`üìä ${symbol}: ${bars.length} bars loaded (${attempts} request${attempts>1?'s':''})`);
  return bars;
}

function resampleBars(bars, period) {
  if (!bars.length) return [];
  const groups = {};
  bars.forEach(bar => {
    const d = new Date(bar.time * 1000);
    let key;
    if (period === 'quarter') {
      const q = Math.floor(d.getMonth() / 3);
      key = `${d.getFullYear()}-Q${q}`;
    } else if (period === 'year') {
      key = `${d.getFullYear()}`;
    }
    if (!groups[key]) groups[key] = [];
    groups[key].push(bar);
  });

  return Object.values(groups).map(group => ({
    time: group[0].time,
    open: group[0].open,
    high: Math.max(...group.map(b => b.high)),
    low: Math.min(...group.map(b => b.low)),
    close: group[group.length - 1].close,
    volume: group.reduce((s, b) => s + b.volume, 0)
  }));
}

// Fetch previous day data for watchlist
async function fetchPrevDay(symbol) {
  try {
    const url = `${API_BASE}/v2/aggs/ticker/${symbol}/prev?adjusted=true&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results?.[0] || null;
  } catch(e) { return null; }
}

// Fetch snapshot for real-time price
async function fetchSnapshot(symbol) {
  try {
    const url = `${API_BASE}/v2/snapshot/locale/us/markets/stocks/tickers/${symbol}?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.ticker || null;
  } catch(e) { return null; }
}

// Fetch ticker financials (income, balance sheet, cash flow)
async function fetchFinancials(symbol) {
  try {
    const url = `${API_BASE}/vX/reference/financials?ticker=${symbol}&limit=20&sort=filing_date&order=desc&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

// Fetch dividends
async function fetchDividends(symbol) {
  try {
    const url = `${API_BASE}/v3/reference/dividends?ticker=${symbol}&limit=50&order=desc&sort=pay_date&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

// Fetch stock splits
async function fetchSplits(symbol) {
  try {
    const url = `${API_BASE}/v3/reference/splits?ticker=${symbol}&limit=20&order=desc&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

// Fetch related companies
async function fetchRelated(symbol) {
  try {
    const url = `${API_BASE}/v1/related-companies/${symbol}?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

// Fetch insider transactions
async function fetchInsiderTx(symbol) {
  try {
    const url = `${API_BASE}/v2/reference/news?ticker=${symbol}&limit=50&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

// Fetch market movers
async function fetchMovers(direction) {
  try {
    const url = `${API_BASE}/v2/snapshot/locale/us/markets/stocks/${direction}?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.tickers || [];
  } catch(e) { return []; }
}

// Fetch all snapshots for sector heatmap
async function fetchAllSnapshots() {
  try {
    const url = `${API_BASE}/v2/snapshot/locale/us/markets/stocks/tickers?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.tickers || [];
  } catch(e) { return []; }
}

// Fetch crypto snapshot
async function fetchCryptoSnapshot(symbol) {
  try {
    const url = `${API_BASE}/v2/snapshot/locale/global/markets/crypto/tickers/${symbol}?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.ticker || null;
  } catch(e) { return null; }
}

// Fetch SMA from Polygon technical indicators API
async function fetchPolygonSMA(symbol, period, timespan) {
  try {
    const url = `${API_BASE}/v1/indicators/sma/${symbol}?timespan=${timespan || 'day'}&window=${period}&limit=1000&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results?.values || [];
  } catch(e) { return []; }
}

// Fetch EMA from Polygon technical indicators API
async function fetchPolygonEMA(symbol, period, timespan) {
  try {
    const url = `${API_BASE}/v1/indicators/ema/${symbol}?timespan=${timespan || 'day'}&window=${period}&limit=1000&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results?.values || [];
  } catch(e) { return []; }
}

// Fetch MACD from Polygon
async function fetchPolygonMACD(symbol, timespan) {
  try {
    const url = `${API_BASE}/v1/indicators/macd/${symbol}?timespan=${timespan || 'day'}&short_window=12&long_window=26&signal_window=9&limit=1000&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results?.values || [];
  } catch(e) { return []; }
}

// Fetch RSI from Polygon
async function fetchPolygonRSI(symbol, timespan) {
  try {
    const url = `${API_BASE}/v1/indicators/rsi/${symbol}?timespan=${timespan || 'day'}&window=14&limit=1000&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results?.values || [];
  } catch(e) { return []; }
}

// Fetch ticker details v3
async function fetchTickerDetails(symbol) {
  try {
    const url = `${API_BASE}/v3/reference/tickers/${symbol}?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || null;
  } catch(e) { return null; }
}

// Fetch exchanges
async function fetchExchanges() {
  try {
    const url = `${API_BASE}/v3/reference/exchanges?asset_class=stocks&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

// Fetch market holidays
async function fetchMarketHolidays() {
  try {
    const url = `${API_BASE}/v1/marketstatus/upcoming?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    return await resp.json() || [];
  } catch(e) { return []; }
}

// Fetch daily open/close (exact OHLCV for any specific day)
async function fetchDailyOC(symbol, date) {
  try {
    const url = `${API_BASE}/v1/open-close/${symbol}/${date}?adjusted=true&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    return await resp.json();
  } catch(e) { return null; }
}

// Fetch grouped daily bars (all tickers for a date)
async function fetchGroupedDaily(date) {
  try {
    const url = `${API_BASE}/v2/aggs/grouped/locale/us/market/stocks/${date}?adjusted=true&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.results || [];
  } catch(e) { return []; }
}

async function loadSymbol(symbol, cellIdx) {
  if (cellIdx === undefined) cellIdx = STATE.activeCell;
  STATE.cells[cellIdx].symbol = symbol;
  if (cellIdx === STATE.activeCell) {
    STATE.symbol = symbol;
    document.getElementById('symTicker').textContent = symbol;
    document.getElementById('headerSym').textContent = symbol;
    const wm = document.getElementById(`watermark${cellIdx}`);
    if (wm) wm.textContent = STATE.settings.watermark ? symbol : '';
    document.getElementById('alertSym').value = symbol;
  }

  // Cell header
  const cellHeader = document.querySelector(`#cell${cellIdx} .cell-sym`);
  if (cellHeader) cellHeader.textContent = symbol;

  showLoading(cellIdx);
  const { multiplier, timespan } = STATE.timeframe;
  const data = await fetchBars(symbol, multiplier, timespan);
  hideLoading(cellIdx);

  if (data.length) {
    STATE.cells[cellIdx].data = data;
    STATE.allData = data;
    setChartData(cellIdx, data);
    updatePriceDisplay(data);
    loadNotes(symbol);
    applyIndicators(cellIdx);
    loadCompareOverlays(cellIdx);
    checkAlerts(data);
    addEarningsMarkers(cellIdx, data);

    // Show data stats
    const first = new Date(data[0].time * 1000).toLocaleDateString();
    const last = new Date(data[data.length-1].time * 1000).toLocaleDateString();
    toast(`${symbol}: ${data.length.toLocaleString()} bars loaded (${first} ‚Üí ${last})`, 'info');
  } else {
    toast(`No data for ${symbol}`, 'error');
  }
}

// Add earnings date markers on chart
async function addEarningsMarkers(cellIdx, data) {
  const cell = STATE.cells[cellIdx];
  if (!cell.chart || !cell.series) return;
  // Fetch financials to get earnings dates
  try {
    const financials = await fetchFinancials(STATE.cells[cellIdx].symbol);
    if (!financials.length) return;
    const markers = [];
    financials.forEach(f => {
      if (!f.filing_date) return;
      const t = Math.floor(new Date(f.filing_date).getTime() / 1000);
      // Find closest bar
      const bar = data.find(d => Math.abs(d.time - t) < 86400 * 3);
      if (bar) {
        markers.push({
          time: bar.time,
          position: 'belowBar',
          color: '#f7a21b',
          shape: 'square',
          text: 'E'
        });
      }
    });
    if (markers.length) cell.series.setMarkers(markers.sort((a,b) => a.time - b.time));
  } catch(e) {}
}

function setChartData(cellIdx, data) {
  const cell = STATE.cells[cellIdx];
  if (!cell.chart || !cell.series) return;

  let chartData;
  const ct = STATE.chartType;
  if (ct === 'heikin') {
    chartData = calcHeikinAshi(data);
  } else if (ct === 'renko') {
    chartData = calcRenko(data);
  } else if (ct === 'linebreak') {
    chartData = calcLineBreak(data);
  } else if (ct === 'line' || ct === 'area' || ct === 'baseline' || ct === 'stepline') {
    chartData = data.map(d => ({ time: d.time, value: d.close }));
  } else if (ct === 'hlcarea') {
    // HLC uses line series with high/low bands - use close for main, render bands via indicators
    chartData = data.map(d => ({ time: d.time, value: d.close }));
  } else if (ct === 'columns') {
    chartData = data.map(d => ({
      time: d.time, value: d.close - d.open,
      color: d.close >= d.open ? 'rgba(38,166,154,.8)' : 'rgba(239,83,80,.8)'
    }));
  } else {
    chartData = data;
  }
  cell.series.setData(chartData);

  // HLC Area bands
  if (ct === 'hlcarea' && cell.chart) {
    // Remove old HLC bands
    if (cell.indicatorSeries['hlc_high']) { cell.chart.removeSeries(cell.indicatorSeries['hlc_high']); delete cell.indicatorSeries['hlc_high']; }
    if (cell.indicatorSeries['hlc_low']) { cell.chart.removeSeries(cell.indicatorSeries['hlc_low']); delete cell.indicatorSeries['hlc_low']; }

    const highSeries = cell.chart.addLineSeries({ color: 'rgba(38,166,154,.3)', lineWidth: 1, priceScaleId: 'right', lastValueVisible: false, priceLineVisible: false });
    highSeries.setData(data.map(d => ({ time: d.time, value: d.high })));
    cell.indicatorSeries['hlc_high'] = highSeries;

    const lowSeries = cell.chart.addLineSeries({ color: 'rgba(239,83,80,.3)', lineWidth: 1, priceScaleId: 'right', lastValueVisible: false, priceLineVisible: false });
    lowSeries.setData(data.map(d => ({ time: d.time, value: d.low })));
    cell.indicatorSeries['hlc_low'] = lowSeries;
  }

  if (cell.volumeSeries && STATE.settings.volume) {
    cell.volumeSeries.setData(data.map(d => ({
      time: d.time, value: d.volume,
      color: d.close >= d.open ? 'rgba(38,166,154,.4)' : 'rgba(239,83,80,.4)'
    })));
  }

  // Auto-detect candlestick patterns
  if (STATE.settings.showPatterns !== false && (ct === 'candles' || ct === 'heikin' || ct === 'hollow')) {
    const markers = detectCandlestickPatterns(data);
    if (markers.length && cell.series) {
      const existing = cell.series.markers?.() || [];
      cell.series.setMarkers([...existing, ...markers].sort((a,b) => a.time - b.time));
    }
  }

  // Auto-detect support/resistance
  if (STATE.settings.autoSR !== false) {
    detectSupportResistance(cellIdx, data);
  }

  // Show data stats bar
  updateDataStatsBar(data);
}

// ==========================================
// RENKO CHART CALCULATION
// ==========================================
function calcRenko(data, boxSize) {
  if (!data.length) return [];
  // Auto-calculate box size as ATR(14) if not specified
  if (!boxSize) {
    const atr = calcATR(data, 14);
    boxSize = atr.length ? atr[atr.length - 1].value : (data[data.length-1].close * 0.01);
    boxSize = Math.max(boxSize, 0.01);
  }

  const bricks = [];
  let lastClose = data[0].close;
  let direction = 0; // 0 = none, 1 = up, -1 = down

  for (let i = 1; i < data.length; i++) {
    const close = data[i].close;
    const diff = close - lastClose;

    if (Math.abs(diff) >= boxSize) {
      const numBricks = Math.floor(Math.abs(diff) / boxSize);
      const dir = diff > 0 ? 1 : -1;

      for (let b = 0; b < numBricks; b++) {
        const open = lastClose + (dir * b * boxSize);
        const brickClose = open + (dir * boxSize);
        bricks.push({
          time: data[i].time,
          open: Math.min(open, brickClose),
          high: Math.max(open, brickClose),
          low: Math.min(open, brickClose),
          close: dir > 0 ? Math.max(open, brickClose) : Math.min(open, brickClose)
        });
      }
      lastClose = lastClose + (dir * numBricks * boxSize);
      direction = dir;
    }
  }

  // Deduplicate by time
  const seen = new Set();
  return bricks.filter(b => {
    if (seen.has(b.time)) return false;
    seen.add(b.time);
    return true;
  });
}

// ==========================================
// LINE BREAK CHART CALCULATION
// ==========================================
function calcLineBreak(data, lines) {
  lines = lines || 3;
  if (!data.length) return [];
  const result = [{ time: data[0].time, open: data[0].open, high: data[0].high, low: data[0].low, close: data[0].close }];

  for (let i = 1; i < data.length; i++) {
    const close = data[i].close;
    const lastBar = result[result.length - 1];
    const lookback = result.slice(-lines);
    const highestClose = Math.max(...lookback.map(b => Math.max(b.open, b.close)));
    const lowestClose = Math.min(...lookback.map(b => Math.min(b.open, b.close)));

    if (close > highestClose) {
      result.push({ time: data[i].time, open: lastBar.close, high: close, low: Math.min(lastBar.close, close), close });
    } else if (close < lowestClose) {
      result.push({ time: data[i].time, open: lastBar.close, high: Math.max(lastBar.close, close), low: close, close });
    }
  }
  return result;
}

// ==========================================
// CANDLESTICK PATTERN RECOGNITION
// ==========================================
function detectCandlestickPatterns(data) {
  const markers = [];
  if (data.length < 5) return markers;

  for (let i = 2; i < data.length; i++) {
    const c = data[i], p = data[i-1], pp = data[i-2];
    const body = Math.abs(c.close - c.open);
    const range = c.high - c.low;
    const upperWick = c.high - Math.max(c.open, c.close);
    const lowerWick = Math.min(c.open, c.close) - c.low;
    const bullish = c.close > c.open;
    const prevBody = Math.abs(p.close - p.open);
    const prevBullish = p.close > p.open;

    // Doji (body < 10% of range)
    if (body < range * 0.1 && range > 0) {
      markers.push({ time: c.time, position: 'aboveBar', color: '#f7a21b', shape: 'circle', text: 'D' });
      continue;
    }

    // Hammer (long lower wick, small body at top, in downtrend)
    if (lowerWick > body * 2 && upperWick < body * 0.5 && i >= 3) {
      const downtrend = data[i-3].close > data[i-1].close;
      if (downtrend) {
        markers.push({ time: c.time, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: 'H' });
        continue;
      }
    }

    // Shooting Star (long upper wick, small body at bottom, in uptrend)
    if (upperWick > body * 2 && lowerWick < body * 0.5 && i >= 3) {
      const uptrend = data[i-3].close < data[i-1].close;
      if (uptrend) {
        markers.push({ time: c.time, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: 'SS' });
        continue;
      }
    }

    // Bullish Engulfing
    if (bullish && !prevBullish && c.open <= p.close && c.close >= p.open && body > prevBody * 1.2) {
      markers.push({ time: c.time, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: 'BE' });
      continue;
    }

    // Bearish Engulfing
    if (!bullish && prevBullish && c.open >= p.close && c.close <= p.open && body > prevBody * 1.2) {
      markers.push({ time: c.time, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: 'SE' });
      continue;
    }

    // Morning Star (3-candle bullish reversal)
    if (i >= 2) {
      const ppBody = Math.abs(pp.close - pp.open);
      const ppBearish = pp.close < pp.open;
      const smallMiddle = prevBody < ppBody * 0.3;
      if (ppBearish && smallMiddle && bullish && c.close > (pp.open + pp.close) / 2) {
        markers.push({ time: c.time, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: 'MS' });
        continue;
      }
    }

    // Evening Star (3-candle bearish reversal)
    if (i >= 2) {
      const ppBody2 = Math.abs(pp.close - pp.open);
      const ppBullish = pp.close > pp.open;
      const smallMiddle2 = prevBody < ppBody2 * 0.3;
      if (ppBullish && smallMiddle2 && !bullish && c.close < (pp.open + pp.close) / 2) {
        markers.push({ time: c.time, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: 'ES' });
        continue;
      }
    }

    // Three White Soldiers
    if (i >= 2 && bullish && prevBullish && pp.close > pp.open) {
      if (c.close > p.close && p.close > pp.close && body > range * 0.5 && prevBody > (p.high - p.low) * 0.5) {
        markers.push({ time: c.time, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: '3WS' });
        continue;
      }
    }

    // Three Black Crows
    if (i >= 2 && !bullish && !prevBullish && pp.close < pp.open) {
      if (c.close < p.close && p.close < pp.close && body > range * 0.5) {
        markers.push({ time: c.time, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: '3BC' });
        continue;
      }
    }

    // Piercing Line
    if (bullish && !prevBullish && c.open < p.low && c.close > (p.open + p.close) / 2 && c.close < p.open) {
      markers.push({ time: c.time, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: 'PL' });
      continue;
    }

    // Dark Cloud Cover
    if (!bullish && prevBullish && c.open > p.high && c.close < (p.open + p.close) / 2 && c.close > p.close) {
      markers.push({ time: c.time, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: 'DC' });
      continue;
    }

    // Tweezer Top (same highs, reversal)
    if (i >= 1 && Math.abs(c.high - p.high) < range * 0.05 && prevBullish && !bullish) {
      markers.push({ time: c.time, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: 'TT' });
      continue;
    }

    // Tweezer Bottom
    if (i >= 1 && Math.abs(c.low - p.low) < range * 0.05 && !prevBullish && bullish) {
      markers.push({ time: c.time, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: 'TB' });
      continue;
    }
  }

  // Limit to last 100 patterns to avoid clutter
  return markers.slice(-100);
}

// ==========================================
// AUTO SUPPORT/RESISTANCE DETECTION
// ==========================================
function detectSupportResistance(cellIdx, data) {
  const cell = STATE.cells[cellIdx];
  if (!cell.chart) return;

  // Remove old S/R lines
  Object.keys(cell.indicatorSeries).filter(k => k.startsWith('sr_')).forEach(k => {
    cell.chart.removeSeries(cell.indicatorSeries[k]);
    delete cell.indicatorSeries[k];
  });

  if (data.length < 30) return;

  // Find swing highs and lows (pivot points)
  const lookback = 10;
  const swingHighs = [], swingLows = [];

  for (let i = lookback; i < data.length - lookback; i++) {
    let isSwingHigh = true, isSwingLow = true;
    for (let j = 1; j <= lookback; j++) {
      if (data[i].high <= data[i-j].high || data[i].high <= data[i+j].high) isSwingHigh = false;
      if (data[i].low >= data[i-j].low || data[i].low >= data[i+j].low) isSwingLow = false;
    }
    if (isSwingHigh) swingHighs.push(data[i].high);
    if (isSwingLow) swingLows.push(data[i].low);
  }

  // Cluster nearby levels (within 1% of each other)
  function clusterLevels(levels) {
    if (!levels.length) return [];
    levels.sort((a, b) => a - b);
    const clusters = [];
    let cluster = [levels[0]];

    for (let i = 1; i < levels.length; i++) {
      if ((levels[i] - cluster[0]) / cluster[0] < 0.01) {
        cluster.push(levels[i]);
      } else {
        if (cluster.length >= 2) clusters.push(cluster.reduce((s, v) => s + v, 0) / cluster.length);
        cluster = [levels[i]];
      }
    }
    if (cluster.length >= 2) clusters.push(cluster.reduce((s, v) => s + v, 0) / cluster.length);
    return clusters;
  }

  const resistanceLevels = clusterLevels(swingHighs).slice(-3);
  const supportLevels = clusterLevels(swingLows).slice(-3);

  // Draw resistance lines
  resistanceLevels.forEach((level, i) => {
    const s = cell.chart.addLineSeries({
      color: 'rgba(239,83,80,.35)', lineWidth: 1, lineStyle: 2,
      priceScaleId: 'right', lastValueVisible: true, priceLineVisible: false, title: `R${i+1}`
    });
    s.setData(data.map(d => ({ time: d.time, value: level })));
    cell.indicatorSeries['sr_r' + i] = s;
  });

  // Draw support lines
  supportLevels.forEach((level, i) => {
    const s = cell.chart.addLineSeries({
      color: 'rgba(38,166,154,.35)', lineWidth: 1, lineStyle: 2,
      priceScaleId: 'right', lastValueVisible: true, priceLineVisible: false, title: `S${i+1}`
    });
    s.setData(data.map(d => ({ time: d.time, value: level })));
    cell.indicatorSeries['sr_s' + i] = s;
  });
}

// ==========================================
// DATA STATISTICS BAR
// ==========================================
function updateDataStatsBar(data) {
  let bar = document.getElementById('dataStatsBar');
  if (!bar) {
    bar = document.createElement('div');
    bar.id = 'dataStatsBar';
    bar.style.cssText = 'display:flex;align-items:center;gap:16px;padding:2px 12px;background:var(--bg2);border-top:1px solid var(--brd);font-size:10px;font-family:"JetBrains Mono",monospace;color:var(--t3);min-height:22px;overflow-x:auto;white-space:nowrap';
    const chartArea = document.querySelector('.chart-area');
    if (chartArea) chartArea.appendChild(bar);
  }

  if (!data || data.length < 2) { bar.innerHTML = ''; return; }

  const last = data[data.length - 1];
  const len = data.length;

  // ATR(14)
  const atrData = calcATR(data, 14);
  const atr = atrData.length ? atrData[atrData.length - 1].value : 0;

  // Average volume (20)
  const avgVol = len >= 20 ? data.slice(-20).reduce((s, d) => s + d.volume, 0) / 20 : 0;

  // Relative volume
  const relVol = avgVol > 0 ? (last.volume / avgVol).toFixed(2) : '-';

  // Volatility (20-day annualized)
  let vol20 = '-';
  if (len >= 21) {
    const returns = [];
    for (let i = len - 20; i < len; i++) {
      returns.push(Math.log(data[i].close / data[i-1].close));
    }
    const mean = returns.reduce((s, r) => s + r, 0) / returns.length;
    const variance = returns.reduce((s, r) => s + (r - mean) ** 2, 0) / (returns.length - 1);
    vol20 = (Math.sqrt(variance) * Math.sqrt(252) * 100).toFixed(1);
  }

  // RSI(14) current
  const rsiData = calcRSI(data, 14);
  const rsi = rsiData.length ? rsiData[rsiData.length - 1].value.toFixed(1) : '-';

  // SMA 50/200 status
  const sma50 = len >= 50 ? data.slice(-50).reduce((s, d) => s + d.close, 0) / 50 : 0;
  const sma200 = len >= 200 ? data.slice(-200).reduce((s, d) => s + d.close, 0) / 200 : 0;
  const goldenCross = sma50 > sma200 && sma200 > 0;

  // 52W High/Low
  const yearData = data.filter(d => d.time >= last.time - 365 * 86400);
  const high52 = yearData.length ? Math.max(...yearData.map(d => d.high)) : 0;
  const low52 = yearData.length ? Math.min(...yearData.map(d => d.low)) : 0;
  const pctFromHigh = high52 ? ((last.close - high52) / high52 * 100).toFixed(1) : '-';

  // Trend
  const trend = last.close > sma50 ? (last.close > sma200 ? '‚ñ≤ Strong Up' : '‚Üó Up') : (last.close < sma200 ? '‚ñº Strong Down' : '‚Üò Down');
  const trendColor = last.close > sma50 ? 'var(--green)' : 'var(--red)';

  const stats = [
    `<span>Bars: <b style="color:var(--t1)">${len.toLocaleString()}</b></span>`,
    `<span>ATR(14): <b style="color:var(--t1)">${atr.toFixed(2)}</b></span>`,
    `<span>RSI: <b style="color:${rsi>70?'var(--red)':rsi<30?'var(--green)':'var(--t1)'}">${rsi}</b></span>`,
    `<span>Vol: <b style="color:var(--t1)">${formatVol(last.volume)}</b></span>`,
    `<span>Avg Vol: <b style="color:var(--t1)">${formatVol(avgVol)}</b></span>`,
    `<span>Rel Vol: <b style="color:${relVol>1.5?'var(--green)':'var(--t1)'}">${relVol}x</b></span>`,
    `<span>œÉ(20): <b style="color:var(--t1)">${vol20}%</b></span>`,
    `<span>52WH: <b style="color:var(--t1)">$${high52.toFixed(2)}</b> <small>(${pctFromHigh}%)</small></span>`,
    `<span>52WL: <b style="color:var(--t1)">$${low52.toFixed(2)}</b></span>`,
    `<span>Trend: <b style="color:${trendColor}">${trend}</b></span>`,
    sma50 > 0 && sma200 > 0 ? `<span style="color:${goldenCross?'var(--green)':'var(--red)'}"><b>${goldenCross ? '‚òÖ Golden Cross' : '‚ú¶ Death Cross'}</b></span>` : '',
  ].filter(Boolean);

  bar.innerHTML = stats.join('<span style="color:var(--bg4)">‚îÇ</span>');
}

function calcHeikinAshi(data) {
  if (!data.length) return [];
  const ha = [];
  for (let i = 0; i < data.length; i++) {
    const d = data[i];
    const prev = ha[i - 1] || d;
    const close = (d.open + d.high + d.low + d.close) / 4;
    const open = (prev.open + prev.close) / 2;
    ha.push({ time: d.time, open, high: Math.max(d.high, open, close), low: Math.min(d.low, open, close), close });
  }
  return ha;
}

function updatePriceDisplay(data) {
  if (!data.length) return;
  const last = data[data.length - 1];
  const prev = data.length > 1 ? data[data.length - 2] : last;
  const chg = ((last.close - prev.close) / prev.close * 100).toFixed(2);
  const symPrice = document.getElementById('symPrice');
  const symChg = document.getElementById('symChg');
  symPrice.textContent = '$' + last.close.toFixed(2);
  symChg.textContent = (chg >= 0 ? '+' : '') + chg + '%';
  symChg.className = 'chg ' + (chg >= 0 ? 'up' : 'dn');

  // Performance
  if (data.length >= 2) {
    const d1 = ((last.close - prev.close) / prev.close * 100).toFixed(2);
    document.getElementById('dailyPerf').textContent = 'D: ' + (d1 >= 0 ? '+' : '') + d1 + '%';
    document.getElementById('dailyPerf').className = 'perf mono ' + (d1 >= 0 ? 'up' : 'dn');
  }
  if (data.length >= 5) {
    const w = ((last.close - data[Math.max(0, data.length - 6)].close) / data[Math.max(0, data.length - 6)].close * 100).toFixed(2);
    document.getElementById('weekPerf').textContent = 'W: ' + (w >= 0 ? '+' : '') + w + '%';
    document.getElementById('weekPerf').className = 'perf mono ' + (w >= 0 ? 'up' : 'dn');
  }
  if (data.length >= 22) {
    const m = ((last.close - data[Math.max(0, data.length - 23)].close) / data[Math.max(0, data.length - 23)].close * 100).toFixed(2);
    document.getElementById('monthPerf').textContent = 'M: ' + (m >= 0 ? '+' : '') + m + '%';
    document.getElementById('monthPerf').className = 'perf mono ' + (m >= 0 ? 'up' : 'dn');
  }
}

function showLoading(cellIdx) {
  const container = document.getElementById(`chartDiv${cellIdx}`);
  if (!container) return;
  let overlay = container.querySelector('.loading-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.innerHTML = '<div class="spinner"></div>';
    container.appendChild(overlay);
  }
  overlay.style.display = 'flex';
}
function hideLoading(cellIdx) {
  const container = document.getElementById(`chartDiv${cellIdx}`);
  if (!container) return;
  const overlay = container.querySelector('.loading-overlay');
  if (overlay) overlay.style.display = 'none';
}

// ==========================================
// INDICATOR CALCULATIONS
// ==========================================
function calcSMA(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let sum = 0;
    for (let j = i - period + 1; j <= i; j++) sum += data[j].close;
    result.push({ time: data[i].time, value: sum / period });
  }
  return result;
}

function calcEMA(data, period) {
  const result = [];
  const k = 2 / (period + 1);
  let ema = data[0].close;
  for (let i = 0; i < data.length; i++) {
    ema = data[i].close * k + ema * (1 - k);
    if (i >= period - 1) result.push({ time: data[i].time, value: ema });
  }
  return result;
}

function calcWMA(data, period) {
  const result = [];
  const denom = period * (period + 1) / 2;
  for (let i = period - 1; i < data.length; i++) {
    let sum = 0;
    for (let j = 0; j < period; j++) sum += data[i - period + 1 + j].close * (j + 1);
    result.push({ time: data[i].time, value: sum / denom });
  }
  return result;
}

function calcDEMA(data, period) {
  const ema1 = calcEMA(data, period);
  const ema2Data = ema1.map((e, i) => ({ time: e.time, close: e.value, open: e.value, high: e.value, low: e.value }));
  const ema2 = calcEMA(ema2Data, period);
  const result = [];
  const offset = ema1.length - ema2.length;
  for (let i = 0; i < ema2.length; i++) {
    result.push({ time: ema2[i].time, value: 2 * ema1[i + offset].value - ema2[i].value });
  }
  return result;
}

function calcHullMA(data, period) {
  const halfWMA = calcWMA(data, Math.floor(period / 2));
  const fullWMA = calcWMA(data, period);
  const minLen = Math.min(halfWMA.length, fullWMA.length);
  const diff = [];
  for (let i = 0; i < minLen; i++) {
    const hIdx = halfWMA.length - minLen + i;
    const fIdx = fullWMA.length - minLen + i;
    diff.push({ time: fullWMA[fIdx].time, close: 2 * halfWMA[hIdx].value - fullWMA[fIdx].value, open: 0, high: 0, low: 0 });
  }
  return calcWMA(diff, Math.floor(Math.sqrt(period)));
}

function calcBB(data, period, mult) {
  const upper = [], middle = [], lower = [];
  for (let i = period - 1; i < data.length; i++) {
    let sum = 0, sq = 0;
    for (let j = i - period + 1; j <= i; j++) { sum += data[j].close; sq += data[j].close ** 2; }
    const avg = sum / period;
    const std = Math.sqrt(sq / period - avg ** 2);
    middle.push({ time: data[i].time, value: avg });
    upper.push({ time: data[i].time, value: avg + mult * std });
    lower.push({ time: data[i].time, value: avg - mult * std });
  }
  return { upper, middle, lower };
}

function calcRSI(data, period) {
  const result = [];
  let avgGain = 0, avgLoss = 0;
  for (let i = 1; i <= period; i++) {
    const chg = data[i].close - data[i - 1].close;
    if (chg > 0) avgGain += chg; else avgLoss -= chg;
  }
  avgGain /= period; avgLoss /= period;
  result.push({ time: data[period].time, value: avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss) });
  for (let i = period + 1; i < data.length; i++) {
    const chg = data[i].close - data[i - 1].close;
    avgGain = (avgGain * (period - 1) + Math.max(chg, 0)) / period;
    avgLoss = (avgLoss * (period - 1) + Math.max(-chg, 0)) / period;
    result.push({ time: data[i].time, value: avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss) });
  }
  return result;
}

function calcMACD(data) {
  const ema12 = calcEMA(data, 12);
  const ema26 = calcEMA(data, 26);
  const macdLine = [], signal = [], histogram = [];
  const offset = ema12.length - ema26.length;
  const macdData = [];
  for (let i = 0; i < ema26.length; i++) {
    const val = ema12[i + offset].value - ema26[i].value;
    macdLine.push({ time: ema26[i].time, value: val });
    macdData.push({ time: ema26[i].time, close: val, open: val, high: val, low: val });
  }
  const sig = calcEMA(macdData, 9);
  const sigOffset = macdLine.length - sig.length;
  for (let i = 0; i < sig.length; i++) {
    signal.push({ time: sig[i].time, value: sig[i].value });
    histogram.push({ time: sig[i].time, value: macdLine[i + sigOffset].value - sig[i].value, color: macdLine[i + sigOffset].value - sig[i].value >= 0 ? 'rgba(38,166,154,.6)' : 'rgba(239,83,80,.6)' });
  }
  return { macdLine: macdLine.slice(sigOffset), signal, histogram };
}

function calcStochastic(data, kPeriod, kSmooth, dSmooth) {
  const k = [], d = [];
  for (let i = kPeriod - 1; i < data.length; i++) {
    let high = -Infinity, low = Infinity;
    for (let j = i - kPeriod + 1; j <= i; j++) { high = Math.max(high, data[j].high); low = Math.min(low, data[j].low); }
    const rawK = high === low ? 50 : (data[i].close - low) / (high - low) * 100;
    k.push({ time: data[i].time, value: rawK });
  }
  // Smooth K
  const kSmoothed = [];
  for (let i = kSmooth - 1; i < k.length; i++) {
    let sum = 0;
    for (let j = i - kSmooth + 1; j <= i; j++) sum += k[j].value;
    kSmoothed.push({ time: k[i].time, value: sum / kSmooth });
  }
  // D line
  for (let i = dSmooth - 1; i < kSmoothed.length; i++) {
    let sum = 0;
    for (let j = i - dSmooth + 1; j <= i; j++) sum += kSmoothed[j].value;
    d.push({ time: kSmoothed[i].time, value: sum / dSmooth });
  }
  return { k: kSmoothed, d };
}

function calcCCI(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let sum = 0;
    for (let j = i - period + 1; j <= i; j++) sum += (data[j].high + data[j].low + data[j].close) / 3;
    const avg = sum / period;
    let md = 0;
    for (let j = i - period + 1; j <= i; j++) md += Math.abs((data[j].high + data[j].low + data[j].close) / 3 - avg);
    md /= period;
    const tp = (data[i].high + data[i].low + data[i].close) / 3;
    result.push({ time: data[i].time, value: md === 0 ? 0 : (tp - avg) / (0.015 * md) });
  }
  return result;
}

function calcWilliamsR(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let high = -Infinity, low = Infinity;
    for (let j = i - period + 1; j <= i; j++) { high = Math.max(high, data[j].high); low = Math.min(low, data[j].low); }
    result.push({ time: data[i].time, value: high === low ? -50 : (high - data[i].close) / (high - low) * -100 });
  }
  return result;
}

function calcROC(data, period) {
  return data.slice(period).map((d, i) => ({ time: d.time, value: (d.close - data[i].close) / data[i].close * 100 }));
}

function calcMFI(data, period) {
  const result = [];
  for (let i = period; i < data.length; i++) {
    let posFlow = 0, negFlow = 0;
    for (let j = i - period + 1; j <= i; j++) {
      const tp = (data[j].high + data[j].low + data[j].close) / 3;
      const prevTp = (data[j-1].high + data[j-1].low + data[j-1].close) / 3;
      const mf = tp * data[j].volume;
      if (tp > prevTp) posFlow += mf; else negFlow += mf;
    }
    result.push({ time: data[i].time, value: negFlow === 0 ? 100 : 100 - 100 / (1 + posFlow / negFlow) });
  }
  return result;
}

function calcATR(data, period) {
  const result = [];
  let atr = 0;
  for (let i = 1; i < data.length; i++) {
    const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i-1].close), Math.abs(data[i].low - data[i-1].close));
    if (i <= period) { atr += tr; if (i === period) { atr /= period; result.push({ time: data[i].time, value: atr }); } }
    else { atr = (atr * (period - 1) + tr) / period; result.push({ time: data[i].time, value: atr }); }
  }
  return result;
}

function calcKeltner(data, period, mult) {
  const ema = calcEMA(data, period);
  const atr = calcATR(data, period);
  const upper = [], lower = [];
  const atrMap = {};
  atr.forEach(a => atrMap[a.time] = a.value);
  ema.forEach(e => {
    const a = atrMap[e.time];
    if (a !== undefined) {
      upper.push({ time: e.time, value: e.value + mult * a });
      lower.push({ time: e.time, value: e.value - mult * a });
    }
  });
  return { upper, middle: ema, lower };
}

function calcDonchian(data, period) {
  const upper = [], lower = [], middle = [];
  for (let i = period - 1; i < data.length; i++) {
    let high = -Infinity, low = Infinity;
    for (let j = i - period + 1; j <= i; j++) { high = Math.max(high, data[j].high); low = Math.min(low, data[j].low); }
    upper.push({ time: data[i].time, value: high });
    lower.push({ time: data[i].time, value: low });
    middle.push({ time: data[i].time, value: (high + low) / 2 });
  }
  return { upper, middle, lower };
}

function calcVWAP(data) {
  let cumVol = 0, cumTP = 0;
  return data.map(d => {
    const tp = (d.high + d.low + d.close) / 3;
    cumVol += d.volume; cumTP += tp * d.volume;
    return { time: d.time, value: cumVol === 0 ? tp : cumTP / cumVol };
  });
}

function calcOBV(data) {
  let obv = 0;
  return data.map((d, i) => {
    if (i > 0) obv += d.close > data[i-1].close ? d.volume : d.close < data[i-1].close ? -d.volume : 0;
    return { time: d.time, value: obv };
  });
}

function calcAD(data) {
  let ad = 0;
  return data.map(d => {
    const mfm = d.high === d.low ? 0 : ((d.close - d.low) - (d.high - d.close)) / (d.high - d.low);
    ad += mfm * d.volume;
    return { time: d.time, value: ad };
  });
}

function calcCMF(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let mfv = 0, vol = 0;
    for (let j = i - period + 1; j <= i; j++) {
      const mfm = data[j].high === data[j].low ? 0 : ((data[j].close - data[j].low) - (data[j].high - data[j].close)) / (data[j].high - data[j].low);
      mfv += mfm * data[j].volume; vol += data[j].volume;
    }
    result.push({ time: data[i].time, value: vol === 0 ? 0 : mfv / vol });
  }
  return result;
}

function calcPSAR(data, af0, afMax) {
  const result = [];
  let bull = true, sar = data[0].low, ep = data[0].high, af = af0;
  for (let i = 1; i < data.length; i++) {
    const prevSar = sar;
    sar = prevSar + af * (ep - prevSar);
    if (bull) {
      sar = Math.min(sar, data[i-1].low, i > 1 ? data[i-2].low : data[i-1].low);
      if (data[i].low < sar) { bull = false; sar = ep; ep = data[i].low; af = af0; }
      else { if (data[i].high > ep) { ep = data[i].high; af = Math.min(af + af0, afMax); } }
    } else {
      sar = Math.max(sar, data[i-1].high, i > 1 ? data[i-2].high : data[i-1].high);
      if (data[i].high > sar) { bull = true; sar = ep; ep = data[i].high; af = af0; }
      else { if (data[i].low < ep) { ep = data[i].low; af = Math.min(af + af0, afMax); } }
    }
    result.push({ time: data[i].time, value: sar, color: bull ? '#26a69a' : '#ef5350' });
  }
  return result;
}

function calcIchimoku(data) {
  const conversion = [], base = [], spanA = [], spanB = [], lagging = [];
  const calcHL = (arr, start, period) => {
    let h = -Infinity, l = Infinity;
    for (let j = start - period + 1; j <= start; j++) {
      if (j >= 0 && j < arr.length) { h = Math.max(h, arr[j].high); l = Math.min(l, arr[j].low); }
    }
    return (h + l) / 2;
  };
  for (let i = 0; i < data.length; i++) {
    if (i >= 8) conversion.push({ time: data[i].time, value: calcHL(data, i, 9) });
    if (i >= 25) base.push({ time: data[i].time, value: calcHL(data, i, 26) });
    if (i >= 25 && i + 26 < data.length) {
      const conv = calcHL(data, i, 9);
      const bas = calcHL(data, i, 26);
      spanA.push({ time: data[i + 26].time, value: (conv + bas) / 2 });
    }
    if (i >= 51 && i + 26 < data.length) {
      spanB.push({ time: data[i + 26].time, value: calcHL(data, i, 52) });
    }
    if (i >= 26) lagging.push({ time: data[i - 26].time, value: data[i].close });
  }
  return { conversion, base, spanA, spanB, lagging };
}

function calcSuperTrend(data, period, multiplier) {
  const atr = calcATR(data, period);
  const result = [];
  const atrMap = {};
  atr.forEach(a => atrMap[a.time] = a.value);
  let trend = 1, up = 0, dn = 0;
  for (let i = period; i < data.length; i++) {
    const a = atrMap[data[i].time] || 0;
    const hl2 = (data[i].high + data[i].low) / 2;
    const newUp = hl2 - multiplier * a;
    const newDn = hl2 + multiplier * a;
    up = data[i-1].close > up ? Math.max(newUp, up) : newUp;
    dn = data[i-1].close < dn ? Math.min(newDn, dn) : newDn;
    if (data[i].close > dn) trend = 1;
    else if (data[i].close < up) trend = -1;
    result.push({ time: data[i].time, value: trend === 1 ? up : dn, color: trend === 1 ? '#26a69a' : '#ef5350' });
  }
  return result;
}

function calcDMI(data, period) {
  const plus = [], minus = [], adxLine = [];
  let plusDM = 0, minusDM = 0, trueRange = 0;
  for (let i = 1; i < data.length; i++) {
    const up = data[i].high - data[i-1].high;
    const dn = data[i-1].low - data[i].low;
    const pDM = up > dn && up > 0 ? up : 0;
    const mDM = dn > up && dn > 0 ? dn : 0;
    const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i-1].close), Math.abs(data[i].low - data[i-1].close));
    if (i <= period) { plusDM += pDM; minusDM += mDM; trueRange += tr; }
    else { plusDM = plusDM - plusDM / period + pDM; minusDM = minusDM - minusDM / period + mDM; trueRange = trueRange - trueRange / period + tr; }
    if (i >= period) {
      const pdi = trueRange === 0 ? 0 : plusDM / trueRange * 100;
      const mdi = trueRange === 0 ? 0 : minusDM / trueRange * 100;
      plus.push({ time: data[i].time, value: pdi });
      minus.push({ time: data[i].time, value: mdi });
      const dx = pdi + mdi === 0 ? 0 : Math.abs(pdi - mdi) / (pdi + mdi) * 100;
      adxLine.push({ time: data[i].time, value: dx });
    }
  }
  // Smooth ADX
  const adx = [];
  let adxSmooth = 0;
  for (let i = 0; i < adxLine.length; i++) {
    if (i < period) adxSmooth += adxLine[i].value;
    if (i === period - 1) { adxSmooth /= period; adx.push({ time: adxLine[i].time, value: adxSmooth }); }
    if (i >= period) { adxSmooth = (adxSmooth * (period - 1) + adxLine[i].value) / period; adx.push({ time: adxLine[i].time, value: adxSmooth }); }
  }
  return { plus, minus, adx };
}

function calcAroon(data, period) {
  const up = [], down = [];
  for (let i = period; i < data.length; i++) {
    let highIdx = 0, lowIdx = 0, high = -Infinity, low = Infinity;
    for (let j = 0; j <= period; j++) {
      if (data[i - j].high > high) { high = data[i - j].high; highIdx = j; }
      if (data[i - j].low < low) { low = data[i - j].low; lowIdx = j; }
    }
    up.push({ time: data[i].time, value: (period - highIdx) / period * 100 });
    down.push({ time: data[i].time, value: (period - lowIdx) / period * 100 });
  }
  return { up, down };
}

function calcAO(data) {
  const result = [];
  for (let i = 33; i < data.length; i++) {
    let s5 = 0, s34 = 0;
    for (let j = i - 4; j <= i; j++) s5 += (data[j].high + data[j].low) / 2;
    for (let j = i - 33; j <= i; j++) s34 += (data[j].high + data[j].low) / 2;
    const val = s5 / 5 - s34 / 34;
    const prev = result.length > 0 ? result[result.length - 1].value : 0;
    result.push({ time: data[i].time, value: val, color: val >= prev ? 'rgba(38,166,154,.7)' : 'rgba(239,83,80,.7)' });
  }
  return result;
}

function calcPivots(data) {
  if (data.length < 2) return {};
  const prev = data[data.length - 2];
  const pp = (prev.high + prev.low + prev.close) / 3;
  return {
    pp: data.map(d => ({ time: d.time, value: pp })),
    r1: data.map(d => ({ time: d.time, value: 2 * pp - prev.low })),
    r2: data.map(d => ({ time: d.time, value: pp + (prev.high - prev.low) })),
    r3: data.map(d => ({ time: d.time, value: prev.high + 2 * (pp - prev.low) })),
    s1: data.map(d => ({ time: d.time, value: 2 * pp - prev.high })),
    s2: data.map(d => ({ time: d.time, value: pp - (prev.high - prev.low) })),
    s3: data.map(d => ({ time: d.time, value: prev.low - 2 * (prev.high - pp) })),
  };
}

function calcLinReg(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let sx = 0, sy = 0, sxy = 0, sx2 = 0;
    for (let j = 0; j < period; j++) {
      sx += j; sy += data[i - period + 1 + j].close;
      sxy += j * data[i - period + 1 + j].close; sx2 += j * j;
    }
    const b = (period * sxy - sx * sy) / (period * sx2 - sx * sx);
    const a = (sy - b * sx) / period;
    result.push({ time: data[i].time, value: a + b * (period - 1) });
  }
  return result;
}

function calcLinRegSlope(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let sx = 0, sy = 0, sxy = 0, sx2 = 0;
    for (let j = 0; j < period; j++) {
      sx += j; sy += data[i - period + 1 + j].close;
      sxy += j * data[i - period + 1 + j].close; sx2 += j * j;
    }
    result.push({ time: data[i].time, value: (period * sxy - sx * sy) / (period * sx2 - sx * sx) });
  }
  return result;
}

// ALMA - Arnaud Legoux Moving Average
function calcALMA(data, period, offset, sigma) {
  offset = offset || 0.85; sigma = sigma || 6;
  const result = [], m = Math.floor(offset * (period - 1)), s = period / sigma;
  for (let i = period - 1; i < data.length; i++) {
    let sum = 0, wSum = 0;
    for (let j = 0; j < period; j++) {
      const w = Math.exp(-((j - m) * (j - m)) / (2 * s * s));
      sum += data[i - period + 1 + j].close * w; wSum += w;
    }
    result.push({ time: data[i].time, value: sum / wSum });
  }
  return result;
}

// Smoothed Moving Average
function calcSMMA(data, period) {
  const result = [];
  let sum = 0;
  for (let i = 0; i < data.length; i++) {
    if (i < period) { sum += data[i].close; if (i === period - 1) result.push({ time: data[i].time, value: sum / period }); }
    else { const prev = result[result.length - 1].value; result.push({ time: data[i].time, value: (prev * (period - 1) + data[i].close) / period }); }
  }
  return result;
}

// LSMA - Least Squares Moving Average (same as LinReg)
function calcLSMA(data, period) { return calcLinReg(data, period); }

// McGinley Dynamic
function calcMcGinley(data, period) {
  const result = []; let md = data[0]?.close || 0;
  for (let i = 0; i < data.length; i++) {
    md = md + (data[i].close - md) / (period * Math.pow(data[i].close / md, 4));
    if (i >= period - 1) result.push({ time: data[i].time, value: md });
  }
  return result;
}

// VWMA - Volume Weighted Moving Average
function calcVWMA(data, period) {
  const result = [];
  for (let i = period - 1; i < data.length; i++) {
    let pv = 0, v = 0;
    for (let j = 0; j < period; j++) { pv += data[i-j].close * data[i-j].volume; v += data[i-j].volume; }
    result.push({ time: data[i].time, value: v > 0 ? pv / v : data[i].close });
  }
  return result;
}

// MA Envelope
function calcEnvelope(data, period, pct) {
  const sma = calcSMA(data, period);
  pct = pct || 0.025;
  return { upper: sma.map(s => ({time:s.time, value:s.value*(1+pct)})), middle: sma, lower: sma.map(s => ({time:s.time, value:s.value*(1-pct)})) };
}

// MA Channel (High/Low)
function calcMAChannel(data, period) {
  const upper = [], lower = [];
  for (let i = period - 1; i < data.length; i++) {
    let sh = 0, sl = 0;
    for (let j = 0; j < period; j++) { sh += data[i-j].high; sl += data[i-j].low; }
    upper.push({time:data[i].time, value:sh/period}); lower.push({time:data[i].time, value:sl/period});
  }
  return { upper, lower };
}

// Guppy Multiple Moving Average
function calcGuppy(data) {
  return {
    short: [3,5,8,10,12,15].map(p => calcEMA(data, p)),
    long: [30,35,40,45,50,60].map(p => calcEMA(data, p))
  };
}

// Williams Alligator
function calcAlligator(data) {
  const jaw = calcSMMA(data, 13).map((v,i,a) => i >= 8 ? {time:a[i].time, value:a[i-8]?.value||v.value} : null).filter(Boolean);
  const teeth = calcSMMA(data, 8).map((v,i,a) => i >= 5 ? {time:a[i].time, value:a[i-5]?.value||v.value} : null).filter(Boolean);
  const lips = calcSMMA(data, 5).map((v,i,a) => i >= 3 ? {time:a[i].time, value:a[i-3]?.value||v.value} : null).filter(Boolean);
  return { jaw, teeth, lips };
}

// Bollinger %B
function calcBBPct(data, period, mult) {
  const bb = calcBB(data, period || 20, mult || 2);
  const result = [];
  for (let i = 0; i < bb.upper.length; i++) {
    const range = bb.upper[i].value - bb.lower[i].value;
    const closeVal = data[period - 1 + i]?.close || 0;
    result.push({ time: bb.upper[i].time, value: range > 0 ? (closeVal - bb.lower[i].value) / range : 0 });
  }
  return result;
}

// Bollinger Bandwidth
function calcBBWidth(data, period, mult) {
  const bb = calcBB(data, period || 20, mult || 2);
  return bb.upper.map((u,i) => ({ time:u.time, value: bb.middle[i].value > 0 ? (u.value - bb.lower[i].value) / bb.middle[i].value : 0 }));
}

// Historical Volatility
function calcHistVol(data, period) {
  const result = [];
  for (let i = period; i < data.length; i++) {
    let sum = 0;
    for (let j = 1; j <= period; j++) {
      const ret = Math.log(data[i-period+j].close / data[i-period+j-1].close);
      sum += ret * ret;
    }
    result.push({ time: data[i].time, value: Math.sqrt(sum / period) * Math.sqrt(252) * 100 });
  }
  return result;
}

// Chaikin Volatility
function calcChaikinVol(data, ema1, ema2) {
  ema1 = ema1 || 10; ema2 = ema2 || 10;
  const hlDiff = data.map(d => ({time:d.time, close: d.high - d.low}));
  const ema = calcEMA(hlDiff, ema1);
  const result = [];
  for (let i = ema2; i < ema.length; i++) {
    const prev = ema[i-ema2].value;
    result.push({ time:ema[i].time, value: prev !== 0 ? ((ema[i].value - prev) / prev) * 100 : 0 });
  }
  return result;
}

// Stochastic RSI
function calcStochRSI(data, rsiPeriod, stochPeriod, kSmooth, dSmooth) {
  rsiPeriod = rsiPeriod || 14; stochPeriod = stochPeriod || 14; kSmooth = kSmooth || 3; dSmooth = dSmooth || 3;
  const rsiVals = calcRSI(data, rsiPeriod);
  const k = [], d = [];
  for (let i = stochPeriod - 1; i < rsiVals.length; i++) {
    let minR = Infinity, maxR = -Infinity;
    for (let j = 0; j < stochPeriod; j++) { const v = rsiVals[i-j].value; minR = Math.min(minR, v); maxR = Math.max(maxR, v); }
    k.push({ time: rsiVals[i].time, value: maxR !== minR ? ((rsiVals[i].value - minR) / (maxR - minR)) * 100 : 50 });
  }
  // Smooth K
  const kSmoothed = [];
  for (let i = kSmooth - 1; i < k.length; i++) {
    let s = 0; for (let j = 0; j < kSmooth; j++) s += k[i-j].value;
    kSmoothed.push({time:k[i].time, value:s/kSmooth});
  }
  // D line
  const dVals = [];
  for (let i = dSmooth - 1; i < kSmoothed.length; i++) {
    let s = 0; for (let j = 0; j < dSmooth; j++) s += kSmoothed[i-j].value;
    dVals.push({time:kSmoothed[i].time, value:s/dSmooth});
  }
  return { k: kSmoothed, d: dVals };
}

// Chande Momentum Oscillator
function calcCMO(data, period) {
  const result = [];
  for (let i = period; i < data.length; i++) {
    let up = 0, dn = 0;
    for (let j = 1; j <= period; j++) {
      const diff = data[i-period+j].close - data[i-period+j-1].close;
      if (diff > 0) up += diff; else dn -= diff;
    }
    result.push({ time:data[i].time, value: (up + dn) !== 0 ? ((up - dn) / (up + dn)) * 100 : 0 });
  }
  return result;
}

// Detrended Price Oscillator
function calcDPO(data, period) {
  period = period || 21;
  const sma = calcSMA(data, period);
  const shift = Math.floor(period / 2) + 1;
  const result = [];
  for (let i = 0; i < sma.length; i++) {
    const dataIdx = i + period - 1;
    if (dataIdx - shift >= 0) {
      result.push({ time: data[dataIdx].time, value: data[dataIdx].close - sma[Math.max(0, i - shift)]?.value || 0 });
    }
  }
  return result;
}

// Fisher Transform
function calcFisher(data, period) {
  period = period || 10;
  const result = []; let fisher = 0, fishPrev = 0;
  for (let i = period - 1; i < data.length; i++) {
    let maxH = -Infinity, minL = Infinity;
    for (let j = 0; j < period; j++) { maxH = Math.max(maxH, data[i-j].high); minL = Math.min(minL, data[i-j].low); }
    const mid = (data[i].high + data[i].low) / 2;
    let val = maxH !== minL ? 0.66 * ((mid - minL) / (maxH - minL) - 0.5) + 0.67 * (fishPrev || 0) : 0;
    val = Math.max(-0.999, Math.min(0.999, val));
    fisher = 0.5 * Math.log((1 + val) / (1 - val)) + 0.5 * fisher;
    result.push({ time:data[i].time, value: fisher });
    fishPrev = val;
  }
  return result;
}

// TRIX
function calcTRIX(data, period) {
  period = period || 18;
  const e1 = calcEMA(data, period);
  const e2 = calcEMA(e1.map(v => ({time:v.time, close:v.value})), period);
  const e3 = calcEMA(e2.map(v => ({time:v.time, close:v.value})), period);
  const result = [];
  for (let i = 1; i < e3.length; i++) {
    result.push({ time:e3[i].time, value: e3[i-1].value !== 0 ? ((e3[i].value - e3[i-1].value) / e3[i-1].value) * 10000 : 0 });
  }
  return result;
}

// Momentum
function calcMomentum(data, period) {
  return data.slice(period).map((d, i) => ({ time: d.time, value: d.close - data[i].close }));
}

// Balance of Power
function calcBOP(data) {
  return data.map(d => ({ time:d.time, value: (d.high !== d.low) ? (d.close - d.open) / (d.high - d.low) : 0 }));
}

// Connors RSI
function calcConnorsRSI(data, rsiP, streakP, rankP) {
  rsiP = rsiP || 3; streakP = streakP || 2; rankP = rankP || 100;
  const rsi = calcRSI(data, rsiP);
  // Streak
  const streaks = [0];
  for (let i = 1; i < data.length; i++) {
    if (data[i].close > data[i-1].close) streaks.push(streaks[i-1] > 0 ? streaks[i-1]+1 : 1);
    else if (data[i].close < data[i-1].close) streaks.push(streaks[i-1] < 0 ? streaks[i-1]-1 : -1);
    else streaks.push(0);
  }
  const streakRSI = calcRSI(streaks.map((s,i) => ({time:data[i].time, close:s})), streakP);
  // Percent rank
  const pctRank = [];
  for (let i = rankP; i < data.length; i++) {
    const change = data[i].close - data[i-1].close;
    let count = 0;
    for (let j = 1; j <= rankP; j++) { if ((data[i-j].close - data[i-j-1]?.close||0) < change) count++; }
    pctRank.push({ time:data[i].time, value: (count / rankP) * 100 });
  }
  // Combine
  const result = [];
  const minLen = Math.min(rsi.length, streakRSI.length, pctRank.length);
  for (let i = 0; i < minLen; i++) {
    const ri = rsi[rsi.length - minLen + i], si = streakRSI[streakRSI.length - minLen + i], pi = pctRank[pctRank.length - minLen + i];
    result.push({ time:ri.time, value: (ri.value + si.value + pi.value) / 3 });
  }
  return result;
}

// Coppock Curve
function calcCoppock(data, wma, longROC, shortROC) {
  wma = wma || 10; longROC = longROC || 14; shortROC = shortROC || 11;
  const roc1 = calcROC(data, longROC);
  const roc2 = calcROC(data, shortROC);
  const minLen = Math.min(roc1.length, roc2.length);
  const combined = [];
  for (let i = 0; i < minLen; i++) {
    const r1 = roc1[roc1.length - minLen + i], r2 = roc2[roc2.length - minLen + i];
    combined.push({time:r1.time, close: r1.value + r2.value});
  }
  return calcWMA(combined.map(c => ({time:c.time, close:c.close, open:c.close, high:c.close, low:c.close, volume:0})), wma);
}

// Relative Vigor Index
function calcRVI(data, period) {
  period = period || 10;
  const result = [];
  for (let i = period + 3; i < data.length; i++) {
    let numSum = 0, denSum = 0;
    for (let j = 0; j < period; j++) {
      const idx = i - j;
      const closeOpen = (data[idx].close - data[idx].open + 2*(data[idx-1]?.close-data[idx-1]?.open||0) + 2*(data[idx-2]?.close-data[idx-2]?.open||0) + (data[idx-3]?.close-data[idx-3]?.open||0)) / 6;
      const highLow = (data[idx].high - data[idx].low + 2*(data[idx-1]?.high-data[idx-1]?.low||0) + 2*(data[idx-2]?.high-data[idx-2]?.low||0) + (data[idx-3]?.high-data[idx-3]?.low||0)) / 6;
      numSum += closeOpen; denSum += highLow;
    }
    result.push({ time:data[i].time, value: denSum !== 0 ? numSum / denSum : 0 });
  }
  return result;
}

// Relative Volatility Index
function calcRVOL(data, period) {
  period = period || 14;
  const stddevs = [];
  for (let i = 9; i < data.length; i++) {
    let sum = 0, sum2 = 0;
    for (let j = 0; j < 10; j++) { sum += data[i-j].close; sum2 += data[i-j].close * data[i-j].close; }
    stddevs.push({ time:data[i].time, value: Math.sqrt(sum2/10 - (sum/10)*(sum/10)), close:data[i].close, prevClose:data[i-1]?.close||data[i].close });
  }
  const result = [];
  let upAvg = 0, dnAvg = 0;
  for (let i = 0; i < stddevs.length; i++) {
    const isUp = stddevs[i].close >= stddevs[i].prevClose;
    if (i < period) {
      if (isUp) upAvg += stddevs[i].value / period; else dnAvg += stddevs[i].value / period;
    } else {
      upAvg = (upAvg * (period-1) + (isUp ? stddevs[i].value : 0)) / period;
      dnAvg = (dnAvg * (period-1) + (!isUp ? stddevs[i].value : 0)) / period;
      result.push({ time:stddevs[i].time, value: (upAvg+dnAvg) !== 0 ? 100 * upAvg / (upAvg+dnAvg) : 50 });
    }
  }
  return result;
}

// Klinger Volume Oscillator
function calcKlinger(data, fastP, slowP, sigP) {
  fastP = fastP || 34; slowP = slowP || 55; sigP = sigP || 13;
  const vf = [];
  for (let i = 1; i < data.length; i++) {
    const hlc = data[i].high + data[i].low + data[i].close;
    const phlc = data[i-1].high + data[i-1].low + data[i-1].close;
    const trend = hlc > phlc ? 1 : -1;
    const dm = data[i].high - data[i].low;
    const cm = i > 1 && ((hlc > phlc) === ((data[i-1].high+data[i-1].low+data[i-1].close) > (data[i-2]?.high||0+data[i-2]?.low||0+data[i-2]?.close||0))) ? (vf[vf.length-1]?.cm || dm) + dm : dm;
    vf.push({time:data[i].time, close: cm !== 0 ? data[i].volume * Math.abs(2*dm/cm - 1) * trend : 0, cm});
  }
  const fast = calcEMA(vf, fastP);
  const slow = calcEMA(vf, slowP);
  const minLen = Math.min(fast.length, slow.length);
  const kvo = [];
  for (let i = 0; i < minLen; i++) {
    kvo.push({time:fast[fast.length-minLen+i].time, value:fast[fast.length-minLen+i].value - slow[slow.length-minLen+i].value, close:fast[fast.length-minLen+i].value - slow[slow.length-minLen+i].value});
  }
  const sig = calcEMA(kvo, sigP);
  return { kvo: kvo.map(k => ({time:k.time,value:k.value})), signal: sig };
}

// Elder's Force Index
function calcElderForce(data, period) {
  period = period || 13;
  const force = [];
  for (let i = 1; i < data.length; i++) {
    force.push({time:data[i].time, close: (data[i].close - data[i-1].close) * data[i].volume});
  }
  return calcEMA(force, period);
}

// Ease of Movement
function calcEOM(data, period) {
  period = period || 14;
  const emv = [];
  for (let i = 1; i < data.length; i++) {
    const dm = ((data[i].high + data[i].low) / 2) - ((data[i-1].high + data[i-1].low) / 2);
    const br = (data[i].volume / 1e6) / (data[i].high - data[i].low || 1);
    emv.push({time:data[i].time, close: dm / br});
  }
  return calcSMA(emv.map(e => ({...e, open:e.close, high:e.close, low:e.close, volume:0})), period);
}

// Price Oscillator
function calcPPO(data, fast, slow, sig) {
  fast = fast || 12; slow = slow || 26; sig = sig || 9;
  const fEMA = calcEMA(data, fast);
  const sEMA = calcEMA(data, slow);
  const minLen = Math.min(fEMA.length, sEMA.length);
  const ppo = [];
  for (let i = 0; i < minLen; i++) {
    const f = fEMA[fEMA.length-minLen+i], s = sEMA[sEMA.length-minLen+i];
    ppo.push({time:f.time, value: s.value !== 0 ? ((f.value - s.value) / s.value) * 100 : 0, close: s.value !== 0 ? ((f.value - s.value) / s.value) * 100 : 0});
  }
  const signal = calcEMA(ppo, sig);
  return { ppo: ppo.map(p => ({time:p.time,value:p.value})), signal };
}

// Mass Index
function calcMassIndex(data, period) {
  period = period || 25;
  const hlRange = data.map(d => ({time:d.time, close:d.high - d.low}));
  const e1 = calcEMA(hlRange, 9);
  const e2 = calcEMA(e1.map(v => ({time:v.time, close:v.value})), 9);
  const ratio = [];
  const minLen = Math.min(e1.length, e2.length);
  for (let i = 0; i < minLen; i++) {
    const a = e1[e1.length-minLen+i], b = e2[e2.length-minLen+i];
    ratio.push({ time:a.time, value: b.value !== 0 ? a.value / b.value : 1 });
  }
  const result = [];
  for (let i = period - 1; i < ratio.length; i++) {
    let sum = 0;
    for (let j = 0; j < period; j++) sum += ratio[i-j].value;
    result.push({time:ratio[i].time, value:sum});
  }
  return result;
}

// Choppiness Index
function calcChop(data, period) {
  period = period || 14;
  const result = [];
  for (let i = period; i < data.length; i++) {
    let atrSum = 0, highest = -Infinity, lowest = Infinity;
    for (let j = 0; j < period; j++) {
      const idx = i - j;
      const tr = Math.max(data[idx].high - data[idx].low, Math.abs(data[idx].high - data[idx-1]?.close||data[idx].close), Math.abs(data[idx].low - data[idx-1]?.close||data[idx].close));
      atrSum += tr;
      highest = Math.max(highest, data[idx].high);
      lowest = Math.min(lowest, data[idx].low);
    }
    const range = highest - lowest;
    result.push({ time:data[i].time, value: range > 0 ? 100 * Math.log10(atrSum / range) / Math.log10(period) : 50 });
  }
  return result;
}

// SMI Ergodic
function calcSMIErgodic(data, fastP, slowP, sigP) {
  fastP = fastP || 5; slowP = slowP || 20; sigP = sigP || 5;
  const pc = [];
  for (let i = 1; i < data.length; i++) pc.push({time:data[i].time, close:data[i].close - data[i-1].close});
  const abspc = pc.map(p => ({time:p.time, close:Math.abs(p.close)}));
  const num = calcEMA(calcEMA(pc, fastP).map(v => ({time:v.time,close:v.value})), slowP);
  const den = calcEMA(calcEMA(abspc, fastP).map(v => ({time:v.time,close:v.value})), slowP);
  const minLen = Math.min(num.length, den.length);
  const smi = [];
  for (let i = 0; i < minLen; i++) {
    const n = num[num.length-minLen+i], d = den[den.length-minLen+i];
    smi.push({time:n.time, value: d.value !== 0 ? (n.value / d.value) * 100 : 0, close: d.value !== 0 ? (n.value / d.value) * 100 : 0});
  }
  const sig = calcEMA(smi, sigP);
  return { smi: smi.map(s => ({time:s.time,value:s.value})), signal: sig };
}

// Net Volume
function calcNetVol(data) {
  return data.map(d => ({time:d.time, value: d.close >= d.open ? d.volume : -d.volume, color: d.close >= d.open ? 'rgba(38,166,154,0.7)' : 'rgba(239,83,80,0.7)'}));
}

// Price Volume Trend
function calcPVT(data) {
  const result = []; let pvt = 0;
  for (let i = 1; i < data.length; i++) {
    pvt += ((data[i].close - data[i-1].close) / data[i-1].close) * data[i].volume;
    result.push({time:data[i].time, value:pvt});
  }
  return result;
}

// Volume Oscillator
function calcVolOsc(data, fast, slow) {
  fast = fast || 5; slow = slow || 10;
  const volData = data.map(d => ({time:d.time, close:d.volume}));
  const fMA = calcSMA(volData.map(v => ({...v,open:v.close,high:v.close,low:v.close,volume:0})), fast);
  const sMA = calcSMA(volData.map(v => ({...v,open:v.close,high:v.close,low:v.close,volume:0})), slow);
  const minLen = Math.min(fMA.length, sMA.length);
  return Array.from({length:minLen}, (_,i) => {
    const f = fMA[fMA.length-minLen+i], s = sMA[sMA.length-minLen+i];
    return {time:f.time, value: s.value !== 0 ? ((f.value - s.value) / s.value) * 100 : 0};
  });
}

// Chaikin Oscillator
function calcChaikinOsc(data, fast, slow) {
  fast = fast || 3; slow = slow || 10;
  const ad = calcAD(data);
  const fEMA = calcEMA(ad.map(a => ({time:a.time, close:a.value})), fast);
  const sEMA = calcEMA(ad.map(a => ({time:a.time, close:a.value})), slow);
  const minLen = Math.min(fEMA.length, sEMA.length);
  return Array.from({length:minLen}, (_,i) => {
    const f = fEMA[fEMA.length-minLen+i], s = sEMA[sEMA.length-minLen+i];
    return {time:f.time, value:f.value - s.value};
  });
}

// Vortex Indicator
function calcVortex(data, period) {
  period = period || 14;
  const viPlus = [], viMinus = [];
  for (let i = period; i < data.length; i++) {
    let vpSum = 0, vmSum = 0, trSum = 0;
    for (let j = 0; j < period; j++) {
      const idx = i - j;
      vpSum += Math.abs(data[idx].high - data[idx-1].low);
      vmSum += Math.abs(data[idx].low - data[idx-1].high);
      trSum += Math.max(data[idx].high - data[idx].low, Math.abs(data[idx].high - data[idx-1].close), Math.abs(data[idx].low - data[idx-1].close));
    }
    viPlus.push({time:data[i].time, value: trSum > 0 ? vpSum/trSum : 1});
    viMinus.push({time:data[i].time, value: trSum > 0 ? vmSum/trSum : 1});
  }
  return { plus: viPlus, minus: viMinus };
}

// Know Sure Thing
function calcKST(data) {
  const r1 = calcROC(data, 10), r2 = calcROC(data, 15), r3 = calcROC(data, 20), r4 = calcROC(data, 30);
  const minLen = Math.min(r1.length, r2.length, r3.length, r4.length);
  const kst = [];
  for (let i = 0; i < minLen; i++) {
    kst.push({time:r1[r1.length-minLen+i].time, value: r1[r1.length-minLen+i].value + r2[r2.length-minLen+i].value*2 + r3[r3.length-minLen+i].value*3 + r4[r4.length-minLen+i].value*4,
      close: r1[r1.length-minLen+i].value + r2[r2.length-minLen+i].value*2 + r3[r3.length-minLen+i].value*3 + r4[r4.length-minLen+i].value*4});
  }
  const sig = calcSMA(kst.map(k => ({...k,open:k.close,high:k.close,low:k.close,volume:0})), 9);
  return { kst: kst.map(k => ({time:k.time,value:k.value})), signal: sig };
}

// Chande Kroll Stop
function calcChandeKroll(data, p, x, q) {
  p = p || 10; x = x || 1; q = q || 9;
  const atrVals = calcATR(data, p);
  const stopShort = [], stopLong = [];
  for (let i = p - 1; i < data.length; i++) {
    const atrIdx = i - (p - 1);
    const atrVal = atrIdx >= 0 && atrIdx < atrVals.length ? atrVals[atrIdx].value : 0;
    let maxH = -Infinity, minL = Infinity;
    for (let j = 0; j < p && (i-j) >= 0; j++) { maxH = Math.max(maxH, data[i-j].high); minL = Math.min(minL, data[i-j].low); }
    const firstHighStop = maxH - x * atrVal;
    const firstLowStop = minL + x * atrVal;
    stopShort.push({time:data[i].time, value: firstHighStop});
    stopLong.push({time:data[i].time, value: firstLowStop});
  }
  return { short: stopShort, long: stopLong };
}

// Zig Zag
function calcZigZag(data, pct) {
  pct = pct || 5;
  const result = [];
  if (!data.length) return result;
  let lastPivot = {time:data[0].time, value:data[0].close};
  let dir = 0; // 0=none, 1=up, -1=down
  result.push(lastPivot);
  for (let i = 1; i < data.length; i++) {
    const change = ((data[i].close - lastPivot.value) / lastPivot.value) * 100;
    if (dir === 0) {
      if (Math.abs(change) >= pct) { dir = change > 0 ? 1 : -1; lastPivot = {time:data[i].time, value:data[i].close}; result.push(lastPivot); }
    } else if (dir === 1) {
      if (data[i].close > lastPivot.value) { lastPivot = {time:data[i].time, value:data[i].close}; result[result.length-1] = lastPivot; }
      else if (change <= -pct) { dir = -1; lastPivot = {time:data[i].time, value:data[i].close}; result.push(lastPivot); }
    } else {
      if (data[i].close < lastPivot.value) { lastPivot = {time:data[i].time, value:data[i].close}; result[result.length-1] = lastPivot; }
      else if (change >= pct) { dir = 1; lastPivot = {time:data[i].time, value:data[i].close}; result.push(lastPivot); }
    }
  }
  return result;
}

// Williams Fractal
function calcFractals(data, period) {
  period = period || 2;
  const up = [], dn = [];
  for (let i = period; i < data.length - period; i++) {
    let isUp = true, isDn = true;
    for (let j = 1; j <= period; j++) {
      if (data[i].high <= data[i-j].high || data[i].high <= data[i+j].high) isUp = false;
      if (data[i].low >= data[i-j].low || data[i].low >= data[i+j].low) isDn = false;
    }
    if (isUp) up.push({time:data[i].time, position:'aboveBar', color:'#26a69a', shape:'arrowDown', text:'‚ñ≤'});
    if (isDn) dn.push({time:data[i].time, position:'belowBar', color:'#ef5350', shape:'arrowUp', text:'‚ñº'});
  }
  return { up, down: dn };
}

// Price Channel
function calcPriceChannel(data, period) {
  period = period || 20;
  const upper = [], lower = [];
  for (let i = period; i < data.length; i++) {
    let maxH = -Infinity, minL = Infinity;
    for (let j = 1; j <= period; j++) { maxH = Math.max(maxH, data[i-j].high); minL = Math.min(minL, data[i-j].low); }
    upper.push({time:data[i].time, value:maxH}); lower.push({time:data[i].time, value:minL});
  }
  return { upper, lower };
}

// 52-Week High/Low
function calc52WHL(data) {
  const oneYear = 252;
  const result = { high: [], low: [] };
  for (let i = oneYear; i < data.length; i++) {
    let maxH = -Infinity, minL = Infinity;
    for (let j = 0; j < oneYear; j++) { maxH = Math.max(maxH, data[i-j].high); minL = Math.min(minL, data[i-j].low); }
    result.high.push({time:data[i].time, value:maxH});
    result.low.push({time:data[i].time, value:minL});
  }
  return result;
}

// Candlestick Pattern Detection
function detectCandlePatterns(data) {
  const markers = [];
  for (let i = 2; i < data.length; i++) {
    const c = data[i], p = data[i-1], pp = data[i-2];
    const body = Math.abs(c.close - c.open);
    const range = c.high - c.low;
    const upperWick = c.high - Math.max(c.open, c.close);
    const lowerWick = Math.min(c.open, c.close) - c.low;
    const bullish = c.close > c.open;
    const pBody = Math.abs(p.close - p.open);
    const pBullish = p.close > p.open;

    // Doji
    if (body < range * 0.1 && range > 0) {
      markers.push({time:c.time, position:'aboveBar', color:'#f7a21b', shape:'circle', text:'D'});
    }
    // Hammer (bullish reversal)
    else if (lowerWick > body * 2 && upperWick < body * 0.3 && !pBullish) {
      markers.push({time:c.time, position:'belowBar', color:'#26a69a', shape:'arrowUp', text:'H'});
    }
    // Shooting Star (bearish reversal)
    else if (upperWick > body * 2 && lowerWick < body * 0.3 && pBullish) {
      markers.push({time:c.time, position:'aboveBar', color:'#ef5350', shape:'arrowDown', text:'SS'});
    }
    // Bullish Engulfing
    else if (bullish && !pBullish && c.open <= p.close && c.close >= p.open && body > pBody) {
      markers.push({time:c.time, position:'belowBar', color:'#26a69a', shape:'arrowUp', text:'BE'});
    }
    // Bearish Engulfing
    else if (!bullish && pBullish && c.open >= p.close && c.close <= p.open && body > pBody) {
      markers.push({time:c.time, position:'aboveBar', color:'#ef5350', shape:'arrowDown', text:'bE'});
    }
    // Morning Star
    else if (i >= 2 && !pp.close > pp.open && Math.abs(p.close - p.open) < Math.abs(pp.close - pp.open) * 0.3 && bullish && c.close > (pp.open + pp.close) / 2) {
      markers.push({time:c.time, position:'belowBar', color:'#26a69a', shape:'arrowUp', text:'MS'});
    }
    // Evening Star
    else if (i >= 2 && pp.close > pp.open && Math.abs(p.close - p.open) < Math.abs(pp.close - pp.open) * 0.3 && !bullish && c.close < (pp.open + pp.close) / 2) {
      markers.push({time:c.time, position:'aboveBar', color:'#ef5350', shape:'arrowDown', text:'ES'});
    }
    // Three White Soldiers
    else if (i >= 2 && bullish && pBullish && pp.close > pp.open && c.close > p.close && p.close > pp.close && body > range * 0.5 && pBody > (p.high-p.low) * 0.5) {
      markers.push({time:c.time, position:'belowBar', color:'#00e676', shape:'arrowUp', text:'3WS'});
    }
    // Three Black Crows
    else if (i >= 2 && !bullish && !pBullish && pp.close < pp.open && c.close < p.close && p.close < pp.close && body > range * 0.5) {
      markers.push({time:c.time, position:'aboveBar', color:'#ff1744', shape:'arrowDown', text:'3BC'});
    }
  }
  return markers;
}

// Chart Pattern Detection (basic)
function detectChartPatterns(data) {
  const markers = [];
  if (data.length < 60) return markers;
  // Simple double top/bottom detection using 50-bar window
  for (let i = 50; i < data.length - 5; i++) {
    const window = data.slice(i - 50, i);
    const highs = [], lows = [];
    // Find local extremes
    for (let j = 5; j < window.length - 5; j++) {
      let isHigh = true, isLow = true;
      for (let k = 1; k <= 5; k++) {
        if (window[j].high <= window[j-k].high || window[j].high <= window[j+k].high) isHigh = false;
        if (window[j].low >= window[j-k].low || window[j].low >= window[j+k].low) isLow = false;
      }
      if (isHigh) highs.push({idx: j, val: window[j].high, time: window[j].time});
      if (isLow) lows.push({idx: j, val: window[j].low, time: window[j].time});
    }
    // Double Top: two similar highs
    if (highs.length >= 2) {
      const h1 = highs[highs.length-2], h2 = highs[highs.length-1];
      if (Math.abs(h1.val - h2.val) / h1.val < 0.02 && h2.idx - h1.idx >= 10) {
        if (!markers.find(m => m.time === h2.time)) {
          markers.push({time:h2.time, position:'aboveBar', color:'#ff1744', shape:'arrowDown', text:'DT'});
        }
      }
    }
    // Double Bottom: two similar lows
    if (lows.length >= 2) {
      const l1 = lows[lows.length-2], l2 = lows[lows.length-1];
      if (Math.abs(l1.val - l2.val) / l1.val < 0.02 && l2.idx - l1.idx >= 10) {
        if (!markers.find(m => m.time === l2.time)) {
          markers.push({time:l2.time, position:'belowBar', color:'#00e676', shape:'arrowUp', text:'DB'});
        }
      }
    }
  }
  return markers;
}

// RSI Divergence
function detectRSIDivergence(data) {
  const markers = [];
  const rsiVals = calcRSI(data, 14);
  if (rsiVals.length < 30) return markers;
  const lookback = 20;
  for (let i = lookback; i < rsiVals.length; i++) {
    const dataIdx = i + 14; // offset for RSI calculation
    if (dataIdx >= data.length) break;
    // Bullish divergence: price makes lower low but RSI makes higher low
    let priceLow1 = Infinity, priceLow2 = Infinity, rsiLow1 = Infinity, rsiLow2 = Infinity;
    const half = Math.floor(lookback / 2);
    for (let j = 0; j < half; j++) {
      priceLow1 = Math.min(priceLow1, data[dataIdx - lookback + j].low);
      rsiLow1 = Math.min(rsiLow1, rsiVals[i - lookback + j]?.value || 50);
    }
    for (let j = half; j < lookback; j++) {
      priceLow2 = Math.min(priceLow2, data[dataIdx - lookback + j].low);
      rsiLow2 = Math.min(rsiLow2, rsiVals[i - lookback + j]?.value || 50);
    }
    if (priceLow2 < priceLow1 * 0.99 && rsiLow2 > rsiLow1 * 1.05 && rsiLow2 < 40) {
      markers.push({time:data[dataIdx].time, position:'belowBar', color:'#00e676', shape:'arrowUp', text:'Bull Div'});
      i += lookback; // skip ahead
    }
  }
  return markers;
}
function applyIndicators(cellIdx) {
  const cell = STATE.cells[cellIdx];
  if (!cell.chart || !cell.data.length) return;
  const data = cell.data;

  // Remove old indicator series
  Object.values(cell.indicatorSeries).forEach(s => {
    if (Array.isArray(s)) s.forEach(ss => { try { cell.chart.removeSeries(ss); } catch(e){} });
    else { try { cell.chart.removeSeries(s); } catch(e){} }
  });
  cell.indicatorSeries = {};

  STATE.indicators.forEach(id => {
    if (id === 'vol') return; // Handled separately

    try {
      // Moving Averages
      if (id.startsWith('sma')) {
        const p = parseInt(id.replace('sma', ''));
        const vals = calcSMA(data, p);
        const s = cell.chart.addLineSeries({ color: IND_COLORS[id] || '#2196f3', lineWidth: 1, priceScaleId: 'right', lastValueVisible: false, priceLineVisible: false });
        s.setData(vals);
        cell.indicatorSeries[id] = s;
      }
      else if (id.startsWith('ema')) {
        const p = parseInt(id.replace('ema', ''));
        const vals = calcEMA(data, p);
        const s = cell.chart.addLineSeries({ color: IND_COLORS[id] || '#4caf50', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
        s.setData(vals);
        cell.indicatorSeries[id] = s;
      }
      else if (id === 'wma20') { const s = cell.chart.addLineSeries({ color: IND_COLORS.wma20, lineWidth: 1, lastValueVisible:false, priceLineVisible:false }); s.setData(calcWMA(data, 20)); cell.indicatorSeries[id] = s; }
      else if (id === 'dema20') { const s = cell.chart.addLineSeries({ color: IND_COLORS.dema20, lineWidth: 1, lastValueVisible:false, priceLineVisible:false }); s.setData(calcDEMA(data, 20)); cell.indicatorSeries[id] = s; }
      else if (id === 'hull20') { const s = cell.chart.addLineSeries({ color: IND_COLORS.hull20, lineWidth: 2, lastValueVisible:false, priceLineVisible:false }); s.setData(calcHullMA(data, 20)); cell.indicatorSeries[id] = s; }

      // Bollinger Bands
      else if (id === 'bb' || id === 'bb2') {
        const mult = id === 'bb2' ? 3 : 2;
        const bb = calcBB(data, 20, mult);
        const su = cell.chart.addLineSeries({ color: '#2196f3', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        const sm = cell.chart.addLineSeries({ color: '#2196f3', lineWidth: 1, lastValueVisible:false, priceLineVisible:false });
        const sl = cell.chart.addLineSeries({ color: '#2196f3', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        su.setData(bb.upper); sm.setData(bb.middle); sl.setData(bb.lower);
        cell.indicatorSeries[id] = [su, sm, sl];
      }

      // Keltner Channel
      else if (id === 'kc') {
        const kc = calcKeltner(data, 20, 1.5);
        const su = cell.chart.addLineSeries({ color: '#ff9800', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        const sm = cell.chart.addLineSeries({ color: '#ff9800', lineWidth: 1, lastValueVisible:false, priceLineVisible:false });
        const sl = cell.chart.addLineSeries({ color: '#ff9800', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        su.setData(kc.upper); sm.setData(kc.middle); sl.setData(kc.lower);
        cell.indicatorSeries[id] = [su, sm, sl];
      }

      // Donchian Channel
      else if (id === 'dc') {
        const dc = calcDonchian(data, 20);
        const su = cell.chart.addLineSeries({ color: '#00bcd4', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        const sm = cell.chart.addLineSeries({ color: '#00bcd4', lineWidth: 1, lineStyle: 3, lastValueVisible:false, priceLineVisible:false });
        const sl = cell.chart.addLineSeries({ color: '#00bcd4', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        su.setData(dc.upper); sm.setData(dc.middle); sl.setData(dc.lower);
        cell.indicatorSeries[id] = [su, sm, sl];
      }

      // VWAP
      else if (id === 'vwap') {
        const s = cell.chart.addLineSeries({ color: IND_COLORS.vwap, lineWidth: 2, lastValueVisible:false, priceLineVisible:false });
        s.setData(calcVWAP(data));
        cell.indicatorSeries[id] = s;
      }

      // Parabolic SAR
      else if (id === 'psar') {
        const psar = calcPSAR(data, 0.02, 0.2);
        const s = cell.chart.addLineSeries({ lineWidth: 0, lastValueVisible:false, priceLineVisible:false, pointMarkersVisible: true, pointMarkersRadius: 2 });
        s.setData(psar);
        cell.indicatorSeries[id] = s;
      }

      // Ichimoku
      else if (id === 'ichi') {
        const ichi = calcIchimoku(data);
        const sConv = cell.chart.addLineSeries({ color: '#2962ff', lineWidth: 1, lastValueVisible:false, priceLineVisible:false });
        const sBase = cell.chart.addLineSeries({ color: '#ef5350', lineWidth: 1, lastValueVisible:false, priceLineVisible:false });
        const sSpanA = cell.chart.addLineSeries({ color: 'rgba(38,166,154,.5)', lineWidth: 1, lastValueVisible:false, priceLineVisible:false });
        const sSpanB = cell.chart.addLineSeries({ color: 'rgba(239,83,80,.5)', lineWidth: 1, lastValueVisible:false, priceLineVisible:false });
        const sLag = cell.chart.addLineSeries({ color: '#7b61ff', lineWidth: 1, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        sConv.setData(ichi.conversion); sBase.setData(ichi.base);
        if (ichi.spanA.length) sSpanA.setData(ichi.spanA);
        if (ichi.spanB.length) sSpanB.setData(ichi.spanB);
        if (ichi.lagging.length) sLag.setData(ichi.lagging);
        cell.indicatorSeries[id] = [sConv, sBase, sSpanA, sSpanB, sLag];
      }

      // SuperTrend
      else if (id === 'supertrend') {
        const st = calcSuperTrend(data, 10, 3);
        const s = cell.chart.addLineSeries({ lineWidth: 2, lastValueVisible:false, priceLineVisible:false });
        s.setData(st);
        cell.indicatorSeries[id] = s;
      }

      // RSI (separate pane via priceScaleId)
      else if (id === 'rsi') {
        const vals = calcRSI(data, 14);
        const s = cell.chart.addLineSeries({ color: '#7b61ff', lineWidth: 1, priceScaleId: 'rsi', lastValueVisible:true, priceLineVisible:false });
        s.setData(vals);
        cell.chart.priceScale('rsi').applyOptions({ scaleMargins: { top: 0.75, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // MACD
      else if (id === 'macd') {
        const m = calcMACD(data);
        const sLine = cell.chart.addLineSeries({ color: '#2962ff', lineWidth: 1, priceScaleId: 'macd', lastValueVisible:false, priceLineVisible:false });
        const sSig = cell.chart.addLineSeries({ color: '#ff6d00', lineWidth: 1, priceScaleId: 'macd', lastValueVisible:false, priceLineVisible:false });
        const sHist = cell.chart.addHistogramSeries({ priceScaleId: 'macd', lastValueVisible:false, priceLineVisible:false });
        sLine.setData(m.macdLine); sSig.setData(m.signal); sHist.setData(m.histogram);
        cell.chart.priceScale('macd').applyOptions({ scaleMargins: { top: 0.75, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = [sLine, sSig, sHist];
      }

      // Stochastic
      else if (id === 'stoch') {
        const st = calcStochastic(data, 14, 3, 3);
        const sk = cell.chart.addLineSeries({ color: '#2962ff', lineWidth: 1, priceScaleId: 'stoch', lastValueVisible:false, priceLineVisible:false });
        const sd = cell.chart.addLineSeries({ color: '#ff6d00', lineWidth: 1, priceScaleId: 'stoch', lastValueVisible:false, priceLineVisible:false });
        sk.setData(st.k); sd.setData(st.d);
        cell.chart.priceScale('stoch').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = [sk, sd];
      }

      // CCI
      else if (id === 'cci') {
        const s = cell.chart.addLineSeries({ color: '#00bcd4', lineWidth: 1, priceScaleId: 'cci', lastValueVisible:true, priceLineVisible:false });
        s.setData(calcCCI(data, 20));
        cell.chart.priceScale('cci').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // Williams %R
      else if (id === 'willr') {
        const s = cell.chart.addLineSeries({ color: '#e91e63', lineWidth: 1, priceScaleId: 'willr', lastValueVisible:true, priceLineVisible:false });
        s.setData(calcWilliamsR(data, 14));
        cell.chart.priceScale('willr').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // ROC
      else if (id === 'roc') {
        const s = cell.chart.addLineSeries({ color: '#ff9800', lineWidth: 1, priceScaleId: 'roc', lastValueVisible:true, priceLineVisible:false });
        s.setData(calcROC(data, 12));
        cell.chart.priceScale('roc').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // MFI
      else if (id === 'mfi') {
        const s = cell.chart.addLineSeries({ color: '#4caf50', lineWidth: 1, priceScaleId: 'mfi', lastValueVisible:true, priceLineVisible:false });
        s.setData(calcMFI(data, 14));
        cell.chart.priceScale('mfi').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // OBV
      else if (id === 'obv') {
        const s = cell.chart.addLineSeries({ color: '#9c27b0', lineWidth: 1, priceScaleId: 'obv', lastValueVisible:false, priceLineVisible:false });
        s.setData(calcOBV(data));
        cell.chart.priceScale('obv').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // A/D
      else if (id === 'ad') {
        const s = cell.chart.addLineSeries({ color: '#795548', lineWidth: 1, priceScaleId: 'ad', lastValueVisible:false, priceLineVisible:false });
        s.setData(calcAD(data));
        cell.chart.priceScale('ad').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // CMF
      else if (id === 'cmf') {
        const s = cell.chart.addLineSeries({ color: '#ff5722', lineWidth: 1, priceScaleId: 'cmf', lastValueVisible:true, priceLineVisible:false });
        s.setData(calcCMF(data, 20));
        cell.chart.priceScale('cmf').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // ATR
      else if (id === 'atr') {
        const s = cell.chart.addLineSeries({ color: '#ff9800', lineWidth: 1, priceScaleId: 'atr', lastValueVisible:true, priceLineVisible:false });
        s.setData(calcATR(data, 14));
        cell.chart.priceScale('atr').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // DMI
      else if (id === 'dmi' || id === 'adx') {
        const dmi = calcDMI(data, 14);
        const sp = cell.chart.addLineSeries({ color: '#26a69a', lineWidth: 1, priceScaleId: 'dmi', lastValueVisible:false, priceLineVisible:false });
        const sm = cell.chart.addLineSeries({ color: '#ef5350', lineWidth: 1, priceScaleId: 'dmi', lastValueVisible:false, priceLineVisible:false });
        const sa = cell.chart.addLineSeries({ color: '#f7a21b', lineWidth: 2, priceScaleId: 'dmi', lastValueVisible:false, priceLineVisible:false });
        sp.setData(dmi.plus); sm.setData(dmi.minus); sa.setData(dmi.adx);
        cell.chart.priceScale('dmi').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = [sp, sm, sa];
      }

      // Aroon
      else if (id === 'aroon') {
        const ar = calcAroon(data, 25);
        const su = cell.chart.addLineSeries({ color: '#26a69a', lineWidth: 1, priceScaleId: 'aroon', lastValueVisible:false, priceLineVisible:false });
        const sd = cell.chart.addLineSeries({ color: '#ef5350', lineWidth: 1, priceScaleId: 'aroon', lastValueVisible:false, priceLineVisible:false });
        su.setData(ar.up); sd.setData(ar.down);
        cell.chart.priceScale('aroon').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = [su, sd];
      }

      // AO
      else if (id === 'ao') {
        const s = cell.chart.addHistogramSeries({ priceScaleId: 'ao', lastValueVisible:false, priceLineVisible:false });
        s.setData(calcAO(data));
        cell.chart.priceScale('ao').applyOptions({ scaleMargins: { top: 0.8, bottom: 0.02 }, borderVisible: false });
        cell.indicatorSeries[id] = s;
      }

      // Pivot Points
      else if (id === 'pivot' || id === 'pivotfib' || id === 'pivotwoodie' || id === 'pivotcam') {
        const pv = calcPivots(data);
        const lines = [];
        if (pv.pp) {
          const colors = { pp:'#f7a21b', r1:'#ef5350', r2:'#d32f2f', r3:'#b71c1c', s1:'#26a69a', s2:'#00897b', s3:'#00695c' };
          Object.entries(pv).forEach(([key, vals]) => {
            const s = cell.chart.addLineSeries({ color: colors[key] || '#787b86', lineWidth: 1, lineStyle: 2, lastValueVisible: true, priceLineVisible: false, title: key.toUpperCase() });
            s.setData(vals);
            lines.push(s);
          });
        }
        cell.indicatorSeries[id] = lines;
      }

      // Linear Regression
      else if (id === 'linreg') {
        const s = cell.chart.addLineSeries({ color: IND_COLORS.linreg, lineWidth: 2, lineStyle: 2, lastValueVisible:false, priceLineVisible:false });
        s.setData(calcLinReg(data, 20));
        cell.indicatorSeries[id] = s;
      }
      else if (id === 'linregslope') {
        const s = cell.chart.addLineSeries({ color: IND_COLORS.linregslope, lineWidth: 1, priceScaleId:'linregslope', lastValueVisible:false, priceLineVisible:false });
        s.setData(calcLinRegSlope(data, 20));
        cell.indicatorSeries[id] = s;
      }
      // New Moving Averages
      else if (id === 'alma') { const s = cell.chart.addLineSeries({color:IND_COLORS.alma,lineWidth:2,lastValueVisible:false,priceLineVisible:false}); s.setData(calcALMA(data,20)); cell.indicatorSeries[id]=s; }
      else if (id === 'smma20') { const s = cell.chart.addLineSeries({color:IND_COLORS.smma20,lineWidth:1,lastValueVisible:false,priceLineVisible:false}); s.setData(calcSMMA(data,20)); cell.indicatorSeries[id]=s; }
      else if (id === 'lsma20') { const s = cell.chart.addLineSeries({color:IND_COLORS.lsma20,lineWidth:1,lastValueVisible:false,priceLineVisible:false}); s.setData(calcLSMA(data,20)); cell.indicatorSeries[id]=s; }
      else if (id === 'mcginley') { const s = cell.chart.addLineSeries({color:IND_COLORS.mcginley,lineWidth:2,lastValueVisible:false,priceLineVisible:false}); s.setData(calcMcGinley(data,14)); cell.indicatorSeries[id]=s; }
      else if (id === 'vwma20') { const s = cell.chart.addLineSeries({color:IND_COLORS.vwma20,lineWidth:1,lastValueVisible:false,priceLineVisible:false}); s.setData(calcVWMA(data,20)); cell.indicatorSeries[id]=s; }
      else if (id === 'envma') {
        const env = calcEnvelope(data,20,0.025);
        const su = cell.chart.addLineSeries({color:'#ff9800',lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false});
        const sl = cell.chart.addLineSeries({color:'#ff9800',lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false});
        su.setData(env.upper); sl.setData(env.lower);
        cell.indicatorSeries[id] = [su,sl];
      }
      else if (id === 'machannel') {
        const mc = calcMAChannel(data,20);
        const su = cell.chart.addLineSeries({color:'#00bcd4',lineWidth:1,lastValueVisible:false,priceLineVisible:false});
        const sl = cell.chart.addLineSeries({color:'#00bcd4',lineWidth:1,lastValueVisible:false,priceLineVisible:false});
        su.setData(mc.upper); sl.setData(mc.lower);
        cell.indicatorSeries[id] = [su,sl];
      }
      else if (id === 'guppy') {
        const g = calcGuppy(data);
        const series = [];
        g.short.forEach((vals,i) => { const s = cell.chart.addLineSeries({color:`hsl(${120+i*10},80%,50%)`,lineWidth:1,lastValueVisible:false,priceLineVisible:false}); s.setData(vals); series.push(s); });
        g.long.forEach((vals,i) => { const s = cell.chart.addLineSeries({color:`hsl(${0+i*10},80%,50%)`,lineWidth:1,lastValueVisible:false,priceLineVisible:false}); s.setData(vals); series.push(s); });
        cell.indicatorSeries[id] = series;
      }
      else if (id === 'alligator') {
        const a = calcAlligator(data);
        const sj = cell.chart.addLineSeries({color:'#2196f3',lineWidth:2,lastValueVisible:false,priceLineVisible:false,title:'Jaw'});
        const st = cell.chart.addLineSeries({color:'#ef5350',lineWidth:1,lastValueVisible:false,priceLineVisible:false,title:'Teeth'});
        const sl = cell.chart.addLineSeries({color:'#26a69a',lineWidth:1,lastValueVisible:false,priceLineVisible:false,title:'Lips'});
        sj.setData(a.jaw); st.setData(a.teeth); sl.setData(a.lips);
        cell.indicatorSeries[id] = [sj,st,sl];
      }
      // New Volatility
      else if (id === 'bbpct') { const s = cell.chart.addLineSeries({color:IND_COLORS.bbpct,lineWidth:1,priceScaleId:'bbpct',lastValueVisible:false,priceLineVisible:false}); s.setData(calcBBPct(data,20,2)); cell.indicatorSeries[id]=s; }
      else if (id === 'bbw') { const s = cell.chart.addLineSeries({color:IND_COLORS.bbw,lineWidth:1,priceScaleId:'bbw',lastValueVisible:false,priceLineVisible:false}); s.setData(calcBBWidth(data,20,2)); cell.indicatorSeries[id]=s; }
      else if (id === 'histvol') { const s = cell.chart.addLineSeries({color:IND_COLORS.histvol,lineWidth:1,priceScaleId:'histvol',lastValueVisible:false,priceLineVisible:false}); s.setData(calcHistVol(data,20)); cell.indicatorSeries[id]=s; }
      else if (id === 'chvol') { const s = cell.chart.addLineSeries({color:IND_COLORS.chvol,lineWidth:1,priceScaleId:'chvol',lastValueVisible:false,priceLineVisible:false}); s.setData(calcChaikinVol(data,10,10)); cell.indicatorSeries[id]=s; }
      // New Oscillators
      else if (id === 'stochrsi') {
        const sr = calcStochRSI(data,14,14,3,3);
        const sk = cell.chart.addLineSeries({color:'#7c4dff',lineWidth:1,priceScaleId:'stochrsi',lastValueVisible:false,priceLineVisible:false});
        const sd = cell.chart.addLineSeries({color:'#ff4081',lineWidth:1,lineStyle:2,priceScaleId:'stochrsi',lastValueVisible:false,priceLineVisible:false});
        sk.setData(sr.k); sd.setData(sr.d);
        cell.indicatorSeries[id] = [sk,sd];
      }
      else if (id === 'cmo') { const s = cell.chart.addLineSeries({color:IND_COLORS.cmo,lineWidth:1,priceScaleId:'cmo',lastValueVisible:false,priceLineVisible:false}); s.setData(calcCMO(data,14)); cell.indicatorSeries[id]=s; }
      else if (id === 'dpo') { const s = cell.chart.addLineSeries({color:IND_COLORS.dpo,lineWidth:1,priceScaleId:'dpo',lastValueVisible:false,priceLineVisible:false}); s.setData(calcDPO(data,21)); cell.indicatorSeries[id]=s; }
      else if (id === 'fisher') { const s = cell.chart.addLineSeries({color:IND_COLORS.fisher,lineWidth:1,priceScaleId:'fisher',lastValueVisible:false,priceLineVisible:false}); s.setData(calcFisher(data,10)); cell.indicatorSeries[id]=s; }
      else if (id === 'trix') { const s = cell.chart.addLineSeries({color:IND_COLORS.trix,lineWidth:1,priceScaleId:'trix',lastValueVisible:false,priceLineVisible:false}); s.setData(calcTRIX(data,18)); cell.indicatorSeries[id]=s; }
      else if (id === 'mom') { const s = cell.chart.addLineSeries({color:IND_COLORS.mom,lineWidth:1,priceScaleId:'mom',lastValueVisible:false,priceLineVisible:false}); s.setData(calcMomentum(data,10)); cell.indicatorSeries[id]=s; }
      else if (id === 'bop') { const s = cell.chart.addHistogramSeries({color:IND_COLORS.bop,priceScaleId:'bop',lastValueVisible:false,priceLineVisible:false}); s.setData(calcBOP(data)); cell.indicatorSeries[id]=s; }
      else if (id === 'crsi') { const s = cell.chart.addLineSeries({color:IND_COLORS.crsi,lineWidth:1,priceScaleId:'crsi',lastValueVisible:false,priceLineVisible:false}); s.setData(calcConnorsRSI(data,3,2,100)); cell.indicatorSeries[id]=s; }
      else if (id === 'coppock') { const s = cell.chart.addLineSeries({color:IND_COLORS.coppock,lineWidth:2,priceScaleId:'coppock',lastValueVisible:false,priceLineVisible:false}); s.setData(calcCoppock(data)); cell.indicatorSeries[id]=s; }
      else if (id === 'rvi') { const s = cell.chart.addLineSeries({color:IND_COLORS.rvi,lineWidth:1,priceScaleId:'rvi',lastValueVisible:false,priceLineVisible:false}); s.setData(calcRVI(data,10)); cell.indicatorSeries[id]=s; }
      else if (id === 'rvol') { const s = cell.chart.addLineSeries({color:IND_COLORS.rvol,lineWidth:1,priceScaleId:'rvol',lastValueVisible:false,priceLineVisible:false}); s.setData(calcRVOL(data,14)); cell.indicatorSeries[id]=s; }
      else if (id === 'klinger') {
        const kl = calcKlinger(data,34,55,13);
        const sk = cell.chart.addLineSeries({color:IND_COLORS.klinger,lineWidth:1,priceScaleId:'klinger',lastValueVisible:false,priceLineVisible:false});
        const ss = cell.chart.addLineSeries({color:'#ff4081',lineWidth:1,lineStyle:2,priceScaleId:'klinger',lastValueVisible:false,priceLineVisible:false});
        sk.setData(kl.kvo); ss.setData(kl.signal);
        cell.indicatorSeries[id] = [sk,ss];
      }
      else if (id === 'elderforce') { const s = cell.chart.addLineSeries({color:IND_COLORS.elderforce,lineWidth:1,priceScaleId:'elderforce',lastValueVisible:false,priceLineVisible:false}); s.setData(calcElderForce(data,13)); cell.indicatorSeries[id]=s; }
      else if (id === 'eom') { const s = cell.chart.addLineSeries({color:IND_COLORS.eom,lineWidth:1,priceScaleId:'eom',lastValueVisible:false,priceLineVisible:false}); s.setData(calcEOM(data,14)); cell.indicatorSeries[id]=s; }
      else if (id === 'ppo') {
        const pp = calcPPO(data,12,26,9);
        const sp = cell.chart.addLineSeries({color:IND_COLORS.ppo,lineWidth:1,priceScaleId:'ppo',lastValueVisible:false,priceLineVisible:false});
        const ss = cell.chart.addLineSeries({color:'#f7a21b',lineWidth:1,lineStyle:2,priceScaleId:'ppo',lastValueVisible:false,priceLineVisible:false});
        sp.setData(pp.ppo); ss.setData(pp.signal);
        cell.indicatorSeries[id] = [sp,ss];
      }
      else if (id === 'massindex') { const s = cell.chart.addLineSeries({color:IND_COLORS.massindex,lineWidth:1,priceScaleId:'massindex',lastValueVisible:false,priceLineVisible:false}); s.setData(calcMassIndex(data,25)); cell.indicatorSeries[id]=s; }
      else if (id === 'chop') { const s = cell.chart.addLineSeries({color:IND_COLORS.chop,lineWidth:1,priceScaleId:'chop',lastValueVisible:false,priceLineVisible:false}); s.setData(calcChop(data,14)); cell.indicatorSeries[id]=s; }
      else if (id === 'smierg') {
        const sm = calcSMIErgodic(data,5,20,5);
        const ss = cell.chart.addLineSeries({color:IND_COLORS.smierg,lineWidth:1,priceScaleId:'smierg',lastValueVisible:false,priceLineVisible:false});
        const sg = cell.chart.addLineSeries({color:'#ff4081',lineWidth:1,lineStyle:2,priceScaleId:'smierg',lastValueVisible:false,priceLineVisible:false});
        ss.setData(sm.smi); sg.setData(sm.signal);
        cell.indicatorSeries[id] = [ss,sg];
      }
      // New Volume
      else if (id === 'netvol') { const s = cell.chart.addHistogramSeries({priceScaleId:'netvol',lastValueVisible:false,priceLineVisible:false}); s.setData(calcNetVol(data)); cell.indicatorSeries[id]=s; }
      else if (id === 'pvt') { const s = cell.chart.addLineSeries({color:IND_COLORS.pvt,lineWidth:1,priceScaleId:'pvt',lastValueVisible:false,priceLineVisible:false}); s.setData(calcPVT(data)); cell.indicatorSeries[id]=s; }
      else if (id === 'volosc') { const s = cell.chart.addLineSeries({color:IND_COLORS.volosc,lineWidth:1,priceScaleId:'volosc',lastValueVisible:false,priceLineVisible:false}); s.setData(calcVolOsc(data,5,10)); cell.indicatorSeries[id]=s; }
      else if (id === 'chaikinosc') { const s = cell.chart.addLineSeries({color:IND_COLORS.chaikinosc,lineWidth:1,priceScaleId:'chaikinosc',lastValueVisible:false,priceLineVisible:false}); s.setData(calcChaikinOsc(data,3,10)); cell.indicatorSeries[id]=s; }
      // New Trend
      else if (id === 'vortex') {
        const vx = calcVortex(data,14);
        const sp = cell.chart.addLineSeries({color:'#26a69a',lineWidth:1,priceScaleId:'vortex',lastValueVisible:false,priceLineVisible:false});
        const sm = cell.chart.addLineSeries({color:'#ef5350',lineWidth:1,priceScaleId:'vortex',lastValueVisible:false,priceLineVisible:false});
        sp.setData(vx.plus); sm.setData(vx.minus);
        cell.indicatorSeries[id] = [sp,sm];
      }
      else if (id === 'kst') {
        const k = calcKST(data);
        const sk = cell.chart.addLineSeries({color:IND_COLORS.kst,lineWidth:1,priceScaleId:'kst',lastValueVisible:false,priceLineVisible:false});
        const ss = cell.chart.addLineSeries({color:'#ff4081',lineWidth:1,lineStyle:2,priceScaleId:'kst',lastValueVisible:false,priceLineVisible:false});
        sk.setData(k.kst); ss.setData(k.signal);
        cell.indicatorSeries[id] = [sk,ss];
      }
      else if (id === 'chandekroll') {
        const ck = calcChandeKroll(data,10,1,9);
        const ss = cell.chart.addLineSeries({color:'#ef5350',lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false});
        const sl = cell.chart.addLineSeries({color:'#26a69a',lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false});
        ss.setData(ck.short); sl.setData(ck.long);
        cell.indicatorSeries[id] = [ss,sl];
      }
      else if (id === 'zigzag') { const s = cell.chart.addLineSeries({color:IND_COLORS.zigzag,lineWidth:2,lastValueVisible:false,priceLineVisible:false}); s.setData(calcZigZag(data,5)); cell.indicatorSeries[id]=s; }
      else if (id === 'fractal') {
        const f = calcFractals(data,2);
        const allMarkers = [...f.up, ...f.down].sort((a,b) => a.time - b.time);
        if (allMarkers.length) cell.series.setMarkers(allMarkers);
      }
      // New S/R
      else if (id === 'hilo52w') {
        const hl = calc52WHL(data);
        const sh = cell.chart.addLineSeries({color:'#00e676',lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false,title:'52W High'});
        const sl = cell.chart.addLineSeries({color:'#ff1744',lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false,title:'52W Low'});
        sh.setData(hl.high); sl.setData(hl.low);
        cell.indicatorSeries[id] = [sh,sl];
      }
      else if (id === 'pricechannel') {
        const pc = calcPriceChannel(data,20);
        const su = cell.chart.addLineSeries({color:IND_COLORS.pricechannel,lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false});
        const sl = cell.chart.addLineSeries({color:IND_COLORS.pricechannel,lineWidth:1,lineStyle:2,lastValueVisible:false,priceLineVisible:false});
        su.setData(pc.upper); sl.setData(pc.lower);
        cell.indicatorSeries[id] = [su,sl];
      }
      // Volume Profile (Visible Range)
      else if (id === 'vp') {
        renderVolumeProfile(cellIdx, data);
      }
      // Pattern Detection
      else if (id === 'candlepatterns') {
        const markers = detectCandlePatterns(data);
        if (markers.length) { const existing = cell.series.markers() || []; cell.series.setMarkers([...existing, ...markers].sort((a,b)=>a.time-b.time)); }
      }
      else if (id === 'chartpatterns') {
        const markers = detectChartPatterns(data);
        if (markers.length) { const existing = cell.series.markers() || []; cell.series.setMarkers([...existing, ...markers].sort((a,b)=>a.time-b.time)); }
      }
      else if (id === 'divergence') {
        const markers = detectRSIDivergence(data);
        if (markers.length) { const existing = cell.series.markers() || []; cell.series.setMarkers([...existing, ...markers].sort((a,b)=>a.time-b.time)); }
      }

    } catch (e) { console.error(`Indicator ${id} error:`, e); }
  });
}

// ==========================================
// VOLUME PROFILE (VISIBLE RANGE)
// ==========================================
function renderVolumeProfile(cellIdx, data) {
  const cell = STATE.cells[cellIdx];
  if (!cell.chart || data.length < 10) return;

  // Remove old VP series
  Object.keys(cell.indicatorSeries).filter(k => k.startsWith('vp_')).forEach(k => {
    try { cell.chart.removeSeries(cell.indicatorSeries[k]); } catch(e) {}
    delete cell.indicatorSeries[k];
  });

  // Calculate volume distribution by price
  const minPrice = Math.min(...data.map(d => d.low));
  const maxPrice = Math.max(...data.map(d => d.high));
  const range = maxPrice - minPrice;
  if (range <= 0) return;

  const numBins = 40; // Number of price levels
  const binSize = range / numBins;
  const bins = new Array(numBins).fill(0);
  const buyBins = new Array(numBins).fill(0);
  const sellBins = new Array(numBins).fill(0);

  // Distribute volume across price bins
  data.forEach(d => {
    const midPrice = (d.high + d.low) / 2;
    const binIdx = Math.min(numBins - 1, Math.floor((midPrice - minPrice) / binSize));
    bins[binIdx] += d.volume;
    if (d.close >= d.open) buyBins[binIdx] += d.volume;
    else sellBins[binIdx] += d.volume;
  });

  const maxVol = Math.max(...bins);
  if (maxVol <= 0) return;

  // Find POC (Point of Control) - highest volume price level
  const pocIdx = bins.indexOf(maxVol);
  const pocPrice = minPrice + (pocIdx + 0.5) * binSize;

  // Find Value Area (70% of total volume)
  const totalVol = bins.reduce((s, v) => s + v, 0);
  const vaTarget = totalVol * 0.7;
  let vaVol = bins[pocIdx];
  let vaHigh = pocIdx, vaLow = pocIdx;
  while (vaVol < vaTarget && (vaHigh < numBins - 1 || vaLow > 0)) {
    const above = vaHigh < numBins - 1 ? bins[vaHigh + 1] : 0;
    const below = vaLow > 0 ? bins[vaLow - 1] : 0;
    if (above >= below && vaHigh < numBins - 1) { vaHigh++; vaVol += above; }
    else if (vaLow > 0) { vaLow--; vaVol += below; }
    else { vaHigh++; vaVol += above; }
  }

  const vahPrice = minPrice + (vaHigh + 1) * binSize;
  const valPrice = minPrice + vaLow * binSize;

  // Draw POC line
  const pocSeries = cell.chart.addLineSeries({
    color: '#f7a21b', lineWidth: 2, lineStyle: 2,
    priceScaleId: 'right', lastValueVisible: true, priceLineVisible: false, title: 'POC'
  });
  pocSeries.setData(data.map(d => ({ time: d.time, value: pocPrice })));
  cell.indicatorSeries['vp_poc'] = pocSeries;

  // Draw VAH/VAL lines
  const vahSeries = cell.chart.addLineSeries({
    color: 'rgba(41,98,255,.5)', lineWidth: 1, lineStyle: 2,
    priceScaleId: 'right', lastValueVisible: true, priceLineVisible: false, title: 'VAH'
  });
  vahSeries.setData(data.map(d => ({ time: d.time, value: vahPrice })));
  cell.indicatorSeries['vp_vah'] = vahSeries;

  const valSeries = cell.chart.addLineSeries({
    color: 'rgba(41,98,255,.5)', lineWidth: 1, lineStyle: 2,
    priceScaleId: 'right', lastValueVisible: true, priceLineVisible: false, title: 'VAL'
  });
  valSeries.setData(data.map(d => ({ time: d.time, value: valPrice })));
  cell.indicatorSeries['vp_val'] = valSeries;

  // Draw histogram bars as horizontal lines at each price level (using colored area series)
  for (let i = 0; i < numBins; i++) {
    if (bins[i] / maxVol < 0.05) continue; // Skip tiny bars
    const pct = bins[i] / maxVol;
    const price = minPrice + (i + 0.5) * binSize;
    const isPoc = i === pocIdx;
    const inVA = i >= vaLow && i <= vaHigh;

    const color = isPoc ? 'rgba(247,162,27,.3)' : inVA ? 'rgba(41,98,255,.15)' : 'rgba(120,123,134,.1)';
    const s = cell.chart.addLineSeries({
      color, lineWidth: Math.max(1, Math.round(pct * 6)),
      priceScaleId: 'right', lastValueVisible: false, priceLineVisible: false
    });
    // Only draw for the visible data range
    const lastN = Math.max(1, Math.round(data.length * pct * 0.3));
    s.setData(data.slice(-lastN).map(d => ({ time: d.time, value: price })));
    cell.indicatorSeries['vp_bin' + i] = s;
  }
}

// ==========================================
// SPREAD / RATIO CHART
// ==========================================
async function loadSpreadChart(sym1, sym2, mode) {
  // mode: 'ratio', 'spread', 'pct'
  mode = mode || 'ratio';
  const [data1, data2] = await Promise.all([
    fetchBars(sym1, STATE.timeframe.multiplier, STATE.timeframe.timespan),
    fetchBars(sym2, STATE.timeframe.multiplier, STATE.timeframe.timespan)
  ]);

  if (!data1.length || !data2.length) { toast('Failed to load spread data', 'error'); return; }

  // Match timestamps
  const map2 = {};
  data2.forEach(d => map2[d.time] = d);

  const spreadData = [];
  data1.forEach(d => {
    if (map2[d.time]) {
      let value;
      if (mode === 'ratio') value = d.close / map2[d.time].close;
      else if (mode === 'spread') value = d.close - map2[d.time].close;
      else {
        const base1 = data1[0].close, base2 = data2[0].close;
        value = ((d.close / base1) - (map2[d.time].close / base2)) * 100;
      }
      spreadData.push({ time: d.time, value });
    }
  });

  if (!spreadData.length) { toast('No matching data points', 'error'); return; }

  const cellIdx = STATE.activeCell;
  const cell = STATE.cells[cellIdx];

  // Remove old spread
  if (cell.indicatorSeries['spread']) {
    cell.chart.removeSeries(cell.indicatorSeries['spread']);
    delete cell.indicatorSeries['spread'];
  }

  const s = cell.chart.addLineSeries({
    color: '#7b61ff', lineWidth: 2, priceScaleId: 'spread',
    lastValueVisible: true, priceLineVisible: true,
    title: `${sym1}/${sym2} ${mode}`
  });
  s.setData(spreadData);
  cell.indicatorSeries['spread'] = s;
  toast(`${mode.toUpperCase()}: ${sym1} vs ${sym2}`, 'info');
}

// ==========================================
// SEARCH
// ==========================================
let searchTimeout;
function toggleSearch() {
  const drop = document.getElementById('searchDrop');
  drop.classList.toggle('show');
  if (drop.classList.contains('show')) {
    document.getElementById('searchInput').focus();
    document.getElementById('searchInput').value = '';
    document.getElementById('searchResults').innerHTML = '';
  }
}

document.getElementById('searchInput').addEventListener('input', function() {
  clearTimeout(searchTimeout);
  const q = this.value.trim();
  if (q.length < 1) { document.getElementById('searchResults').innerHTML = ''; return; }
  searchTimeout = setTimeout(() => searchSymbols(q), 300);
});

async function searchSymbols(query) {
  try {
    const url = `${API_BASE}/v3/reference/tickers?search=${query}&active=true&limit=25&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    const results = json.results || [];
    const activeFilter = document.querySelector('.search-tab.active').dataset.filter;

    const filtered = results.filter(r => {
      if (activeFilter === 'all') return true;
      if (activeFilter === 'stocks') return r.market === 'stocks';
      if (activeFilter === 'crypto') return r.market === 'crypto';
      if (activeFilter === 'forex') return r.market === 'fx';
      if (activeFilter === 'etf') return r.type === 'ETF';
      return true;
    });

    document.getElementById('searchResults').innerHTML = filtered.map(r => `
      <div class="search-item" onclick="selectSymbol('${r.ticker}')">
        <div class="si-icon">${r.ticker.substring(0, 2)}</div>
        <div class="si-info">
          <div class="si-ticker">${r.ticker}</div>
          <div class="si-name">${r.name || ''}</div>
        </div>
        <span class="si-exchange">${r.primary_exchange || r.market || ''}</span>
        <span class="si-type">${r.type || r.market || ''}</span>
      </div>
    `).join('');
  } catch (e) { console.error('Search error:', e); }
}

function selectSymbol(sym) {
  document.getElementById('searchDrop').classList.remove('show');
  loadSymbol(sym, STATE.activeCell);
}

// Search tabs
document.querySelectorAll('.search-tab').forEach(tab => {
  tab.addEventListener('click', function() {
    document.querySelectorAll('.search-tab').forEach(t => t.classList.remove('active'));
    this.classList.add('active');
    const q = document.getElementById('searchInput').value.trim();
    if (q) searchSymbols(q);
  });
});

// ==========================================
// TIMEFRAMES
// ==========================================
document.querySelectorAll('.tf-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    STATE.timeframe = { multiplier: parseInt(this.dataset.m), timespan: this.dataset.t };
    loadSymbol(STATE.symbol, STATE.activeCell);
  });
});

// ==========================================
// CHART TYPES
// ==========================================
document.querySelectorAll('.ct-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.ct-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    STATE.chartType = this.dataset.type;
    rebuildAllCharts();
    // Reload data for active cell
    const cell = STATE.cells[STATE.activeCell];
    if (cell.data.length) {
      setChartData(STATE.activeCell, cell.data);
      applyIndicators(STATE.activeCell);
    }
  });
});

// ==========================================
// LAYOUTS
// ==========================================
function setLayout(layout) {
  STATE.layout = layout;
  const grid = document.getElementById('chartGrid');
  grid.className = 'chart-grid layout-' + layout;

  const count = layout === 1 ? 1 : layout === '2h' || layout === '2v' ? 2 : layout === 3 ? 3 : layout === 4 ? 4 : 6;
  grid.innerHTML = '';

  for (let i = 0; i < count; i++) {
    const cell = document.createElement('div');
    cell.className = 'chart-cell' + (i === 0 ? ' active' : '');
    cell.id = `cell${i}`;
    cell.onclick = () => setActiveCell(i);
    cell.innerHTML = `
      <div class="cell-header" ${count === 1 ? 'style="display:none"' : ''}>
        <span class="cell-sym" onclick="event.stopPropagation();promptCellSymbol(${i})">${STATE.cells[i].symbol}</span>
        <span class="cell-price"></span>
      </div>
      <div class="chart-watermark" id="watermark${i}" ${count === 1 ? '' : 'style="font-size:32px"'}>${STATE.cells[i].symbol}</div>
      <div class="cell-chart" id="chartDiv${i}"></div>
    `;
    grid.appendChild(cell);
  }

  // Create charts
  setTimeout(() => {
    for (let i = 0; i < count; i++) {
      createChart(i);
      loadSymbol(STATE.cells[i].symbol, i);
    }
    STATE.activeCell = 0;
  }, 50);
}

function setActiveCell(idx) {
  document.querySelectorAll('.chart-cell').forEach(c => c.classList.remove('active'));
  document.getElementById(`cell${idx}`).classList.add('active');
  STATE.activeCell = idx;
  STATE.symbol = STATE.cells[idx].symbol;
  document.getElementById('symTicker').textContent = STATE.symbol;
  document.getElementById('headerSym').textContent = STATE.symbol;
}

function promptCellSymbol(idx) {
  const sym = prompt('Enter symbol:', STATE.cells[idx].symbol);
  if (sym) loadSymbol(sym.toUpperCase(), idx);
}

// ==========================================
// COMPARE OVERLAY
// ==========================================
async function loadCompareOverlays(cellIdx) {
  const cell = STATE.cells[cellIdx];
  const pctMode = document.getElementById('comparePctMode')?.checked || false;

  STATE.compareSymbols.forEach(async (cSym, i) => {
    const data = await fetchBars(cSym, STATE.timeframe.multiplier, STATE.timeframe.timespan);
    if (data.length) {
      let lineData;
      if (pctMode) {
        // Normalize to % change from first bar
        const base = data[0].close;
        lineData = data.map(d => ({ time: d.time, value: ((d.close - base) / base) * 100 }));
      } else {
        lineData = data.map(d => ({ time: d.time, value: d.close }));
      }
      const scaleId = pctMode ? 'pct_compare' : ('compare' + i);
      const s = cell.chart.addLineSeries({
        color: COMPARE_COLORS[i % COMPARE_COLORS.length], lineWidth: 2,
        priceScaleId: scaleId, lastValueVisible: true, priceLineVisible: false,
        title: pctMode ? `${cSym} %` : cSym,
        priceFormat: pctMode ? { type: 'custom', formatter: v => v.toFixed(2) + '%' } : undefined
      });
      s.setData(lineData);
      cell.indicatorSeries['compare_' + cSym] = s;
    }
  });

  // Also normalize the main symbol in % mode
  if (pctMode && cell.data.length && STATE.compareSymbols.length > 0) {
    const base = cell.data[0].close;
    const mainPctData = cell.data.map(d => ({ time: d.time, value: ((d.close - base) / base) * 100 }));
    // Add main symbol as a % line too
    if (cell.indicatorSeries['compare_main']) {
      cell.chart.removeSeries(cell.indicatorSeries['compare_main']);
    }
    const mainLine = cell.chart.addLineSeries({
      color: '#2962ff', lineWidth: 2, priceScaleId: 'pct_compare',
      lastValueVisible: true, priceLineVisible: false,
      title: STATE.symbol + ' %',
      priceFormat: { type: 'custom', formatter: v => v.toFixed(2) + '%' }
    });
    mainLine.setData(mainPctData);
    cell.indicatorSeries['compare_main'] = mainLine;
  }

  renderCompareLegend();
}

function reloadCompareOverlays() {
  const cellIdx = STATE.activeCell;
  const cell = STATE.cells[cellIdx];
  // Remove existing compare series
  Object.keys(cell.indicatorSeries).filter(k => k.startsWith('compare_')).forEach(k => {
    try { cell.chart.removeSeries(cell.indicatorSeries[k]); } catch(e) {}
    delete cell.indicatorSeries[k];
  });
  loadCompareOverlays(cellIdx);
}

function renderCompareLegend() {
  const legend = document.getElementById('compareLegend');
  if (STATE.compareSymbols.length === 0) { legend.style.display = 'none'; return; }
  legend.style.display = 'flex';
  legend.innerHTML = STATE.compareSymbols.map((sym, i) => `
    <span class="compare-item">
      <span class="dot" style="background:${COMPARE_COLORS[i % COMPARE_COLORS.length]}"></span>
      ${sym}
      <span class="compare-remove" onclick="removeCompare('${sym}')">‚úï</span>
    </span>
  `).join('');
}

function removeCompare(sym) {
  STATE.compareSymbols = STATE.compareSymbols.filter(s => s !== sym);
  rebuildAllCharts();
  const cell = STATE.cells[STATE.activeCell];
  if (cell.data.length) { setChartData(STATE.activeCell, cell.data); applyIndicators(STATE.activeCell); loadCompareOverlays(STATE.activeCell); }
}

function openCompareModal() {
  document.getElementById('compareModal').classList.add('show');
  document.getElementById('compareSearch').focus();
}

async function searchCompare() {
  const q = document.getElementById('compareSearch').value.trim();
  if (q.length < 1) return;
  try {
    const url = `${API_BASE}/v3/reference/tickers?search=${q}&active=true&limit=10&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    document.getElementById('compareResults').innerHTML = (json.results || []).map(r => `
      <div class="ind-item" onclick="addCompare('${r.ticker}')">
        <div><div class="ind-name">${r.ticker}</div><div class="ind-desc">${r.name || ''}</div></div>
      </div>
    `).join('');
  } catch (e) {}
}

function addCompare(sym) {
  if (STATE.compareSymbols.includes(sym)) return;
  STATE.compareSymbols.push(sym);
  closeModal('compareModal');
  loadCompareOverlays(STATE.activeCell);
  toast(`Added ${sym} comparison`, 'success');
}

function openSpreadDialog() {
  const sym1 = prompt('First symbol (numerator):', STATE.symbol);
  if (!sym1) return;
  const sym2 = prompt('Second symbol (denominator):', 'SPY');
  if (!sym2) return;
  const mode = prompt('Mode: ratio / spread / pct', 'ratio');
  if (!mode) return;
  loadSpreadChart(sym1.toUpperCase(), sym2.toUpperCase(), mode);
}

// ==========================================
// INDICATOR MODAL
// ==========================================
function openIndicatorModal() {
  document.getElementById('indicatorModal').classList.add('show');
  renderIndicatorList();
  document.getElementById('indSearch').focus();
}

function renderIndicatorList() {
  const cats = [...new Set(INDICATORS.map(i => i.cat))];
  document.getElementById('indCats').innerHTML = `<button class="ind-cat active" data-cat="all" onclick="filterIndCat(this)">All</button>` +
    cats.map(c => `<button class="ind-cat" data-cat="${c}" onclick="filterIndCat(this)">${c}</button>`).join('');
  filterIndicators();
}

function filterIndCat(el) {
  document.querySelectorAll('.ind-cat').forEach(c => c.classList.remove('active'));
  el.classList.add('active');
  filterIndicators();
}

function filterIndicators() {
  const q = (document.getElementById('indSearch').value || '').toLowerCase();
  const cat = document.querySelector('.ind-cat.active')?.dataset.cat || 'all';
  const list = INDICATORS.filter(i => {
    if (cat !== 'all' && i.cat !== cat) return false;
    if (q && !i.name.toLowerCase().includes(q) && !i.desc.toLowerCase().includes(q) && !i.id.toLowerCase().includes(q)) return false;
    return true;
  });
  document.getElementById('indList').innerHTML = list.map(i => `
    <div class="ind-item ${STATE.indicators.includes(i.id) ? 'active' : ''}" onclick="toggleIndicator('${i.id}')">
      <div><div class="ind-name">${i.name}</div><div class="ind-desc">${i.desc}</div></div>
      <span class="ind-check">‚úì</span>
    </div>
  `).join('');
}

function toggleIndicator(id) {
  const idx = STATE.indicators.indexOf(id);
  if (idx >= 0) STATE.indicators.splice(idx, 1); else STATE.indicators.push(id);
  filterIndicators();
  applyIndicators(STATE.activeCell);
}

// ==========================================
// WATCHLIST PANEL
// ==========================================
function renderWatchlistPanel() {
  let html = `
    <div class="wl-header">
      <select class="wl-select" id="wlSelect" onchange="switchWatchlist(this.value)">
        ${Object.keys(watchlists).map(k => `<option value="${k}" ${k === activeWatchlist ? 'selected' : ''}>${k}</option>`).join('')}
      </select>
      <div class="wl-actions">
        <button onclick="newWatchlist()" title="New Watchlist">+</button>
        <button onclick="renameWatchlist()" title="Rename">‚úé</button>
        <button onclick="deleteWatchlist()" title="Delete">üóë</button>
        <button onclick="duplicateWatchlist()" title="Duplicate">‚ßâ</button>
      </div>
    </div>
    <div class="wl-row header">
      <span>Symbol</span><span>Name</span><span style="text-align:right">Price</span><span style="text-align:right">Change</span>
    </div>
    <div id="wlRows"></div>
    <div class="wl-add">
      <input id="wlAddInput" placeholder="Add symbol... (e.g. TSLA)" onkeydown="if(event.key==='Enter')addToWatchlist(this.value)">
    </div>
  `;
  return html;
}

async function refreshWatchlist() {
  const syms = watchlists[activeWatchlist] || [];
  const container = document.getElementById('wlRows');
  if (!container) return;

  const rows = await Promise.all(syms.map(async sym => {
    try {
      const r = await fetchPrevDay(sym);
      if (r) {
        const chg = ((r.c - r.o) / r.o * 100).toFixed(2);
        return `<div class="wl-row" onclick="selectSymbol('${sym}')">
          <span class="sym">${sym.replace('X:','').replace('C:','')}</span>
          <span class="name" style="font-size:10px;color:var(--t3)">${formatVol(r.v || 0)}</span>
          <span class="prc">$${r.c?.toFixed(2) || '-'}</span>
          <span class="chg ${chg >= 0 ? 'up' : 'dn'}">${chg >= 0 ? '+' : ''}${chg}%<span class="remove-sym" onclick="event.stopPropagation();removeFromWatchlist('${sym}')">‚úï</span></span>
        </div>`;
      }
    } catch(e) {}
    return `<div class="wl-row" onclick="selectSymbol('${sym}')"><span class="sym">${sym}</span><span class="name">-</span><span class="prc">-</span><span class="chg">-</span></div>`;
  }));

  container.innerHTML = rows.join('');
}

function addToWatchlist(sym) {
  sym = sym.trim().toUpperCase();
  if (!sym) return;
  if (!watchlists[activeWatchlist]) watchlists[activeWatchlist] = [];
  if (!watchlists[activeWatchlist].includes(sym)) {
    watchlists[activeWatchlist].push(sym);
    saveWatchlists();
    refreshWatchlist();
    toast(`${sym} added to ${activeWatchlist}`, 'success');
  }
  document.getElementById('wlAddInput').value = '';
}

function removeFromWatchlist(sym) {
  watchlists[activeWatchlist] = watchlists[activeWatchlist].filter(s => s !== sym);
  saveWatchlists();
  refreshWatchlist();
}

function switchWatchlist(name) {
  activeWatchlist = name;
  localStorage.setItem('jh_active_wl', name);
  refreshWatchlist();
}

function newWatchlist() {
  const name = prompt('Watchlist name:');
  if (name && !watchlists[name]) { watchlists[name] = []; saveWatchlists(); activeWatchlist = name; togglePanel('watchlist'); toast(`Created "${name}"`, 'success'); }
}

function renameWatchlist() {
  const name = prompt('New name:', activeWatchlist);
  if (name && name !== activeWatchlist && !watchlists[name]) {
    watchlists[name] = watchlists[activeWatchlist];
    delete watchlists[activeWatchlist];
    activeWatchlist = name;
    saveWatchlists();
    togglePanel('watchlist');
  }
}

function deleteWatchlist() {
  if (Object.keys(watchlists).length <= 1) { toast('Cannot delete last watchlist', 'error'); return; }
  if (confirm(`Delete "${activeWatchlist}"?`)) {
    delete watchlists[activeWatchlist];
    activeWatchlist = Object.keys(watchlists)[0];
    saveWatchlists();
    togglePanel('watchlist');
  }
}

function duplicateWatchlist() {
  const name = activeWatchlist + ' Copy';
  watchlists[name] = [...watchlists[activeWatchlist]];
  activeWatchlist = name;
  saveWatchlists();
  togglePanel('watchlist');
  toast(`Duplicated as "${name}"`, 'success');
}

function saveWatchlists() {
  localStorage.setItem('jh_watchlists', JSON.stringify(watchlists));
  localStorage.setItem('jh_active_wl', activeWatchlist);
}

// ==========================================
// SCREENER PANEL
// ==========================================
function renderScreenerPanel() {
  return `
    <div class="screener-tabs">
      <button class="screener-tab active" onclick="loadScreener('gainers',this)">üî• Gainers</button>
      <button class="screener-tab" onclick="loadScreener('losers',this)">üìâ Losers</button>
      <button class="screener-tab" onclick="loadScreener('active',this)">‚ö° Most Active</button>
    </div>
    <div id="screenerRows"><div style="padding:20px;text-align:center;color:var(--t3)">Loading...</div></div>
  `;
}

async function loadScreener(type, btn) {
  if (btn) { document.querySelectorAll('.screener-tab').forEach(t => t.classList.remove('active')); btn.classList.add('active'); }
  const dir = type === 'losers' ? 'losers' : 'gainers';
  try {
    let tickers = await fetchMovers(dir);
    if (type === 'active') tickers.sort((a, b) => (b.day?.v || 0) - (a.day?.v || 0));
    tickers = tickers.slice(0, 30);

    document.getElementById('screenerRows').innerHTML = tickers.map(t => {
      const chg = t.todaysChangePerc?.toFixed(2) || '0';
      return `<div class="screener-row" onclick="selectSymbol('${t.ticker}')">
        <span class="sr-sym">${t.ticker}</span>
        <span class="sr-name">${formatVol(t.day?.v || 0)} vol</span>
        <span class="sr-prc">$${t.day?.c?.toFixed(2) || '-'}</span>
        <span class="sr-chg ${chg >= 0 ? 'up' : 'dn'}">${chg >= 0 ? '+' : ''}${chg}%</span>
      </div>`;
    }).join('');
  } catch(e) {
    document.getElementById('screenerRows').innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">Error loading data</div>';
  }
}

// ==========================================
// NEWS PANEL
// ==========================================
function renderNewsPanel() {
  return `<div id="newsRows"><div style="padding:20px;text-align:center;color:var(--t3)">Loading news...</div></div>`;
}

async function loadNews() {
  try {
    const url = `${API_BASE}/v2/reference/news?ticker=${STATE.symbol}&limit=30&apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    const articles = json.results || [];
    document.getElementById('newsRows').innerHTML = articles.map(a => {
      const time = new Date(a.published_utc).toLocaleString();
      return `<div class="news-item" onclick="window.open('${a.article_url}','_blank')">
        <div class="news-time">${time}</div>
        <div class="news-title">${a.title}</div>
        <div class="news-source">${a.publisher?.name || ''}</div>
      </div>`;
    }).join('') || '<div style="padding:20px;text-align:center;color:var(--t3)">No news found</div>';
  } catch(e) {
    document.getElementById('newsRows').innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">Error loading news</div>';
  }
}

// ==========================================
// DETAILS PANEL
// ==========================================
function renderDetailsPanel() {
  return `<div id="detailsGrid" class="detail-grid"><div style="padding:20px;text-align:center;color:var(--t3);grid-column:1/3">Loading...</div></div>`;
}

async function loadDetails() {
  try {
    const details = await fetchTickerDetails(STATE.symbol);
    if (!details) { document.getElementById('detailsGrid').innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">No details available</div>'; return; }

    const data = STATE.cells[STATE.activeCell].data;
    const last = data.length ? data[data.length - 1] : null;

    // Calculate 52-week high/low from data
    const oneYearAgo = last ? last.time - 365 * 86400 : 0;
    const yearData = data.filter(d => d.time >= oneYearAgo);
    const high52w = yearData.length ? Math.max(...yearData.map(b => b.high)) : 0;
    const low52w = yearData.length ? Math.min(...yearData.map(b => b.low)) : 0;

    // Calculate moving averages from actual data
    const sma20v = data.length >= 20 ? data.slice(-20).reduce((s,b) => s + b.close, 0) / 20 : 0;
    const sma50v = data.length >= 50 ? data.slice(-50).reduce((s,b) => s + b.close, 0) / 50 : 0;
    const sma200v = data.length >= 200 ? data.slice(-200).reduce((s,b) => s + b.close, 0) / 200 : 0;

    // Average volume
    const avgVol30 = data.length >= 30 ? data.slice(-30).reduce((s,b) => s + b.volume, 0) / 30 : 0;
    const avgVol10 = data.length >= 10 ? data.slice(-10).reduce((s,b) => s + b.volume, 0) / 10 : 0;

    // Relative volume
    const relVol = avgVol30 > 0 && last ? (last.volume / avgVol30).toFixed(2) : '-';

    // Beta calculation (simplified)
    const volatility = yearData.length >= 20 ? Math.sqrt(yearData.slice(-20).reduce((s, b, i, arr) => {
      if (i === 0) return 0;
      const ret = Math.log(b.close / arr[i-1].close);
      return s + ret * ret;
    }, 0) / 19) * Math.sqrt(252) * 100 : 0;

    // All-time high/low from loaded data
    const allHigh = data.length ? Math.max(...data.map(b => b.high)) : 0;
    const allLow = data.length ? Math.min(...data.map(b => b.low)) : 0;

    // % from 52W high
    const pctFrom52wHigh = high52w && last ? ((last.close - high52w) / high52w * 100).toFixed(2) : '-';
    const pctFrom52wLow = low52w && last ? ((last.close - low52w) / low52w * 100).toFixed(2) : '-';

    // Performance calculations
    const calc_perf = (days) => {
      if (data.length <= days) return '-';
      const old = data[data.length - 1 - days].close;
      return ((last.close - old) / old * 100).toFixed(2);
    };
    const perf1d = calc_perf(1), perf5d = calc_perf(5), perf1m = calc_perf(22), perf3m = calc_perf(66);
    const perf6m = calc_perf(132), perf1y = calc_perf(252), perfYTD = '-';

    // Total data range
    const dataFrom = data.length ? new Date(data[0].time * 1000).toLocaleDateString() : '-';
    const dataTo = data.length ? new Date(data[data.length-1].time * 1000).toLocaleDateString() : '-';

    const rows = [
      ['Company', details.name || '-'],
      ['Ticker', details.ticker || STATE.symbol],
      ['Exchange', details.primary_exchange || '-'],
      ['Type', details.type || '-'],
      ['Currency', details.currency_name?.toUpperCase() || 'USD'],
      ['Locale', details.locale || '-'],
      ['Market Cap', details.market_cap ? '$' + formatNum(details.market_cap) : '-'],
      ['Shares Out', details.share_class_shares_outstanding ? formatNum(details.share_class_shares_outstanding) : '-'],
      ['Float Shares', details.weighted_shares_outstanding ? formatNum(details.weighted_shares_outstanding) : '-'],
      ['List Date', details.list_date || '-'],
      ['SIC Code', details.sic_code || '-'],
      ['SIC Industry', details.sic_description || '-'],
      ['<b style="color:var(--blue)">‚îÄ‚îÄ Price ‚îÄ‚îÄ</b>', ''],
      ['Last Price', last ? '$' + last.close.toFixed(2) : '-'],
      ['Session High', last ? '$' + last.high.toFixed(2) : '-'],
      ['Session Low', last ? '$' + last.low.toFixed(2) : '-'],
      ['Session Volume', last ? formatVol(last.volume) : '-'],
      ['VWAP', last && last.vwap ? '$' + last.vwap.toFixed(2) : '-'],
      ['Trades', last && last.trades ? formatNum(last.trades) : '-'],
      ['<b style="color:var(--blue)">‚îÄ‚îÄ 52 Week ‚îÄ‚îÄ</b>', ''],
      ['52W High', high52w ? '$' + high52w.toFixed(2) : '-'],
      ['52W Low', low52w ? '$' + low52w.toFixed(2) : '-'],
      ['% from 52W High', pctFrom52wHigh !== '-' ? pctFrom52wHigh + '%' : '-'],
      ['% from 52W Low', pctFrom52wLow !== '-' ? '+' + pctFrom52wLow + '%' : '-'],
      ['<b style="color:var(--blue)">‚îÄ‚îÄ All-Time ‚îÄ‚îÄ</b>', ''],
      ['All-Time High', allHigh ? '$' + allHigh.toFixed(2) : '-'],
      ['All-Time Low', allLow ? '$' + allLow.toFixed(2) : '-'],
      ['<b style="color:var(--blue)">‚îÄ‚îÄ Averages ‚îÄ‚îÄ</b>', ''],
      ['SMA 20', sma20v ? '$' + sma20v.toFixed(2) : '-'],
      ['SMA 50', sma50v ? '$' + sma50v.toFixed(2) : '-'],
      ['SMA 200', sma200v ? '$' + sma200v.toFixed(2) : '-'],
      ['Avg Vol (10D)', formatVol(avgVol10)],
      ['Avg Vol (30D)', formatVol(avgVol30)],
      ['Relative Volume', relVol + 'x'],
      ['Volatility (Ann.)', volatility ? volatility.toFixed(1) + '%' : '-'],
      ['<b style="color:var(--blue)">‚îÄ‚îÄ Performance ‚îÄ‚îÄ</b>', ''],
      ['1 Day', perf1d !== '-' ? `<span class="${perf1d>=0?'up':'dn'}" style="color:var(--${perf1d>=0?'green':'red'})">${perf1d>=0?'+':''}${perf1d}%</span>` : '-'],
      ['5 Days', perf5d !== '-' ? `<span style="color:var(--${perf5d>=0?'green':'red'})">${perf5d>=0?'+':''}${perf5d}%</span>` : '-'],
      ['1 Month', perf1m !== '-' ? `<span style="color:var(--${perf1m>=0?'green':'red'})">${perf1m>=0?'+':''}${perf1m}%</span>` : '-'],
      ['3 Months', perf3m !== '-' ? `<span style="color:var(--${perf3m>=0?'green':'red'})">${perf3m>=0?'+':''}${perf3m}%</span>` : '-'],
      ['6 Months', perf6m !== '-' ? `<span style="color:var(--${perf6m>=0?'green':'red'})">${perf6m>=0?'+':''}${perf6m}%</span>` : '-'],
      ['1 Year', perf1y !== '-' ? `<span style="color:var(--${perf1y>=0?'green':'red'})">${perf1y>=0?'+':''}${perf1y}%</span>` : '-'],
      ['<b style="color:var(--blue)">‚îÄ‚îÄ Data ‚îÄ‚îÄ</b>', ''],
      ['Total Bars', data.length.toLocaleString()],
      ['Data From', dataFrom],
      ['Data To', dataTo],
    ];

    if (details.homepage_url) {
      rows.push(['Website', `<a href="${details.homepage_url}" target="_blank" style="color:var(--blue);font-size:11px">${details.homepage_url}</a>`]);
    }

    if (details.description) {
      rows.push(['<b style="color:var(--blue)">‚îÄ‚îÄ Description ‚îÄ‚îÄ</b>', '']);
      rows.push([details.description.substring(0, 500) + (details.description.length > 500 ? '...' : ''), '']);
    }

    document.getElementById('detailsGrid').innerHTML = rows.map(([label, val]) => {
      if (!val && val !== 0) return `<div class="detail-cell" style="grid-column:1/3"><div class="dl">${label}</div></div>`;
      return `<div class="detail-cell"><div class="dl">${label}</div><div class="dv">${val}</div></div>`;
    }).join('');
  } catch(e) { console.error('Details error:', e); }
}

// ==========================================
// TECHNICAL ANALYSIS PANEL
// ==========================================
function renderTAPanel() {
  return `
    <div class="ta-gauge" id="taGauge"><div style="padding:20px;color:var(--t3)">Calculating...</div></div>
    <div class="ta-table" id="taTable"></div>
  `;
}

function calcTechnicalAnalysis() {
  const data = STATE.cells[STATE.activeCell].data;
  if (data.length < 50) return;

  const last = data[data.length - 1].close;
  const signals = [];

  // Moving Averages
  const sma10 = calcSMA(data, 10); const sma10v = sma10.length ? sma10[sma10.length-1].value : 0;
  const sma20 = calcSMA(data, 20); const sma20v = sma20.length ? sma20[sma20.length-1].value : 0;
  const sma50 = calcSMA(data, 50); const sma50v = sma50.length ? sma50[sma50.length-1].value : 0;
  const sma100 = calcSMA(data, 100); const sma100v = sma100.length ? sma100[sma100.length-1].value : 0;
  const sma200 = calcSMA(data, 200); const sma200v = sma200.length ? sma200[sma200.length-1].value : 0;
  const ema10 = calcEMA(data, 10); const ema10v = ema10.length ? ema10[ema10.length-1].value : 0;
  const ema20 = calcEMA(data, 20); const ema20v = ema20.length ? ema20[ema20.length-1].value : 0;
  const ema50 = calcEMA(data, 50); const ema50v = ema50.length ? ema50[ema50.length-1].value : 0;

  signals.push({ name: 'SMA (10)', value: sma10v.toFixed(2), signal: last > sma10v ? 'Buy' : 'Sell' });
  signals.push({ name: 'SMA (20)', value: sma20v.toFixed(2), signal: last > sma20v ? 'Buy' : 'Sell' });
  signals.push({ name: 'SMA (50)', value: sma50v.toFixed(2), signal: last > sma50v ? 'Buy' : 'Sell' });
  signals.push({ name: 'SMA (100)', value: sma100v.toFixed(2), signal: last > sma100v ? 'Buy' : 'Sell' });
  signals.push({ name: 'SMA (200)', value: sma200v.toFixed(2), signal: last > sma200v ? 'Buy' : 'Sell' });
  signals.push({ name: 'EMA (10)', value: ema10v.toFixed(2), signal: last > ema10v ? 'Buy' : 'Sell' });
  signals.push({ name: 'EMA (20)', value: ema20v.toFixed(2), signal: last > ema20v ? 'Buy' : 'Sell' });
  signals.push({ name: 'EMA (50)', value: ema50v.toFixed(2), signal: last > ema50v ? 'Buy' : 'Sell' });

  // RSI
  const rsi = calcRSI(data, 14); const rsiv = rsi.length ? rsi[rsi.length-1].value : 50;
  signals.push({ name: 'RSI (14)', value: rsiv.toFixed(2), signal: rsiv < 30 ? 'Buy' : rsiv > 70 ? 'Sell' : 'Neutral' });

  // MACD
  const macd = calcMACD(data);
  const macdLast = macd.macdLine.length ? macd.macdLine[macd.macdLine.length-1].value : 0;
  const sigLast = macd.signal.length ? macd.signal[macd.signal.length-1].value : 0;
  signals.push({ name: 'MACD', value: macdLast.toFixed(4), signal: macdLast > sigLast ? 'Buy' : 'Sell' });

  // Stochastic
  const stoch = calcStochastic(data, 14, 3, 3);
  const stochK = stoch.k.length ? stoch.k[stoch.k.length-1].value : 50;
  signals.push({ name: 'Stochastic', value: stochK.toFixed(2), signal: stochK < 20 ? 'Buy' : stochK > 80 ? 'Sell' : 'Neutral' });

  // CCI
  const cci = calcCCI(data, 20); const cciv = cci.length ? cci[cci.length-1].value : 0;
  signals.push({ name: 'CCI (20)', value: cciv.toFixed(2), signal: cciv < -100 ? 'Buy' : cciv > 100 ? 'Sell' : 'Neutral' });

  // Williams %R
  const willr = calcWilliamsR(data, 14); const willrv = willr.length ? willr[willr.length-1].value : -50;
  signals.push({ name: 'Williams %R', value: willrv.toFixed(2), signal: willrv < -80 ? 'Buy' : willrv > -20 ? 'Sell' : 'Neutral' });

  const buyCount = signals.filter(s => s.signal === 'Buy').length;
  const sellCount = signals.filter(s => s.signal === 'Sell').length;
  const neutralCount = signals.filter(s => s.signal === 'Neutral').length;

  const overall = buyCount > sellCount + 2 ? 'STRONG BUY' : buyCount > sellCount ? 'BUY' : sellCount > buyCount + 2 ? 'STRONG SELL' : sellCount > buyCount ? 'SELL' : 'NEUTRAL';
  const overallClass = overall.includes('BUY') ? 'buy' : overall.includes('SELL') ? 'sell' : 'neutral';

  document.getElementById('taGauge').innerHTML = `
    <div class="ta-label ${overallClass}">${overall}</div>
    <div class="ta-summary">
      <div class="ta-box buy"><div class="ta-count">${buyCount}</div><div class="ta-type">Buy</div></div>
      <div class="ta-box neutral"><div class="ta-count">${neutralCount}</div><div class="ta-type">Neutral</div></div>
      <div class="ta-box sell"><div class="ta-count">${sellCount}</div><div class="ta-type">Sell</div></div>
    </div>
  `;

  document.getElementById('taTable').innerHTML =
    `<div class="ta-row header"><span>Indicator</span><span style="text-align:center">Value</span><span style="text-align:center">Signal</span></div>` +
    signals.map(s => `
      <div class="ta-row">
        <span>${s.name}</span>
        <span style="text-align:center;font-family:'JetBrains Mono',monospace;font-size:11px">${s.value}</span>
        <span class="signal ${s.signal.toLowerCase()}">${s.signal}</span>
      </div>
    `).join('');
}

// ==========================================
// NOTES PANEL
// ==========================================
function renderNotesPanel() {
  const note = symbolNotes[STATE.symbol] || '';
  return `
    <div class="notes-area">
      <div class="panel-section-title">Notes for ${STATE.symbol} <span class="notes-saved" id="notesSaved">‚úì Saved</span></div>
      <textarea id="notesText" oninput="saveNotes()" placeholder="Add notes for ${STATE.symbol}...">${note}</textarea>
    </div>
  `;
}

function loadNotes(sym) {
  const textarea = document.getElementById('notesText');
  if (textarea) textarea.value = symbolNotes[sym] || '';
}

let notesTimeout;
function saveNotes() {
  clearTimeout(notesTimeout);
  notesTimeout = setTimeout(() => {
    symbolNotes[STATE.symbol] = document.getElementById('notesText').value;
    localStorage.setItem('jh_notes', JSON.stringify(symbolNotes));
    const saved = document.getElementById('notesSaved');
    if (saved) { saved.style.display = 'inline'; setTimeout(() => saved.style.display = 'none', 2000); }
  }, 500);
}

// ==========================================
// HOTKEYS PANEL
// ==========================================
function renderHotkeysPanel() {
  const hotkeys = [
    ['/', 'Symbol Search'],
    ['Esc', 'Close Panel/Modal'],
    ['1-9', 'Switch Timeframe'],
    ['Alt+1', 'Single Layout'],
    ['Alt+2', 'Split Layout'],
    ['Alt+4', 'Quad Layout'],
    ['Alt+W', 'Toggle Watchlist'],
    ['Alt+N', 'Toggle News'],
    ['Alt+S', 'Screenshot'],
    ['Alt+A', 'Create Alert'],
    ['Alt+I', 'Indicators'],
    ['Alt+F', 'Fullscreen'],
    ['Alt+R', 'Replay Mode'],
    ['Alt+P', 'Toggle Patterns'],
    ['Delete', 'Delete Selected Drawing'],
    ['Ctrl+Z', 'Undo Drawing'],
    ['Home', 'Reset Zoom'],
    ['‚Üê‚Üí', 'Scroll Chart'],
    ['+/-', 'Zoom In/Out'],
  ];

  const patterns = [
    ['D', '‚óè', '#f7a21b', 'Doji ‚Äî Indecision/Reversal'],
    ['H', '‚ñ≤', '#26a69a', 'Hammer ‚Äî Bullish Reversal'],
    ['SS', '‚ñº', '#ef5350', 'Shooting Star ‚Äî Bearish Reversal'],
    ['BE', '‚ñ≤', '#26a69a', 'Bullish Engulfing'],
    ['SE', '‚ñº', '#ef5350', 'Bearish Engulfing'],
    ['MS', '‚ñ≤', '#26a69a', 'Morning Star ‚Äî 3-Bar Bull Reversal'],
    ['ES', '‚ñº', '#ef5350', 'Evening Star ‚Äî 3-Bar Bear Reversal'],
    ['3WS', '‚ñ≤', '#26a69a', 'Three White Soldiers ‚Äî Strong Bull'],
    ['3BC', '‚ñº', '#ef5350', 'Three Black Crows ‚Äî Strong Bear'],
    ['PL', '‚ñ≤', '#26a69a', 'Piercing Line ‚Äî Bullish'],
    ['DC', '‚ñº', '#ef5350', 'Dark Cloud Cover ‚Äî Bearish'],
    ['TT', '‚ñº', '#ef5350', 'Tweezer Top ‚Äî Bearish'],
    ['TB', '‚ñ≤', '#26a69a', 'Tweezer Bottom ‚Äî Bullish'],
    ['E', '‚ñ†', '#f7a21b', 'Earnings Report Date'],
    ['S1-3', '‚Äî', '#26a69a', 'Auto Support Levels'],
    ['R1-3', '‚Äî', '#ef5350', 'Auto Resistance Levels'],
  ];

  return `
    <div style="padding:8px 0">
      <div class="panel-section-title" style="padding:0 12px">Keyboard Shortcuts</div>
      ${hotkeys.map(([key, desc]) => `
        <div class="hk-row">
          <span class="hk-desc">${desc}</span>
          <span class="hk-key">${key.split('+').map(k => `<kbd>${k}</kbd>`).join('+')}</span>
        </div>
      `).join('')}
    </div>
    <div style="padding:8px 12px;border-top:1px solid var(--brd)">
      <div class="panel-section-title" style="padding:0 0 8px">Chart Pattern Legend</div>
      ${patterns.map(([code, symbol, color, desc]) => `
        <div style="display:flex;align-items:center;gap:8px;padding:3px 0;font-size:11px">
          <span style="color:${color};font-weight:700;font-family:'JetBrains Mono',monospace;width:36px">${symbol} ${code}</span>
          <span style="color:var(--t2)">${desc}</span>
        </div>
      `).join('')}
    </div>
  `;
}

// ==========================================
// RIGHT PANEL
// ==========================================
let activePanel = null;

function togglePanel(panel) {
  const rp = document.getElementById('rightPanel');
  if (activePanel === panel) { rp.classList.remove('open', 'wide'); activePanel = null; return; }
  activePanel = panel;
  rp.classList.add('open');
  rp.classList.toggle('wide', panel === 'details' || panel === 'ta' || panel === 'financials' || panel === 'heatmap');

  // Highlight button
  document.querySelectorAll('.topbar-right .icon-btn').forEach(b => b.classList.remove('active'));
  const btnId = 'panel' + panel.charAt(0).toUpperCase() + panel.slice(1);
  const btn = document.getElementById(btnId);
  if (btn) btn.classList.add('active');

  const content = document.getElementById('panelContent');
  switch (panel) {
    case 'watchlist': content.innerHTML = renderWatchlistPanel(); refreshWatchlist(); break;
    case 'screener': content.innerHTML = renderScreenerPanel(); loadScreener('gainers'); break;
    case 'news': content.innerHTML = renderNewsPanel(); loadNews(); break;
    case 'details': content.innerHTML = renderDetailsPanel(); loadDetails(); break;
    case 'financials': content.innerHTML = renderFinancialsPanel(); loadFinancialsPanel(); break;
    case 'dividends': content.innerHTML = renderDividendsPanel(); loadDividendsPanel(); break;
    case 'ta': content.innerHTML = renderTAPanel(); calcTechnicalAnalysis(); break;
    case 'heatmap': content.innerHTML = renderHeatmapPanel(); loadHeatmapPanel(); break;
    case 'notes': content.innerHTML = renderNotesPanel(); break;
    case 'hotkeys': content.innerHTML = renderHotkeysPanel(); break;
  }
}

// ==========================================
// FINANCIALS PANEL
// ==========================================
function renderFinancialsPanel() {
  return `
    <div class="screener-tabs">
      <button class="screener-tab active" onclick="loadFinancialsPanel('income',this)">Income</button>
      <button class="screener-tab" onclick="loadFinancialsPanel('balance',this)">Balance Sheet</button>
      <button class="screener-tab" onclick="loadFinancialsPanel('cash',this)">Cash Flow</button>
    </div>
    <div id="financialsRows" style="padding:8px"><div style="padding:20px;text-align:center;color:var(--t3)">Loading financials...</div></div>
  `;
}

async function loadFinancialsPanel(tab, btn) {
  if (btn) { document.querySelectorAll('.screener-tab').forEach(t => t.classList.remove('active')); btn.classList.add('active'); }
  tab = tab || 'income';
  const financials = await fetchFinancials(STATE.symbol);
  const container = document.getElementById('financialsRows');
  if (!financials.length) { container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">No financial data available</div>'; return; }

  let html = '<div style="overflow-x:auto">';

  // Get the relevant financial statement
  const statements = financials.map(f => {
    const period = f.fiscal_period + ' ' + f.fiscal_year;
    const filingDate = f.filing_date || '-';
    let data = {};

    if (tab === 'income' && f.financials?.income_statement) {
      const is = f.financials.income_statement;
      data = {
        'Revenue': is.revenues?.value,
        'Cost of Revenue': is.cost_of_revenue?.value,
        'Gross Profit': is.gross_profit?.value,
        'Operating Expenses': is.operating_expenses?.value,
        'Operating Income': is.operating_income_loss?.value,
        'Net Income': is.net_income_loss?.value,
        'EPS (Basic)': is.basic_earnings_per_share?.value,
        'EPS (Diluted)': is.diluted_earnings_per_share?.value,
      };
    } else if (tab === 'balance' && f.financials?.balance_sheet) {
      const bs = f.financials.balance_sheet;
      data = {
        'Total Assets': bs.assets?.value,
        'Current Assets': bs.current_assets?.value,
        'Total Liabilities': bs.liabilities?.value,
        'Current Liabilities': bs.current_liabilities?.value,
        'Equity': bs.equity?.value,
        'Stockholders Equity': bs.equity_attributable_to_parent?.value,
      };
    } else if (tab === 'cash' && f.financials?.cash_flow_statement) {
      const cf = f.financials.cash_flow_statement;
      data = {
        'Operating Cash Flow': cf.net_cash_flow_from_operating_activities?.value,
        'Investing Cash Flow': cf.net_cash_flow_from_investing_activities?.value,
        'Financing Cash Flow': cf.net_cash_flow_from_financing_activities?.value,
        'Net Cash Flow': cf.net_cash_flow?.value,
      };
    }
    return { period, filingDate, data };
  }).filter(s => Object.keys(s.data).length > 0).slice(0, 8);

  if (!statements.length) { container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">No data for this statement</div>'; return; }

  // Build table
  const metrics = Object.keys(statements[0].data);
  html += '<table style="width:100%;border-collapse:collapse;font-size:11px">';
  html += '<tr style="border-bottom:1px solid var(--brd)"><td style="padding:6px 8px;color:var(--t3);font-weight:600;position:sticky;left:0;background:var(--bg2)">Period</td>';
  statements.forEach(s => { html += `<td style="padding:6px 8px;text-align:right;color:var(--t1);font-weight:600;white-space:nowrap">${s.period}</td>`; });
  html += '</tr>';

  metrics.forEach(metric => {
    html += `<tr style="border-bottom:1px solid rgba(42,46,57,.3)">`;
    html += `<td style="padding:6px 8px;color:var(--t2);position:sticky;left:0;background:var(--bg2);white-space:nowrap">${metric}</td>`;
    statements.forEach(s => {
      const val = s.data[metric];
      const formatted = val !== undefined && val !== null ? (Math.abs(val) >= 1e9 ? '$' + (val/1e9).toFixed(2) + 'B' : Math.abs(val) >= 1e6 ? '$' + (val/1e6).toFixed(1) + 'M' : typeof val === 'number' ? val.toFixed(2) : val) : '-';
      const color = typeof val === 'number' && val < 0 ? 'var(--red)' : 'var(--t1)';
      html += `<td style="padding:6px 8px;text-align:right;font-family:'JetBrains Mono',monospace;font-size:10px;color:${color}">${formatted}</td>`;
    });
    html += '</tr>';
  });

  html += '</table></div>';
  container.innerHTML = html;
}

// ==========================================
// DIVIDENDS & SPLITS PANEL
// ==========================================
function renderDividendsPanel() {
  return `
    <div class="screener-tabs">
      <button class="screener-tab active" onclick="loadDividendsPanel('dividends',this)">Dividends</button>
      <button class="screener-tab" onclick="loadDividendsPanel('splits',this)">Stock Splits</button>
    </div>
    <div id="dividendsRows" style="padding:8px"><div style="padding:20px;text-align:center;color:var(--t3)">Loading...</div></div>
  `;
}

async function loadDividendsPanel(tab, btn) {
  if (btn) { document.querySelectorAll('.screener-tab').forEach(t => t.classList.remove('active')); btn.classList.add('active'); }
  tab = tab || 'dividends';
  const container = document.getElementById('dividendsRows');

  if (tab === 'dividends') {
    const divs = await fetchDividends(STATE.symbol);
    if (!divs.length) { container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">No dividend history</div>'; return; }

    // Summary
    const annualYield = divs.length >= 4 ? divs.slice(0, 4).reduce((s, d) => s + (d.cash_amount || 0), 0) : 0;
    const lastPrice = STATE.cells[STATE.activeCell].data;
    const price = lastPrice.length ? lastPrice[lastPrice.length - 1].close : 1;
    const yieldPct = annualYield > 0 ? (annualYield / price * 100).toFixed(2) : '0';

    let html = `
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1px;margin-bottom:8px">
        <div class="detail-cell"><div class="dl">Annual Div</div><div class="dv" style="color:var(--green)">$${annualYield.toFixed(2)}</div></div>
        <div class="detail-cell"><div class="dl">Yield</div><div class="dv" style="color:var(--green)">${yieldPct}%</div></div>
        <div class="detail-cell"><div class="dl">Frequency</div><div class="dv">${divs[0].frequency === 4 ? 'Quarterly' : divs[0].frequency === 12 ? 'Monthly' : divs[0].frequency === 2 ? 'Semi-Annual' : 'Annual'}</div></div>
      </div>
    `;

    html += divs.map(d => `
      <div style="display:grid;grid-template-columns:1fr 80px 80px;padding:6px 8px;border-bottom:1px solid rgba(42,46,57,.3);font-size:12px">
        <span style="color:var(--t2)">${d.pay_date || d.ex_dividend_date || '-'}</span>
        <span style="text-align:right;font-family:'JetBrains Mono',monospace;color:var(--green)">$${d.cash_amount?.toFixed(4) || '-'}</span>
        <span style="text-align:right;color:var(--t3);font-size:10px">${d.declaration_date ? 'Ex: ' + d.ex_dividend_date : ''}</span>
      </div>
    `).join('');
    container.innerHTML = html;
  } else {
    const splits = await fetchSplits(STATE.symbol);
    if (!splits.length) { container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--t3)">No split history</div>'; return; }

    container.innerHTML = splits.map(s => `
      <div style="display:grid;grid-template-columns:1fr 1fr;padding:10px 12px;border-bottom:1px solid rgba(42,46,57,.3);font-size:12px">
        <div>
          <div style="font-weight:600;color:var(--t1)">${s.split_from}:${s.split_to} Split</div>
          <div style="color:var(--t3);font-size:11px">${s.execution_date || '-'}</div>
        </div>
        <div style="text-align:right;font-family:'JetBrains Mono',monospace;color:var(--blue)">
          ${(s.split_to / s.split_from).toFixed(1)}x
        </div>
      </div>
    `).join('');
  }
}

// ==========================================
// SECTOR HEATMAP PANEL
// ==========================================
function renderHeatmapPanel() {
  return `
    <div class="screener-tabs">
      <button class="screener-tab active" onclick="loadHeatmapPanel('sp500',this)">S&P 500</button>
      <button class="screener-tab" onclick="loadHeatmapPanel('sectors',this)">Sectors</button>
      <button class="screener-tab" onclick="loadHeatmapPanel('crypto',this)">Crypto</button>
    </div>
    <div id="heatmapRows" style="padding:8px"><div style="padding:20px;text-align:center;color:var(--t3)">Loading heatmap...</div></div>
  `;
}

async function loadHeatmapPanel(tab, btn) {
  if (btn) { document.querySelectorAll('.screener-tab').forEach(t => t.classList.remove('active')); btn.classList.add('active'); }
  tab = tab || 'sp500';
  const container = document.getElementById('heatmapRows');

  const sectorETFs = {
    'Technology': 'XLK', 'Healthcare': 'XLV', 'Financials': 'XLF', 'Energy': 'XLE',
    'Consumer Disc.': 'XLY', 'Consumer Staples': 'XLP', 'Industrials': 'XLI',
    'Materials': 'XLB', 'Utilities': 'XLU', 'Real Estate': 'XLRE', 'Communication': 'XLC'
  };

  const majorStocks = ['AAPL','MSFT','GOOGL','AMZN','NVDA','META','TSLA','BRK.B','JPM','V','JNJ','UNH','XOM','PG','MA','HD','CVX','MRK','ABBV','PEP','COST','KO','AVGO','LLY','WMT','ADBE','CRM','TMO','MCD','CSCO','ACN','ABT','DHR','CMCSA','NEE','TXN','PM','UPS','RTX','INTC'];
  const cryptos = ['X:BTCUSD','X:ETHUSD','X:SOLUSD','X:ADAUSD','X:DOGEUSD','X:AVAXUSD','X:DOTUSD','X:LINKUSD','X:MATICUSD','X:UNIUSD'];

  let symbols;
  if (tab === 'sp500') symbols = majorStocks;
  else if (tab === 'sectors') symbols = Object.values(sectorETFs);
  else symbols = cryptos;

  const labels = tab === 'sectors' ? Object.keys(sectorETFs) : null;

  // Fetch prev day data for all
  const results = await Promise.all(symbols.map(async (sym, i) => {
    const data = await fetchPrevDay(sym);
    if (!data) return null;
    const chg = ((data.c - data.o) / data.o * 100).toFixed(2);
    return { sym: labels ? labels[i] : sym.replace('X:', ''), price: data.c, chg: parseFloat(chg), vol: data.v };
  }));

  const valid = results.filter(Boolean).sort((a, b) => b.chg - a.chg);

  container.innerHTML = `<div style="display:flex;flex-wrap:wrap;gap:3px">` +
    valid.map(r => {
      const intensity = Math.min(Math.abs(r.chg) / 3, 1);
      const bg = r.chg >= 0
        ? `rgba(38,166,154,${0.1 + intensity * 0.5})`
        : `rgba(239,83,80,${0.1 + intensity * 0.5})`;
      const size = tab === 'sp500' ? 'width:72px;height:48px' : 'width:90px;height:56px';
      return `
        <div onclick="selectSymbol('${r.sym.includes(':') ? r.sym : r.sym}')" style="
          background:${bg};border-radius:4px;padding:4px 6px;cursor:pointer;
          display:flex;flex-direction:column;align-items:center;justify-content:center;
          ${size};border:1px solid rgba(255,255,255,.05);
        ">
          <div style="font-size:10px;font-weight:700;font-family:'JetBrains Mono',monospace">${r.sym}</div>
          <div style="font-size:10px;font-family:'JetBrains Mono',monospace;color:${r.chg >= 0 ? 'var(--green)' : 'var(--red)'}">${r.chg >= 0 ? '+' : ''}${r.chg}%</div>
        </div>
      `;
    }).join('') + '</div>';
}

// ==========================================
// TEMPLATES
// ==========================================
function openTemplateModal() { document.getElementById('templateModal').classList.add('show'); renderTemplateList(); }

function renderTemplateList() {
  document.getElementById('tmplList').innerHTML = Object.entries(templates).map(([name, tmpl]) => `
    <div class="tmpl-item" onclick="applyTemplate('${name}')">
      <div>
        <div class="tmpl-name">${name}</div>
        <div class="tmpl-info">${tmpl.chartType} ¬∑ ${tmpl.indicators.length} indicators</div>
      </div>
      <span class="tmpl-del" onclick="event.stopPropagation();deleteTemplate('${name}')">‚úï</span>
    </div>
  `).join('');
}

function saveTemplate() {
  const name = document.getElementById('tmplName').value.trim();
  if (!name) { toast('Enter template name', 'error'); return; }
  templates[name] = { chartType: STATE.chartType, indicators: [...STATE.indicators], settings: {...STATE.settings} };
  localStorage.setItem('jh_templates', JSON.stringify(templates));
  renderTemplateList();
  document.getElementById('tmplName').value = '';
  toast(`Template "${name}" saved`, 'success');
}

function applyTemplate(name) {
  const tmpl = templates[name];
  if (!tmpl) return;
  STATE.chartType = tmpl.chartType;
  STATE.indicators = [...tmpl.indicators];
  document.querySelectorAll('.ct-btn').forEach(b => { b.classList.remove('active'); if (b.dataset.type === tmpl.chartType) b.classList.add('active'); });
  rebuildAllCharts();
  const cell = STATE.cells[STATE.activeCell];
  if (cell.data.length) { setChartData(STATE.activeCell, cell.data); applyIndicators(STATE.activeCell); }
  closeModal('templateModal');
  toast(`Applied "${name}"`, 'success');
}

function deleteTemplate(name) {
  delete templates[name];
  localStorage.setItem('jh_templates', JSON.stringify(templates));
  renderTemplateList();
}

// ==========================================
// ALERTS
// ==========================================
function openAlertModal() {
  document.getElementById('alertModal').classList.add('show');
  document.getElementById('alertSym').value = STATE.symbol;
  const data = STATE.cells[STATE.activeCell].data;
  if (data.length) document.getElementById('alertVal').value = data[data.length-1].close.toFixed(2);
}

function createAlert() {
  const sym = document.getElementById('alertSym').value.trim().toUpperCase();
  const cond = document.getElementById('alertCond').value;
  const val = parseFloat(document.getElementById('alertVal').value);
  const msg = document.getElementById('alertMsg').value;
  if (!sym || isNaN(val)) { toast('Invalid alert', 'error'); return; }
  alerts.push({ id: Date.now(), sym, cond, val, msg, active: true, created: new Date().toISOString() });
  localStorage.setItem('jh_alerts', JSON.stringify(alerts));
  closeModal('alertModal');
  toast(`Alert created: ${sym} ${cond.replace(/_/g, ' ')} ${val}`, 'success');
}

function checkAlerts(data) {
  if (!data.length) return;
  const last = data[data.length - 1];
  const prev = data.length > 1 ? data[data.length - 2] : last;
  alerts.forEach(alert => {
    if (!alert.active || alert.sym !== STATE.symbol) return;
    let triggered = false;
    if (alert.cond === 'crosses_above' && prev.close <= alert.val && last.close > alert.val) triggered = true;
    if (alert.cond === 'crosses_below' && prev.close >= alert.val && last.close < alert.val) triggered = true;
    if (alert.cond === 'greater_than' && last.close > alert.val) triggered = true;
    if (alert.cond === 'less_than' && last.close < alert.val) triggered = true;
    if (triggered) {
      toast(`üîî Alert: ${alert.sym} ${alert.cond.replace(/_/g, ' ')} $${alert.val}${alert.msg ? ' - ' + alert.msg : ''}`, 'warning');
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('JustHodl Alert', { body: `${alert.sym} ${alert.cond.replace(/_/g, ' ')} $${alert.val}` });
      }
    }
  });
}

// ==========================================
// REPLAY MODE
// ==========================================
let replayInterval;

function toggleReplay() {
  STATE.replayMode = !STATE.replayMode;
  document.getElementById('replayBar').classList.toggle('show', STATE.replayMode);
  document.getElementById('replayBtn').classList.toggle('active', STATE.replayMode);
  if (STATE.replayMode) {
    STATE.replayIndex = Math.max(50, Math.floor(STATE.allData.length / 2));
    replayUpdate();
  } else {
    clearInterval(replayInterval);
    STATE.replayPlaying = false;
    const cell = STATE.cells[STATE.activeCell];
    if (cell.data.length) { setChartData(STATE.activeCell, cell.data); applyIndicators(STATE.activeCell); }
  }
}

function replayUpdate() {
  const data = STATE.allData.slice(0, STATE.replayIndex);
  if (data.length) {
    setChartData(STATE.activeCell, data);
    const last = data[data.length - 1];
    const date = new Date(last.time * 1000);
    document.getElementById('replayDate').textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    document.getElementById('replaySpeed').textContent = STATE.replaySpeed + 'x';
  }
}

function replayStep(n) { STATE.replayIndex = Math.max(10, Math.min(STATE.allData.length, STATE.replayIndex + n)); replayUpdate(); }

function replayToggle() {
  STATE.replayPlaying = !STATE.replayPlaying;
  document.getElementById('replayPlayBtn').textContent = STATE.replayPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
  if (STATE.replayPlaying) {
    replayInterval = setInterval(() => {
      STATE.replayIndex += STATE.replaySpeed;
      if (STATE.replayIndex >= STATE.allData.length) { STATE.replayPlaying = false; clearInterval(replayInterval); document.getElementById('replayPlayBtn').textContent = '‚ñ∂ Play'; }
      replayUpdate();
    }, 200);
  } else clearInterval(replayInterval);
}

function replayChangeSpeed() {
  const speeds = [1, 2, 5, 10, 20, 50];
  const idx = speeds.indexOf(STATE.replaySpeed);
  STATE.replaySpeed = speeds[(idx + 1) % speeds.length];
  document.getElementById('replaySpeed').textContent = STATE.replaySpeed + 'x';
}

// ==========================================
// DRAWING TOOLS
// ==========================================
function setTool(tool) {
  STATE.drawingTool = tool;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  const btn = document.querySelector(`.tool-btn[data-tool="${tool}"]`);
  if (btn) btn.classList.add('active');
}

function toggleLockDrawings() { STATE.drawingsLocked = !STATE.drawingsLocked; toast(STATE.drawingsLocked ? 'Drawings locked' : 'Drawings unlocked', 'info'); }
function toggleDrawingsVisible() { STATE.drawingsVisible = !STATE.drawingsVisible; toast(STATE.drawingsVisible ? 'Drawings shown' : 'Drawings hidden', 'info'); }
function deleteAllDrawings() { if (confirm('Delete all drawings?')) { symbolDrawings[STATE.symbol] = []; localStorage.setItem('jh_drawings', JSON.stringify(symbolDrawings)); toast('All drawings deleted', 'info'); } }
function toggleMagnet() { STATE.magnetMode = !STATE.magnetMode; toast(STATE.magnetMode ? 'Magnet on' : 'Magnet off', 'info'); }
function toggleStayInDrawing() { STATE.stayInDrawing = !STATE.stayInDrawing; toast(STATE.stayInDrawing ? 'Stay in drawing mode' : 'Normal mode', 'info'); }

// ==========================================
// SCREENSHOT & EXPORT
// ==========================================
function takeScreenshot() {
  const cell = STATE.cells[STATE.activeCell];
  if (!cell.chart) return;
  const canvas = document.querySelector(`#chartDiv${STATE.activeCell} canvas`);
  if (canvas) {
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${STATE.symbol}_${new Date().toISOString().split('T')[0]}.png`;
      a.click();
      URL.revokeObjectURL(url);
      toast('Screenshot saved', 'success');
    });
  }
}

function exportCSV() {
  const data = STATE.cells[STATE.activeCell].data;
  if (!data.length) return;
  const csv = 'Date,Open,High,Low,Close,Volume\n' + data.map(d => {
    const date = new Date(d.time * 1000).toISOString();
    return `${date},${d.open},${d.high},${d.low},${d.close},${d.volume}`;
  }).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${STATE.symbol}_${STATE.timeframe.multiplier}${STATE.timeframe.timespan}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  toast('CSV exported', 'success');
}

// ==========================================
// FULLSCREEN
// ==========================================
function toggleFullscreen() {
  document.getElementById('app').classList.toggle('fullscreen');
  // Resize charts
  setTimeout(() => {
    const grid = document.getElementById('chartGrid');
    grid.querySelectorAll('.chart-cell').forEach((_, i) => {
      if (STATE.cells[i]?.chart) {
        const container = document.getElementById(`chartDiv${i}`);
        if (container) STATE.cells[i].chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
      }
    });
  }, 100);
}

// ==========================================
// MARKET STATUS
// ==========================================
async function updateMarketStatus() {
  try {
    const url = `${API_BASE}/v1/marketstatus/now?apiKey=${POLYGON_KEY}`;
    const resp = await fetch(url);
    const json = await resp.json();
    const dot = document.getElementById('mktDot');
    const status = document.getElementById('mktStatus');
    if (json.market === 'open') { dot.className = 'dot open'; status.textContent = 'Market Open'; }
    else if (json.market === 'extended-hours') { dot.className = 'dot pre'; status.textContent = 'Extended Hours'; }
    else { dot.className = 'dot closed'; status.textContent = 'Market Closed'; }
  } catch(e) {}
  document.getElementById('mktTime').textContent = new Date().toLocaleString('en-US', { timeZone: STATE.timezone, hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

function setTimezone(tz) { STATE.timezone = tz; updateMarketStatus(); }

// ==========================================
// AUTO REFRESH
// ==========================================
let refreshTimer;
function startAutoRefresh() {
  clearInterval(refreshTimer);
  const interval = STATE.settings.refreshInterval;
  if (interval > 0) {
    refreshTimer = setInterval(() => {
      loadSymbol(STATE.symbol, STATE.activeCell);
    }, interval * 1000);
  }
}

// ==========================================
// CONTEXT MENU
// ==========================================
function ctxAction(action) {
  document.getElementById('ctxMenu').classList.remove('show');
  switch (action) {
    case 'addAlert': openAlertModal(); break;
    case 'addToWatchlist': addToWatchlist(STATE.symbol); break;
    case 'hline': setTool('hline'); break;
    case 'trendline': setTool('trendline'); break;
    case 'fib': setTool('fib'); break;
    case 'resetZoom': STATE.cells[STATE.activeCell].chart?.timeScale().fitContent(); break;
    case 'screenshot': takeScreenshot(); break;
    case 'export': exportCSV(); break;
    case 'removeAll': deleteAllDrawings(); break;
  }
}

// ==========================================
// MODALS
// ==========================================
function closeModal(id) { document.getElementById(id).classList.remove('show'); }

// ==========================================
// TOAST
// ==========================================
function toast(msg, type) {
  const container = document.getElementById('toastContainer');
  const t = document.createElement('div');
  t.className = 'toast ' + (type || 'info');
  t.innerHTML = `<span class="toast-msg">${msg}</span><span class="toast-close" onclick="this.parentElement.remove()">‚úï</span>`;
  container.appendChild(t);
  setTimeout(() => t.remove(), 4000);
}

// ==========================================
// UTILITIES
// ==========================================
function formatVol(v) {
  if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
  if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
  if (v >= 1e3) return (v / 1e3).toFixed(1) + 'K';
  return v.toString();
}

function formatNum(n) {
  if (n >= 1e12) return (n / 1e12).toFixed(2) + 'T';
  if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
  if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
  return n.toLocaleString();
}

// ==========================================
// EVENT LISTENERS
// ==========================================
function setupEventListeners() {
  // Context menu
  document.getElementById('chartArea').addEventListener('contextmenu', e => {
    e.preventDefault();
    const ctx = document.getElementById('ctxMenu');
    ctx.style.left = e.clientX + 'px';
    ctx.style.top = e.clientY + 'px';
    ctx.classList.add('show');
  });
  document.addEventListener('click', () => document.getElementById('ctxMenu').classList.remove('show'));

  // Close search on outside click
  document.addEventListener('click', e => {
    if (!e.target.closest('#symSearch')) document.getElementById('searchDrop').classList.remove('show');
  });

  // Close modals on overlay click
  document.querySelectorAll('.modal-overlay').forEach(m => {
    m.addEventListener('click', e => { if (e.target === m) m.classList.remove('show'); });
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

    if (e.key === '/') { e.preventDefault(); toggleSearch(); }
    if (e.key === 'Escape') {
      document.querySelectorAll('.modal-overlay.show').forEach(m => m.classList.remove('show'));
      document.getElementById('searchDrop').classList.remove('show');
      if (activePanel) { document.getElementById('rightPanel').classList.remove('open', 'wide'); activePanel = null; }
    }

    // Timeframe shortcuts
    const tfMap = { '1':'1m', '2':'5m', '3':'15m', '4':'30m', '5':'1H', '6':'4H', '7':'1D', '8':'1W', '9':'1M' };
    if (tfMap[e.key] && !e.altKey) {
      const tfBtns = document.querySelectorAll('.tf-btn');
      const idx = ['1','2','3','4','5','6','7','8','9'].indexOf(e.key);
      if (tfBtns[idx]) tfBtns[idx].click();
    }

    // Alt shortcuts
    if (e.altKey) {
      if (e.key === '1') { e.preventDefault(); setLayout(1); }
      if (e.key === '2') { e.preventDefault(); setLayout('2h'); }
      if (e.key === '4') { e.preventDefault(); setLayout(4); }
      if (e.key === 'w' || e.key === 'W') { e.preventDefault(); togglePanel('watchlist'); }
      if (e.key === 'n' || e.key === 'N') { e.preventDefault(); togglePanel('news'); }
      if (e.key === 's' || e.key === 'S') { e.preventDefault(); takeScreenshot(); }
      if (e.key === 'a' || e.key === 'A') { e.preventDefault(); openAlertModal(); }
      if (e.key === 'i' || e.key === 'I') { e.preventDefault(); openIndicatorModal(); }
      if (e.key === 'f' || e.key === 'F') { e.preventDefault(); toggleFullscreen(); }
      if (e.key === 'r' || e.key === 'R') { e.preventDefault(); toggleReplay(); }
    }

    // Zoom
    if (e.key === '+' || e.key === '=') { const ts = STATE.cells[STATE.activeCell].chart?.timeScale(); if (ts) ts.applyOptions({ barSpacing: ts.options().barSpacing + 2 }); }
    if (e.key === '-') { const ts = STATE.cells[STATE.activeCell].chart?.timeScale(); if (ts) ts.applyOptions({ barSpacing: Math.max(2, ts.options().barSpacing - 2) }); }
    if (e.key === 'Home') { STATE.cells[STATE.activeCell].chart?.timeScale().fitContent(); }
  });

  // Request notification permission
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
  }

  // Update clock
  setInterval(() => {
    document.getElementById('mktTime').textContent = new Date().toLocaleString('en-US', { timeZone: STATE.timezone, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }, 1000);
}

// ==========================================
// INIT
// ==========================================
window.addEventListener('load', init);
window.addEventListener('resize', () => {
  const grid = document.getElementById('chartGrid');
  if (grid) grid.querySelectorAll('.chart-cell').forEach((_, i) => {
    const cell = STATE.cells[i];
    if (cell?.chart) {
      const container = document.getElementById(`chartDiv${i}`);
      if (container && container.clientWidth > 0) cell.chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
    }
  });
});
</script>
</body>
</html>
