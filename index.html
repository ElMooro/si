<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Economic Data Watchlist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 400px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
        }

        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, #1a237e 0%, #3949ab 100%);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .header p {
            font-size: 1.1em;
            color: #b3c5ff;
        }

        .search-container {
            position: relative;
            margin-bottom: 25px;
        }

        .search-input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 8px;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #3949ab;
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 0 0 8px 8px;
            max-height: 400px; /* You might want to adjust this if you show all results */
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }

        .search-result-item {
            padding: 10px 16px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-result-item:hover {
            background: #333;
        }

        .search-result-info {
            flex: 1;
        }

        .search-result-title {
            color: #4a9eff;
            font-weight: 500;
            font-size: 0.9em;
        }

        .search-result-symbol {
            color: #888;
            font-size: 0.8em;
        }

        .category-browser {
            margin-top: 20px;
        }

        .category-browser h3 {
            color: #4a9eff;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .main-category {
            margin-bottom: 15px;
        }

        .main-category-header {
            padding: 12px;
            background: #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .main-category-header:hover {
            background: #333;
        }

        .main-category-header.active {
            background: #3949ab;
        }

        .category-count {
            font-size: 0.85em;
            color: #888;
            background: #1a1a1a;
            padding: 2px 8px;
            border-radius: 12px;
        }

        .subcategories {
            margin-left: 20px;
            margin-top: 10px;
            display: none;
        }

        .subcategories.show {
            display: block;
        }

        .subcategory {
            margin-bottom: 10px;
        }

        .subcategory-header {
            padding: 10px;
            background: #222;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .subcategory-header:hover {
            background: #333;
            transform: translateX(5px);
        }

        .series-list {
            margin-left: 20px;
            margin-top: 8px;
            display: none;
        }

        .series-list.show {
            display: block;
        }

        .series-item {
            padding: 8px 10px;
            background: #1a1a1a;
            margin-bottom: 4px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .series-item:hover {
            background: #2a2a2a;
            transform: translateX(3px);
        }

        .series-name {
            color: #4a9eff;
            flex: 1;
            margin-right: 10px;
        }

        .series-symbol {
            color: #666;
            font-family: monospace;
            font-size: 0.8em;
        }

        .add-btn {
            padding: 4px 12px;
            background: #4caf50;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.8em;
            cursor: pointer;
            white-space: nowrap;
        }

        .add-btn:hover {
            background: #5cbf60;
        }

        .add-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .watchlist-container {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .watchlist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .watchlist-title {
            font-size: 1.8em;
            color: #4a9eff;
        }

        .watchlist-controls {
            display: flex;
            gap: 10px;
        }

        .watchlist-btn {
            padding: 8px 16px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .watchlist-btn:hover {
            background: #333;
            border-color: #555;
        }

        .watchlist-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }

        .watchlist-table th,
        .watchlist-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .watchlist-table th {
            background: #222;
            color: #4a9eff;
            font-weight: 600;
            position: sticky;
            top: 0; /* For sticky header in .main-content */
            z-index: 10;
        }

        .watchlist-table tr:hover {
            background: #222;
        }

        .series-name-cell {
            color: #4a9eff;
            font-weight: 500;
        }

        .series-symbol-cell {
            color: #666;
            font-size: 0.85em;
        }

        .value-cell {
            text-align: right;
            font-family: monospace;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #ff5252;
        }

        .neutral {
            color: #888;
        }

        .remove-btn {
            padding: 4px 8px;
            background: #d32f2f;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.8em;
            cursor: pointer;
        }

        .remove-btn:hover {
            background: #f44336;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #666;
        }

        .empty-state h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .stats-bar {
            background: #222;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .stat-item {
            flex: 1;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4a9eff;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
        }

        .error-note {
            background: #ff9800; /* Using a less alarming color than red for a note */
            color: #000;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
                height: auto; /* Allow content to determine height */
            }
            
            .sidebar {
                width: 100%;
                height: auto; /* Adjust height dynamically */
                max-height: 50vh; /* Or a preferred max height */
                border-right: none;
                border-bottom: 1px solid #333;
            }
            .main-content {
                 height: auto; /* Adjust height dynamically */
            }
             .watchlist-table th {
                position: static; /* Disable sticky header on mobile if it causes issues */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2 style="color: #4a9eff; margin-bottom: 20px;">Global Economic Data Explorer</h2>
            
            <div class="search-container">
                <input 
                    type="text" 
                    id="searchInput" 
                    class="search-input" 
                    placeholder="Search economic series..."
                    autocomplete="off"
                >
                <span class="search-icon">🔍</span>
                <div id="searchResults" class="search-results"></div>
            </div>

            <div class="category-browser">
                <h3>Browse by Source</h3>
                <div id="categoryList"></div>
            </div>
        </aside>

        <main class="main-content">
            <div class="header">
                <h1>Global Economic Data Watchlist</h1>
                <p>Track economic indicators from FRED, ECB, NY Fed, and OFR</p>
            </div>

            <div id="errorNote" class="error-note" style="display: none;">
                Note: Some series may not be available through the API, or may have limited historical data. FRED series typically have the best coverage.
            </div>

            <div id="statsBar" class="stats-bar" style="display: none;">
                <div class="stat-item">
                    <div class="stat-value" id="totalSeries">0</div>
                    <div class="stat-label">Series Tracked</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value positive" id="gainers">0</div>
                    <div class="stat-label">Gainers (Daily)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value negative" id="losers">0</div>
                    <div class="stat-label">Losers (Daily)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="dataPoints">0</div>
                    <div class="stat-label">Data Points</div>
                </div>
            </div>

            <div class="watchlist-container">
                <div class="watchlist-header">
                    <h2 class="watchlist-title">My Watchlist</h2>
                    <div class="watchlist-controls">
                        <button class="watchlist-btn" onclick="refreshAllData()">🔄 Refresh All</button>
                        <button class="watchlist-btn" onclick="downloadWatchlist()">📥 Download CSV</button>
                        <button class="watchlist-btn" onclick="clearWatchlist()">🗑️ Clear All</button>
                    </div>
                </div>

                <div id="watchlistContent">
                    <div class="empty-state">
                        <h3>Your watchlist is empty</h3>
                        <p>Search or browse categories to add series to your watchlist</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const API_BASE = 'https://ped8gafyuz.us-east-1.awsapprunner.com';
        
        // Comprehensive economic data series
        // To include more series, expand this object.
        // If you want to dynamically fetch ALL series from a source (e.g., all 100,000+ series from FRED),
        // the backend API (ped8gafyuz.us-east-1.awsapprunner.com) would need to provide an endpoint
        // for discovering series/categories, which is different from fetching data for a known symbol.
        const economicData = {
            'Federal Reserve (FRED) - Core Series': {
                'Interest Rates': [
                    { symbol: 'DFF', name: 'Federal Funds Rate' },
                    { symbol: 'EFFR', name: 'Effective Federal Funds Rate' },
                    { symbol: 'SOFR', name: 'Secured Overnight Financing Rate' },
                    { symbol: 'DGS1', name: '1-Year Treasury Rate' },
                    { symbol: 'DGS2', name: '2-Year Treasury Rate' },
                    { symbol: 'DGS5', name: '5-Year Treasury Rate' },
                    { symbol: 'DGS10', name: '10-Year Treasury Rate' },
                    { symbol: 'DGS30', name: '30-Year Treasury Rate' },
                    { symbol: 'TB3MS', name: '3-Month Treasury Bill' },
                    { symbol: 'MORTGAGE30US', name: '30-Year Mortgage Rate' },
                    { symbol: 'PRIME', name: 'Prime Rate' }
                ],
                'Monetary Aggregates': [
                    { symbol: 'M1SL', name: 'M1 Money Supply' },
                    { symbol: 'M2SL', name: 'M2 Money Supply' },
                    { symbol: 'BOGMBASE', name: 'Monetary Base' },
                    { symbol: 'TOTRESNS', name: 'Total Reserves' },
                    { symbol: 'WRESBAL', name: 'Reserve Balances with Fed Banks' },
                    { symbol: 'RESPPNTEPNWW', name: 'Eligible Collateral' },
                    { symbol: 'RESPPALGUONNWW', name: 'Treasury Securities Held' },
                    { symbol: 'SWP1690', name: 'Central Bank Liquidity Swaps' },
                    { symbol: 'OTHL1690', name: 'Loans: Credit Facilities' }
                ],
                'Economic Indicators': [
                    { symbol: 'GDP', name: 'Gross Domestic Product' },
                    { symbol: 'GDPC1', name: 'Real GDP' },
                    { symbol: 'UNRATE', name: 'Unemployment Rate' },
                    { symbol: 'PAYEMS', name: 'Nonfarm Payrolls' },
                    { symbol: 'CPIAUCSL', name: 'Consumer Price Index' },
                    { symbol: 'CPILFESL', name: 'Core CPI' },
                    { symbol: 'PPIACO', name: 'Producer Price Index' },
                    { symbol: 'INDPRO', name: 'Industrial Production Index' },
                    { symbol: 'HOUST', name: 'Housing Starts' },
                    { symbol: 'PERMIT', name: 'Building Permits' }
                ],
                'Financial Markets': [
                    { symbol: 'VIXCLS', name: 'VIX Volatility Index' },
                    { symbol: 'TEDRATE', name: 'TED Spread' },
                    { symbol: 'T10Y2Y', name: '10Y-2Y Treasury Spread' },
                    { symbol: 'T10Y3M', name: '10Y-3M Treasury Spread' },
                    { symbol: 'BAMLH0A0HYM2', name: 'High Yield Spread' },
                    { symbol: 'DEXUSEU', name: 'USD/EUR Exchange Rate' },
                    { symbol: 'DEXCHUS', name: 'CNY/USD Exchange Rate' },
                    { symbol: 'DEXJPUS', name: 'JPY/USD Exchange Rate' },
                    { symbol: 'DTWEXBGS', name: 'Trade Weighted Dollar Index' }
                ]
            },
            'European Central Bank (ECB) - Attempt': { // Note: These symbols are likely FRED symbols for ECB data
                'ECB Policy Rates': [
                    { symbol: 'ECBDFR', name: 'ECB Deposit Facility Rate' },
                    { symbol: 'ECBMPRFR', name: 'ECB Main Refinancing Rate' },
                    { symbol: 'ECBMLFR', name: 'ECB Marginal Lending Rate' },
                    // { symbol: 'EUINTERESTRATE', name: 'Euro Area Interest Rate' } // Example, confirm real symbol
                ],
                'Euro Area Indicators': [
                    // { symbol: 'EURM1', name: 'Euro Area M1' }, // Confirm real symbols
                    // { symbol: 'EURM2', name: 'Euro Area M2' },
                    // { symbol: 'EURM3', name: 'Euro Area M3' },
                    // { symbol: 'EURCPI', name: 'Euro Area CPI' },
                    // { symbol: 'EURGDP', name: 'Euro Area GDP' },
                    // { symbol: 'EURUNRATE', name: 'Euro Area Unemployment' }
                ]
            },
            'New York Fed - Core Series': { // Note: These symbols are likely FRED symbols for NY Fed data
                'NY Fed Markets': [
                    { symbol: 'RPONTSYD', name: 'Overnight Repo Rate (Secured by Treasury Securities)' }, // More descriptive name
                    { symbol: 'SOFR', name: 'SOFR (also in FRED)' },
                    { symbol: 'OBFR', name: 'Overnight Bank Funding Rate' },
                    { symbol: 'TGCR', name: 'Tri-Party General Collateral Rate' },
                    { symbol: 'BGCR', name: 'Broad General Collateral Rate' }
                ],
                'Primary Dealer Statistics': [
                    // { symbol: 'PDPOSGS', name: 'Primary Dealer Positions - Treasuries' }, // Confirm real symbols
                    // { symbol: 'PDPOSMBS', name: 'Primary Dealer Positions - MBS' },
                    // { symbol: 'PDPOSCORP', name: 'Primary Dealer Positions - Corporate' },
                    // { symbol: 'PDDURAS', name: 'Primary Dealer Duration Risk' }
                ],
                'Inflation Expectations': [
                    { symbol: 'T5YIE', name: '5-Year Breakeven Inflation Rate' },
                    { symbol: 'T10YIE', name: '10-Year Breakeven Inflation Rate' },
                    { symbol: 'T5YIFR', name: '5-Year, 5-Year Forward Inflation Expectation Rate' }, // More standard name
                    { symbol: 'DFEDTARU', name: 'Federal Funds Target Range - Upper Limit' } // More descriptive
                ]
            },
            'Office of Financial Research (OFR)': { // Note: These symbols are likely FRED symbols for OFR data
                'Financial Stress': [
                    { symbol: 'STLFSI4', name: 'St. Louis Fed Financial Stress Index' }, // STLFSI3 or STLFSI4 could be latest
                    { symbol: 'NFCI', name: 'Chicago Fed National Financial Conditions Index' }, // More descriptive
                    { symbol: 'ANFCI', name: 'Adjusted National Financial Conditions Index' },
                    { symbol: 'KCFSI', name: 'Kansas City Financial Stress Index' }
                ],
                'Systemic Risk Indicators': [
                    // { symbol: 'SRISK', name: 'Systemic Risk Measure' }, // Confirm actual available FRED symbol
                    // { symbol: 'LEVERAGE', name: 'Financial Sector Leverage' },
                    // { symbol: 'MKTCAP', name: 'Market Capitalization Ratio' }
                ]
            },
            'Additional FRED Series': {
                'Employment Details': [
                    { symbol: 'CIVPART', name: 'Labor Force Participation Rate' },
                    { symbol: 'EMRATIO', name: 'Employment-Population Ratio' },
                    { symbol: 'UNEMPLOY', name: 'Unemployed Persons' },
                    { symbol: 'ICSA', name: 'Initial Jobless Claims' },
                    { symbol: 'CCSA', name: 'Continued Claims (Insured Unemployment)' },
                    { symbol: 'U6RATE', name: 'U-6 Unemployment Rate' },
                    { symbol: 'MEDIANLRMTHSAP', name: 'Median Usual Weekly Earnings' } // Example: MEHOINUSA672N is annual
                ],
                'Housing Market': [
                    { symbol: 'CSUSHPISA', name: 'Case-Shiller U.S. National Home Price Index' },
                    { symbol: 'MSPUS', name: 'Median Sales Price of Houses Sold for the United States' },
                    { symbol: 'EXHOSLUSM495S', name: 'Existing Home Sales' },
                    { symbol: 'HSN1F', name: 'New Single-Family Houses Sold' },
                    { symbol: 'MSACSR', name: 'Monthly Supply of New Houses in the U.S.' }
                ],
                'Manufacturing & Business': [ // Broadened Category
                    { symbol: 'DGORDER', name: 'Durable Goods Orders' },
                    { symbol: 'NEWORDER', name: 'Manufacturers New Orders: Total' }, // More specific
                    { symbol: 'UMCSENT', name: 'University of Michigan: Consumer Sentiment' },
                    { symbol: 'ISMRTLMP', name: 'ISM Manufacturing PMI Composite Index' }, // Common PMI
                    { symbol: 'MANEMP', name: 'Manufacturing Employment' }
                ],
                'Credit & Banking': [
                    { symbol: 'TOTBKCR', name: 'Bank Credit, All Commercial Banks' },
                    { symbol: 'BUSLOANS', name: 'Commercial and Industrial Loans, All Commercial Banks' },
                    { symbol: 'REALLN', name: 'Real Estate Loans, All Commercial Banks' },
                    { symbol: 'CONSUMER', name: 'Consumer Loans, All Commercial Banks' }, // Often split by type
                    { symbol: 'TOTALSL', name: 'Total Consumer Credit Outstanding' }, // Broader consumer credit
                    { symbol: 'DPSACBW027SBOG', name: 'Deposits, All Commercial Banks' },
                    // { symbol: 'H8B1001NCBCMG', name: 'Commercial Paper Outstanding' } // Often more specific series are used
                ],
                'Commodities': [
                    { symbol: 'DCOILWTICO', name: 'WTI Crude Oil Price' },
                    { symbol: 'GOLDAMGBD228NLBM', name: 'Gold Price: London Fixing' },
                    { symbol: 'DHHNGSP', name: 'Henry Hub Natural Gas Spot Price' },
                    { symbol: 'DCOILBRENTEU', name: 'Brent Crude Oil Price' },
                    { symbol: 'PALLFNFINDEXM', name: 'Global Price Index of All Commodities' }
                ],
                'Government Finance': [
                    { symbol: 'GFDEBTN', name: 'Federal Debt: Total Public Debt' },
                    { symbol: 'GFDEGDQ188S', name: 'Federal Debt: Total Public Debt as Percent of GDP' },
                    { symbol: 'FYFSD', name: 'Federal Surplus or Deficit (-)' },
                    { symbol: 'FYFR', name: 'Federal Receipts' },
                    { symbol: 'FYONET', name: 'Federal Net Outlays' }
                ]
            }
        };

        let watchlist = [];
        let seriesData = {}; // Stores { symbol: [ {date, value}, ... ] }
        let searchTimeout;
        let failedSeries = new Set(); // Track series that failed to load

        function initializeCategories() {
            const categoryList = document.getElementById('categoryList');
            categoryList.innerHTML = ''; // Clear previous categories if any
            
            Object.entries(economicData).forEach(([mainCategory, subcategories]) => {
                const mainDiv = document.createElement('div');
                mainDiv.className = 'main-category';
                
                const totalSeriesInMain = Object.values(subcategories).reduce((acc, arr) => acc + arr.length, 0);
                
                const mainHeader = document.createElement('div');
                mainHeader.className = 'main-category-header';
                mainHeader.innerHTML = `
                    <span>${mainCategory}</span>
                    <span class="category-count">${totalSeriesInMain}</span>
                `;
                mainHeader.onclick = () => toggleMainCategory(mainCategory);
                
                const subcatContainer = document.createElement('div');
                subcatContainer.className = 'subcategories';
                subcatContainer.id = `main-${mainCategory.replace(/[^a-zA-Z0-9]/g, '-')}`;
                
                Object.entries(subcategories).forEach(([subcat, series]) => {
                    if (series.length === 0) return; // Skip empty subcategories

                    const subcatDiv = document.createElement('div');
                    subcatDiv.className = 'subcategory';
                    
                    const subcatHeader = document.createElement('div');
                    subcatHeader.className = 'subcategory-header';
                    subcatHeader.innerHTML = `
                        <span>${subcat}</span>
                        <span class="category-count">${series.length}</span>
                    `;
                    subcatHeader.onclick = (event) => {
                        event.stopPropagation(); // Prevent main category from toggling
                        toggleSubcategory(mainCategory, subcat);
                    };
                    
                    const seriesList = document.createElement('div');
                    seriesList.className = 'series-list';
                    seriesList.id = `series-${mainCategory.replace(/[^a-zA-Z0-9]/g, '-')}-${subcat.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    
                    series.forEach(item => {
                        const seriesItem = document.createElement('div');
                        seriesItem.className = 'series-item';
                        seriesItem.innerHTML = `
                            <span class="series-name">${item.name}</span>
                            <span class="series-symbol">${item.symbol}</span>
                            <button class="add-btn" id="btn-${item.symbol}" onclick="event.stopPropagation(); addToWatchlist('${item.symbol}', '${item.name.replace(/'/g, "\\'")}')">Add</button>
                        `;
                        seriesList.appendChild(seriesItem);
                    });
                    
                    subcatDiv.appendChild(subcatHeader);
                    subcatDiv.appendChild(seriesList);
                    subcatContainer.appendChild(subcatDiv);
                });
                
                mainDiv.appendChild(mainHeader);
                mainDiv.appendChild(subcatContainer);
                categoryList.appendChild(mainDiv);
            });
        }

        function toggleMainCategory(category) {
            const id = `main-${category.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const element = document.getElementById(id);
            const header = element.previousElementSibling;
            
            // Close other main categories
            document.querySelectorAll('.main-category-header.active').forEach(activeHeader => {
                if (activeHeader !== header) {
                    activeHeader.classList.remove('active');
                    activeHeader.nextElementSibling.classList.remove('show');
                }
            });

            element.classList.toggle('show');
            header.classList.toggle('active');
        }

        function toggleSubcategory(mainCategory, subCategory) {
            const id = `series-${mainCategory.replace(/[^a-zA-Z0-9]/g, '-')}-${subCategory.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const element = document.getElementById(id);
            const header = element.previousElementSibling;

            // Close other subcategories within the same main category
            const parentSubcategoriesContainer = element.closest('.subcategories');
            parentSubcategoriesContainer.querySelectorAll('.subcategory-header.active').forEach(activeHeader => {
                 if (activeHeader !== header) {
                    activeHeader.classList.remove('active'); // Optional: visual cue for active subcat header
                    activeHeader.nextElementSibling.classList.remove('show');
                }
            });
            
            element.classList.toggle('show');
            header.classList.toggle('active'); // Optional: visual cue for active subcat header
        }

        document.getElementById('searchInput').addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length < 2) {
                document.getElementById('searchResults').style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(() => performSearch(query), 300);
        });

        function performSearch(query) {
            const results = [];
            
            Object.entries(economicData).forEach(([mainCat, subcats]) => {
                Object.entries(subcats).forEach(([subcat, series]) => {
                    series.forEach(item => {
                        if (item.name.toLowerCase().includes(query) || 
                            item.symbol.toLowerCase().includes(query)) {
                            results.push({
                                ...item,
                                category: `${mainCat} > ${subcat}`
                            });
                        }
                    });
                });
            });
            
            // MODIFIED: Display all results, not just a slice.
            // You might want to re-introduce a limit or add pagination if results lists are very long.
            displaySearchResults(results);
        }

        function displaySearchResults(results) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div style="padding: 10px 16px; color: #888;">No results found</div>';
            } else {
                container.innerHTML = results.map(item => `
                    <div class="search-result-item" onclick="addToWatchlist('${item.symbol}', '${item.name.replace(/'/g, "\\'")}')">
                        <div class="search-result-info">
                            <div class="search-result-title">${item.name}</div>
                            <div class="search-result-symbol">${item.symbol} - ${item.category}</div>
                        </div>
                        <button class="add-btn" id="search-btn-${item.symbol}">Add</button> 
                    </div>
                `).join('');
                 // Re-attach event listeners or ensure addToWatchlist is correctly called for search results
                results.forEach(item => {
                    const btn = container.querySelector(`#search-btn-${item.symbol}`);
                    if(btn) {
                        btn.onclick = (event) => {
                             event.stopPropagation(); // Important if parent div also has a click
                             addToWatchlist(item.symbol, item.name.replace(/'/g, "\\'"));
                        };
                    }
                    // Check if item is already in watchlist to disable button
                    const isInWatchlist = watchlist.some(watchlistItem => watchlistItem.symbol === item.symbol);
                    if (isInWatchlist && btn) {
                        btn.textContent = 'Added';
                        btn.disabled = true;
                    }
                });
            }
            
            container.style.display = 'block';
        }
        
        document.addEventListener('click', function(e) {
            const searchContainer = e.target.closest('.search-container');
            if (!searchContainer) {
                document.getElementById('searchResults').style.display = 'none';
            }
        });


        async function addToWatchlist(symbol, name) {
            if (watchlist.find(item => item.symbol === symbol)) {
                // alert('This series is already in your watchlist'); // Can be annoying, button state is better
                return;
            }
            
            // Try to find button in category list first
            let btn = document.getElementById(`btn-${symbol}`);
            if (!btn) { // If not found, try to find in search results
                btn = document.getElementById(`search-btn-${symbol}`);
            }
            // If still not found (e.g. if called programmatically or button ID scheme changes)
            // we can try to find a generic button if one was clicked, but it's less reliable.
            // For now, we assume one of the above buttons exists if UI was used.

            if (btn) {
                btn.textContent = 'Loading...';
                btn.disabled = true;
            }
            
            try {
                const data = await fetchSeriesData(symbol);
                if (data && data.length > 0) {
                    seriesData[symbol] = data;
                    watchlist.push({ symbol, name });
                    updateWatchlistDisplay();
                    updateStats();
                    saveWatchlistToLocalStorage(); // Save after adding

                    document.getElementById('searchResults').style.display = 'none';
                    // document.getElementById('searchInput').value = ''; // Keep search input if user wants to add more from same search
                    
                    if(btn) { // If we found a button, update it
                       btn.textContent = 'Added'; // Keep it disabled as it's now in watchlist
                    }
                    // Update any other buttons for this symbol
                    updateAddButtonStates(symbol, true);


                    if (failedSeries.size > 0 && watchlist.some(s => failedSeries.has(s.symbol))) {
                        document.getElementById('errorNote').style.display = 'block';
                    } else if (failedSeries.size === 0 || !watchlist.some(s => failedSeries.has(s.symbol))) {
                         document.getElementById('errorNote').style.display = 'none';
                    }

                } else {
                     // Handle case where data is empty but no error thrown (e.g. API returns empty array successfully)
                    failedSeries.add(symbol);
                    document.getElementById('errorNote').style.display = 'block';
                    alert(`No data available for ${symbol}. It might be a new or unsupported series.`);
                    if(btn) { // Reset button if fetch was 'successful' but empty
                        btn.textContent = 'Add';
                        btn.disabled = false;
                    }
                }
            } catch (error) {
                console.error('Error loading series:', symbol, error);
                failedSeries.add(symbol);
                document.getElementById('errorNote').style.display = 'block';
                alert(`Unable to load data for ${symbol}. This series may not be available or there was a network issue.`);
                if (btn) { // Reset button on error
                    btn.textContent = 'Add';
                    btn.disabled = false;
                }
            }
        }

        function updateAddButtonStates(symbol, isInWatchlist) {
            const categoryBtn = document.getElementById(`btn-${symbol}`);
            const searchBtn = document.getElementById(`search-btn-${symbol}`);

            if (categoryBtn) {
                categoryBtn.textContent = isInWatchlist ? 'Added' : 'Add';
                categoryBtn.disabled = isInWatchlist;
            }
            if (searchBtn) {
                searchBtn.textContent = isInWatchlist ? 'Added' : 'Add';
                searchBtn.disabled = isInWatchlist;
            }
        }


        async function fetchSeriesData(symbol) {
            // This function fetches historical data for a *specific series symbol*.
            // The amount of historical data (number of data points) depends on what the API returns.
            // If the API paginates responses for a single series (e.g., returns 1000 points + a next_page token),
            // this function would need to be modified to handle fetching all pages.
            // Currently, it processes whatever data is returned in the first API call.
            try {
                const url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=fred`; // Assuming 'fred' is a general provider or backend handles routing
                console.log(`Workspaceing: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    // Try to get more specific error from response body if possible
                    let errorMsg = `HTTP error ${response.status}`;
                    try {
                        const errorData = await response.json();
                        if (errorData && errorData.error) errorMsg += `: ${errorData.error}`;
                        else if (errorData && errorData.message) errorMsg += `: ${errorData.message}`;
                    } catch (e) { /* ignore if response is not json */ }
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                console.log(`Response for ${symbol}:`, data);
                
                let results = [];
                // Common API response structures
                if (data && data.data && Array.isArray(data.data)) { // Structure { "data": [...] }
                    results = data.data;
                } else if (data && data.observations && Array.isArray(data.observations)) { // FRED-like structure
                    results = data.observations.map(obs => ({ date: obs.date, value: parseFloat(obs.value) }));
                } else if (data && data.results && Array.isArray(data.results)) { // Another common structure
                    results = data.results;
                } else if (Array.isArray(data)) { // Direct array response
                    results = data;
                } else if (typeof data === 'object' && data !== null) { // For single object response or nested data
                    // Attempt to find a likely array of data if not in expected paths
                    for (const key in data) {
                        if (Array.isArray(data[key]) && data[key].length > 0) {
                            // Check if array items look like data points
                            const firstItem = data[key][0];
                            if (typeof firstItem === 'object' && firstItem !== null && ('date' in firstItem || 'Date' in firstItem || 'DATE' in firstItem) && ('value'in firstItem || 'Value' in firstItem || 'VALUE' in firstItem )) {
                                results = data[key];
                                break;
                            }
                        }
                    }
                }


                if (results.length === 0 && !(data.observations && data.observations.length === 0)) { // Allow empty observations array if that's the structure
                    console.warn(`No data series found in response for ${symbol}, or format not recognized. Response:`, data);
                    // Do not throw error yet, let processing try
                }
                
                const processedData = results.map(item => {
                    const date = item.date || item.Date || item.DATE || item.timestamp; // Add timestamp
                    const valueString = item[symbol] || // If data is { "symbol": value }
                                      item.value || 
                                      item.Value || 
                                      item.VALUE ||
                                      item.close || // for financial series
                                      item.Close ||
                                      item.price ||
                                      item.Price;
                    
                    // Handle cases where value might be "." (FRED specific for NaN) or other non-numeric strings
                    const value = (valueString === "." || valueString === null || valueString === undefined) ? NaN : parseFloat(valueString);
                    return { date: new Date(date), value: value };
                }).filter(item => item.date instanceof Date && !isNaN(item.date.getTime()) && !isNaN(item.value) && item.value !== null) // Ensure date is valid & value is a number
                  .sort((a, b) => a.date - b.date);
                
                if (processedData.length === 0) {
                     console.warn(`No valid data points after processing for ${symbol}. Original items: ${results.length}`);
                     // If original results had items, but processing yielded none, it indicates a data format issue or all values were invalid.
                     // If results were initially empty, this is expected.
                     if (results.length > 0) {
                        throw new Error('Processed data is empty, check data format or values.');
                     } else {
                        // API returned no data points, this is not an error in itself, just an empty series.
                        // addToWatchlist handles this by alerting "No data available"
                     }
                }
                
                console.log(`Successfully fetched and processed ${processedData.length} data points for ${symbol}`);
                return processedData;
                
            } catch (error) {
                console.error(`Error fetching or processing data for ${symbol}:`, error);
                failedSeries.add(symbol); // Track failure
                document.getElementById('errorNote').style.display = 'block';
                throw error; // Re-throw to be caught by addToWatchlist
            }
        }

        function calculateChange(data, days) {
            if (!data || data.length < 2) return null;
            
            const latest = data[data.length - 1];
            if (!latest || !(latest.date instanceof Date) || isNaN(latest.value)) return null;

            const targetDate = new Date(latest.date);
            targetDate.setDate(targetDate.getDate() - days);
            
            let closest = null;
            // Iterate backwards from the second to last point
            for (let i = data.length - 2; i >= 0; i--) {
                const currentDate = data[i].date;
                if (!(currentDate instanceof Date) || isNaN(data[i].value)) continue;

                if (currentDate <= targetDate) {
                    closest = data[i];
                    break; // Found the first point on or before the target date
                }
                // If no exact match, keep the one closest before targetDate (implicitly the last one checked if loop finishes)
                if (closest === null || Math.abs(currentDate - targetDate) < Math.abs(closest.date - targetDate)) {
                     if (currentDate < latest.date) closest = data[i]; // ensure it's an earlier point
                }
            }
             if (!closest && data.length > 1 && data[0].date < latest.date) { // Fallback to earliest if no other found
                // This case handles when all other data points are after targetDate but before latest.date
                // This might not be the desired behavior for "days ago", but it's a fallback.
                // A more robust solution might be to find the point *closest* to targetDate.
                // For now, if no point is found *before* targetDate, we can't calculate change.
                 return null;
            }
            if (!closest) return null;
            
            const change = latest.value - closest.value;
            const percentChange = closest.value !== 0 ? (change / closest.value) * 100 : (latest.value !== 0 ? Infinity : 0); // Handle division by zero
            
            return { change, percentChange, previousDate: closest.date, previousValue: closest.value };
        }

        function calculateYTDChange(data) {
            if (!data || data.length === 0) return null;
            
            const latest = data[data.length - 1];
            if (!latest || !(latest.date instanceof Date) || isNaN(latest.value)) return null;

            const currentYear = latest.date.getFullYear();
            // Find the last trading day of the previous year, or first of current if no prior year data
            let yearStartDataPoint = null;

            // Look for the last data point of the previous year
            for (let i = data.length - 1; i >= 0; i--) {
                const point = data[i];
                if (point.date.getFullYear() < currentYear) {
                    yearStartDataPoint = point;
                    break;
                }
            }
            // If no data from previous year, use the earliest data point from the current year (if not latest)
            if (!yearStartDataPoint) {
                for (let i = 0; i < data.length; i++) {
                    const point = data[i];
                     if (point.date.getFullYear() === currentYear && point.date < latest.date) {
                        yearStartDataPoint = point;
                        break;
                    }
                }
                if (!yearStartDataPoint && data[0].date < latest.date) yearStartDataPoint = data[0]; // Fallback to very first point if only one year of data and it's not just a single point
                else if (!yearStartDataPoint && data.length === 1) return null; // Not enough data for YTD
            }


            if (!yearStartDataPoint || yearStartDataPoint.date >= latest.date) return null; // Not enough historical data or only one point
            
            const change = latest.value - yearStartDataPoint.value;
            const percentChange = yearStartDataPoint.value !== 0 ? (change / yearStartDataPoint.value) * 100 : (latest.value !== 0 ? Infinity : 0);
            
            return { change, percentChange, previousDate: yearStartDataPoint.date, previousValue: yearStartDataPoint.value  };
        }


        function updateWatchlistDisplay() {
            const container = document.getElementById('watchlistContent');
            
            if (watchlist.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>Your watchlist is empty</h3>
                        <p>Search or browse categories to add series to your watchlist</p>
                    </div>
                `;
                document.getElementById('statsBar').style.display = 'none';
                return;
            }
            
            document.getElementById('statsBar').style.display = 'flex';
            
            let tableHTML = `
                <table class="watchlist-table">
                    <thead>
                        <tr>
                            <th>Series</th>
                            <th>Current Value (Date)</th>
                            <th>Daily %</th>
                            <th>Weekly %</th>
                            <th>Monthly %</th>
                            <th>Quarterly %</th>
                            <th>YTD %</th>
                            <th>1 Year %</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) { // Handle missing data for a symbol
                    tableHTML += `
                        <tr>
                            <td>
                                <div class="series-name-cell">${item.name}</div>
                                <div class="series-symbol-cell">${item.symbol}</div>
                            </td>
                            <td class="value-cell" colspan="6">Data unavailable</td>
                            <td><button class="remove-btn" onclick="removeFromWatchlist('${item.symbol}')">Remove</button></td>
                        </tr>
                    `;
                    return;
                };
                
                const latest = data[data.length - 1];
                const daily = calculateChange(data, 1);
                const weekly = calculateChange(data, 7);
                const monthly = calculateChange(data, 30);
                const quarterly = calculateChange(data, 90);
                const ytd = calculateYTDChange(data);
                const yearly = calculateChange(data, 365);
                
                tableHTML += `
                    <tr>
                        <td>
                            <div class="series-name-cell">${item.name}</div>
                            <div class="series-symbol-cell">${item.symbol}</div>
                        </td>
                        <td class="value-cell">${formatValue(latest.value)} (${latest.date.toLocaleDateString()})</td>
                        <td class="value-cell ${getChangeClass(daily?.percentChange)}">${formatPercent(daily?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(weekly?.percentChange)}">${formatPercent(weekly?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(monthly?.percentChange)}">${formatPercent(monthly?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(quarterly?.percentChange)}">${formatPercent(quarterly?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(ytd?.percentChange)}">${formatPercent(ytd?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(yearly?.percentChange)}">${formatPercent(yearly?.percentChange)}</td>
                        <td><button class="remove-btn" onclick="removeFromWatchlist('${item.symbol}')">Remove</button></td>
                    </tr>
                `;
            });
            
            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;
        }

        function updateStats() {
            let gainers = 0;
            let losers = 0;
            let totalDataPoints = 0;
            
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) return;
                
                totalDataPoints += data.length;
                const daily = calculateChange(data, 1); // Use daily change for gainer/loser count
                if (daily) {
                    if (daily.percentChange > 0.0001) gainers++; // Use a small threshold to avoid floating point issues with 0
                    else if (daily.percentChange < -0.0001) losers++;
                }
            });
            
            document.getElementById('totalSeries').textContent = watchlist.length;
            document.getElementById('gainers').textContent = gainers;
            document.getElementById('losers').textContent = losers;
            document.getElementById('dataPoints').textContent = formatNumber(totalDataPoints);
        }

        function formatValue(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            if (Math.abs(value) >= 1e12) return (value / 1e12).toFixed(2) + 'T'; // Trillions
            if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(2) + 'B';
            if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(2) + 'M';
            // if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(2) + 'K'; // Often not needed for econ data
            if (Math.abs(value) < 0.0001 && value !==0) return value.toExponential(2); // For very small numbers
            if (Math.abs(value) < 1 && value !==0) return value.toFixed(4);
            return value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function formatPercent(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            if (value === Infinity) return '∞%';
            if (value === -Infinity) return '-∞%';
            const sign = value > 0.0001 ? '+' : ''; // Add sign only if strictly positive
            return sign + value.toFixed(2) + '%';
        }

        function formatNumber(num) {
            if (num === null || num === undefined || isNaN(num)) return '-';
            return num.toLocaleString();
        }

        function getChangeClass(value) {
            if (value === null || value === undefined || isNaN(value)) return 'neutral';
            if (value > 0.0001) return 'positive';
            if (value < -0.0001) return 'negative';
            return 'neutral';
        }

        function removeFromWatchlist(symbol) {
            watchlist = watchlist.filter(item => item.symbol !== symbol);
            delete seriesData[symbol]; // Remove its data
            failedSeries.delete(symbol); // Remove from failed if it was there
            
            updateWatchlistDisplay();
            updateStats();
            saveWatchlistToLocalStorage(); // Save after removing
            updateAddButtonStates(symbol, false); // Update button states in sidebar/search

            // Hide error note if no remaining watchlist items are in failedSeries
            if (!watchlist.some(s => failedSeries.has(s.symbol))) {
                document.getElementById('errorNote').style.display = 'none';
            }
        }

        async function refreshAllData() {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '⏳ Refreshing...';
            btn.disabled = true;
            
            // Create a temporary copy of watchlist symbols to iterate over,
            // as fetchSeriesData might modify failedSeries set
            const symbolsToRefresh = watchlist.map(item => item.symbol);
            failedSeries.clear(); // Clear past failures before refresh attempt
            document.getElementById('errorNote').style.display = 'none';


            const promises = symbolsToRefresh.map(symbol => 
                fetchSeriesData(symbol)
                    .then(data => {
                        if (data && data.length > 0) {
                            seriesData[symbol] = data;
                        } else if (data && data.length === 0) {
                            // API returned success but no data points. Keep existing data if any, or mark as failed to load.
                            // For refresh, perhaps better to clear old data if new fetch is empty.
                            // seriesData[symbol] = []; // Or handle as failed if you prefer
                            console.warn(`Refresh for ${symbol} returned no data points.`);
                            failedSeries.add(symbol); // Mark as failed if refresh yields nothing
                        }
                    })
                    .catch(error => {
                        console.error(`Failed to refresh data for ${symbol}:`, error);
                        // failedSeries.add(symbol); // fetchSeriesData already adds to failedSeries on error
                        // Do not remove from watchlist, just indicate data couldn't be refreshed
                    })
            );
            
            await Promise.allSettled(promises); // Use allSettled to ensure all fetches complete
                        
            updateWatchlistDisplay();
            updateStats();
            saveWatchlistToLocalStorage(); // Save potentially updated data

            if (failedSeries.size > 0 && watchlist.some(s => failedSeries.has(s.symbol))) {
                 document.getElementById('errorNote').style.display = 'block';
            }

            btn.textContent = originalText;
            btn.disabled = false;
        }

        function downloadWatchlist() {
            if (watchlist.length === 0) {
                alert('Your watchlist is empty');
                return;
            }
            
            let csvContent = 'Series Name,Symbol,Current Value,Current Value Date,';
            csvContent += 'Daily %,Weekly %,Monthly %,Quarterly %,YTD %,1 Year %\n';
            
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                let row = `"${item.name.replace(/"/g, '""')}",${item.symbol},`;

                if (!data || data.length === 0) {
                    row += 'N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A\n';
                    csvContent += row;
                    return;
                }
                
                const latest = data[data.length - 1];
                const daily = calculateChange(data, 1);
                const weekly = calculateChange(data, 7);
                const monthly = calculateChange(data, 30);
                const quarterly = calculateChange(data, 90);
                const ytd = calculateYTDChange(data);
                const yearly = calculateChange(data, 365);
                
                row += `${latest.value || ''},${latest.date ? latest.date.toISOString().split('T')[0] : ''},`;
                row += `${daily?.percentChange?.toFixed(4) || ''},`;
                row += `${weekly?.percentChange?.toFixed(4) || ''},`;
                row += `${monthly?.percentChange?.toFixed(4) || ''},`;
                row += `${quarterly?.percentChange?.toFixed(4) || ''},`;
                row += `${ytd?.percentChange?.toFixed(4) || ''},`;
                row += `${yearly?.percentChange?.toFixed(4) || ''}\n`;
                csvContent += row;
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `watchlist_data_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } else {
                alert("CSV download not supported by your browser.");
            }
        }

        function clearWatchlist() {
            if (confirm('Are you sure you want to clear your entire watchlist?')) {
                const symbolsToUpdateButtonsFor = watchlist.map(item => item.symbol);
                watchlist = [];
                seriesData = {};
                failedSeries.clear();
                document.getElementById('errorNote').style.display = 'none';
                updateWatchlistDisplay();
                updateStats();
                saveWatchlistToLocalStorage(); // Clear saved watchlist
                symbolsToUpdateButtonsFor.forEach(symbol => updateAddButtonStates(symbol, false));
            }
        }

        function saveWatchlistToLocalStorage() {
            // Save only symbols and names, data will be refetched
            const watchlistToSave = watchlist.map(item => ({ symbol: item.symbol, name: item.name }));
            localStorage.setItem('economicWatchlist', JSON.stringify(watchlistToSave));
        }

        async function loadWatchlistFromLocalStorage() {
            const savedWatchlist = localStorage.getItem('economicWatchlist');
            if (savedWatchlist) {
                const parsedWatchlist = JSON.parse(savedWatchlist);
                // To prevent UI blocking, load data for each item sequentially with visual feedback
                // or in parallel with a global loading indicator.
                // For simplicity here, we'll add them and then trigger a refresh which can show loading states.
                
                document.getElementById('watchlistContent').innerHTML = '<div class="loading">Loading watchlist...</div>';

                for (const item of parsedWatchlist) {
                     // Temporarily add to watchlist structure without data to avoid "already in watchlist" issues
                     // if addToWatchlist is called directly.
                     // Or, design addToWatchlist to handle pre-population.
                     // Here, we'll pre-populate `watchlist` and then fetch all.
                     if (!watchlist.find(i => i.symbol === item.symbol)) {
                         watchlist.push({ symbol: item.symbol, name: item.name });
                     }
                }
                 // Update button states for all initially loaded items
                watchlist.forEach(item => updateAddButtonStates(item.symbol, true));

                if (watchlist.length > 0) {
                    await refreshAllData(); // This will fetch data for all items now in the watchlist array
                } else {
                     updateWatchlistDisplay(); // Update to empty if nothing was loaded
                }
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initializeCategories();
            loadWatchlistFromLocalStorage(); // Load saved watchlist
        });
    </script>
</body>
</html>