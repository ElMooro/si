<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Economic Data Watchlist - Enhanced</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <style>
        /* Existing styles remain unchanged */
        /* ... (Your provided CSS styles are kept as is) ... */
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2 style="color: #4a9eff; margin-bottom: 20px;">Global Economic Data Explorer</h2>
            <div class="search-container">
                <input 
                    type="text" 
                    id="searchInput" 
                    class="search-input" 
                    placeholder="Search economic series..."
                    autocomplete="off"
                >
                <span class="search-icon">üîç</span>
                <div id="searchResults" class="search-results"></div>
            </div>
            <div class="category-browser">
                <h3>Browse by Source</h3>
                <div id="categoryList"></div>
            </div>
        </aside>

        <main class="main-content">
            <div class="header">
                <h1>Global Economic Data Watchlist</h1>
                <p>Track economic indicators from FRED, ECB, NY Fed, and OFR
                    <span class="live-indicator">
                        <span class="live-dot"></span>
                        LIVE
                    </span>
                </p>
                <div style="background: #ff9800; color: #000; padding: 10px; margin-top: 15px; border-radius: 6px; font-size: 0.9em;">
                    <strong>Demo Mode:</strong> Currently using simulated data. To use real FRED data:
                    <ol style="margin: 5px 0 0 20px;">
                        <li>Get a free API key from <a href="https://fred.stlouisfed.org/docs/api/api debtor_key.html" target="_blank" style="color: #000; text-decoration: underline;">FRED</a></li>
                        <li>Replace 'YOUR_FRED_API_KEY' in the code</li>
                        <li>Set USE_MOCK_DATA = false</li>
                    </ol>
                </div>
            </div>

            <div id="errorNote" class="error-note" style="display: none;">
                Note: Some series may not be available through the API. FRED series typically have the best coverage.
            </div>

            <div id="analyticsPanel" class="analytics-panel" style="display: none;">
                <div class="analytics-header">
                    <h3 class="analytics-title">Market Analytics</h3>
                    <div class="view-toggle">
                        <button class="toggle-btn active" onclick="toggleView('analytics')">Analytics</button>
                        <button class="toggle-btn" onclick="toggleView('correlation')">Correlation</button>
                        <button class="toggle-btn" onclick="toggleView('risk')">Risk Analysis</button>
                    </div>
                </div>
                
                <div id="analyticsContent">
                    <div class="analytics-grid">
                        <div class="analytics-card">
                            <h4>Market Momentum</h4>
                            <div class="analytics-value" id="marketMomentum">--</div>
                            <div class="analytics-subtitle">Based on % gainers</div>
                        </div>
                        <div class="analytics-card">
                            <h4>Volatility Index</h4>
                            <div class="analytics-value" id="volatilityIndex">--</div>
                            <div class="analytics-subtitle">Average daily change</div>
                        </div>
                        <div class="analytics-card">
                            <h4>Trend Strength</h4>
                            <div class="analytics-value" id="trendStrength">--</div>
                            <div class="analytics-subtitle">Weekly momentum</div>
                        </div>
                        <div class="analytics-card">
                            <h4>Data Freshness</h4>
                            <div class="analytics-value" id="dataFreshness">--</div>
                            <div class="analytics-subtitle">Last update</div>
                        </div>
                    </div>

                    <div class="heatmap-container">
                        <h4 class="heatmap-title">Performance Heatmap (Daily %)</h4>
                        <div id="heatmapGrid" class="heatmap-grid"></div>
                    </div>
                </div>

                <div id="correlationContent" class="correlation-matrix" style="display: none;">
                    <h4 class="correlation-title">Correlation Matrix</h4>
                    <div id="correlationMatrix"></div>
                </div>

                <div id="riskContent" class="risk-analysis-container" style="display: none;">
                    <h4 class="risk-title">Risk Analysis Dashboard</h4>
                    <div class="risk-metrics">
                        <div class="risk-metric-card">
                            <h5>Market Risk Score</h5>
                            <div class="risk-score" id="marketRiskScore">--</div>
                            <div class="risk-label" id="marketRiskLabel">--</div>
                        </div>
                        <div class="risk-metric-card">
                            <h5>Volatility Percentile</h5>
                            <div class="risk-percentile" id="volatilityPercentile">--</div>
                            <div class="risk-label">Market volatility rank</div>
                        </div>
                        <div class="risk-metric-card">
                            <h5>Stress Events</h5>
                            <div class="stress-count" id="stressEvents">--</div>
                            <div class="risk-label">High volatility days</div>
                        </div>
                    </div>
                    <div class="risk-histogram">
                        <h4 class="histogram-title">Risk Distribution</h4>
                        <div class="histogram-controls">
                            <select id="histogramMetric">
                                <option value="daily_change">Daily % Change</option>
                                <option value="volatility">Volatility</option>
                                <option value="returns">Returns</option>
                            </select>
                            <button class="histogram-btn" onclick="updateRiskHistogram()">Update</button>
                        </div>
                        <div id="histogramContainer">
                            <canvas id="riskHistogram"></canvas>
                        </div>
                        <div class="histogram-legend" id="histogramLegend"></div>
                    </div>
                    <div class="risk-indicators">
                        <h4>Risk Indicators</h4>
                        <div id="riskIndicatorsList"></div>
                    </div>
                </div>
            </div>

            <div id="statsBar" class="stats-bar" style="display: none;">
                <div class="stat-item">
                    <div class="stat-value" id="totalSeries">0</div>
                    <div class="stat-label">Series Tracked</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value positive" id="gainers">0</div>
                    <div class="stat-label">Gainers</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value negative" id="losers">0</div>
                    <div class="stat-label">Losers</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="dataPoints">0</div>
                    <div class="stat-label">Data Points</div>
                </div>
            </div>

            <div class="watchlist-container">
                <div class="watchlist-header">
                    <h2 class="watchlist-title">My Watchlist</h2>
                    <div class="watchlist-controls">
                        <button class="watchlist-btn" onclick="toggleAutoRefresh()">
                            <span id="autoRefreshIcon">‚ñ∂Ô∏è</span>
                            <span id="autoRefreshText">Auto Refresh</span>
                        </button>
                        <button class="watchlist-btn" onclick="refreshAllData()">üîÑ Refresh All</button>
                        <button class="watchlist-btn" onclick="downloadWatchlist()">üì• Download CSV</button>
                        <button class="watchlist-btn" onclick="clearWatchlist()">üóëÔ∏è Clear All</button>
                    </div>
                </div>

                <div id="watchlistContent">
                    <div class="empty-state">
                        <h3>Your watchlist is empty</h3>
                        <p>Search or browse categories to add series to your watchlist</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const API_BASE = 'https://api.stlouisfed.org/fred';
        const API_KEY = 'YOUR_FRED_API_KEY';
        const USE_MOCK_DATA = true;

        // Economic data series (unchanged)
        const economicData = { /* Your provided economicData object remains unchanged */ };

        let watchlist = [];
        let seriesData = {};
        let searchTimeout;
        let failedSeries = new Set();
        let autoRefreshInterval = null;
        let currentView = 'analytics';
        let riskIndicators = [];
        let histogramChart = null;

        function initializeCategories() {
            const categoryList = document.getElementById('categoryList');
            Object.entries(economicData).forEach(([mainCategory, subcategories]) => {
                const mainDiv = document.createElement('div');
                mainDiv.className = 'main-category';
                const totalSeries = Object.values(subcategories).reduce((acc, arr) => acc + arr.length, 0);
                const mainHeader = document.createElement('div');
                mainHeader.className = 'main-category-header';
                mainHeader.innerHTML = `
                    <span>${mainCategory}</span>
                    <span class="category-count">${totalSeries}</span>
                `;
                mainHeader.onclick = () => toggleMainCategory(mainCategory);
                const subcatContainer = document.createElement('div');
                subcatContainer.className = 'subcategories';
                subcatContainer.id = `main-${mainCategory.replace(/[^a-zA-Z0-9]/g, '-')}`;
                Object.entries(subcategories).forEach(([subcat, series]) => {
                    const subcatDiv = document.createElement('div');
                    subcatDiv.className = 'subcategory';
                    const subcatHeader = document.createElement('div');
                    subcatHeader.className = 'subcategory-header';
                    subcatHeader.innerHTML = `
                        <span>${subcat}</span>
                        <span class="category-count">${series.length}</span>
                    `;
                    subcatHeader.onclick = () => toggleSubcategory(mainCategory, subcat);
                    const seriesList = document.createElement('div');
                    seriesList.className = 'series-list';
                    seriesList.id = `series-${mainCategory.replace(/[^a-zA-Z0-9]/g, '-')}-${subcat.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    series.forEach(item => {
                        const seriesItem = document.createElement('div');
                        seriesItem.className = 'series-item';
                        seriesItem.innerHTML = `
                            <span class="series-name">${item.name}</span>
                            <span class="series-symbol">${item.symbol}</span>
                            <button class="add-btn" id="btn-${item.symbol}" onclick="addToWatchlist('${item.symbol}', '${item.name.replace(/'/g, "\\'")}')">Add</button>
                        `;
                        seriesList.appendChild(seriesItem);
                    });
                    subcatDiv.appendChild(subcatHeader);
                    subcatDiv.appendChild(seriesList);
                    subcatContainer.appendChild(subcatDiv);
                });
                mainDiv.appendChild(mainHeader);
                mainDiv.appendChild(subcatContainer);
                categoryList.appendChild(mainDiv);
            });
        }

        function toggleMainCategory(category) {
            const id = `main-${category.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const element = document.getElementById(id);
            const header = element.previousElementSibling;
            document.querySelectorAll('.subcategories').forEach(sub => {
                if (sub.id !== id) {
                    sub.classList.remove('show');
                    sub.previousElementSibling.classList.remove('active');
                }
            });
            element.classList.toggle('show');
            header.classList.toggle('active');
        }

        function toggleSubcategory(mainCategory, subCategory) {
            const id = `series-${mainCategory.replace(/[^a-zA-Z0-9]/g, '-')}-${subCategory.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const element = document.getElementById(id);
            const parent = element.closest('.subcategories');
            parent.querySelectorAll('.series-list').forEach(list => {
                if (list.id !== id) {
                    list.classList.remove('show');
                }
            });
            element.classList.toggle('show');
        }

        document.getElementById('searchInput').addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            const query = e.target.value.toLowerCase().trim();
            if (query.length < 2) {
                document.getElementById('searchResults').style.display = 'none';
                return;
            }
            searchTimeout = setTimeout(() => performSearch(query), 300);
        });

        function performSearch(query) {
            const results = [];
            Object.entries(economicData).forEach(([mainCat, subcats]) => {
                Object.entries(subcats).forEach(([subcat, series]) => {
                    series.forEach(item => {
                        if (item.name.toLowerCase().includes(query) || 
                            item.symbol.toLowerCase().includes(query)) {
                            results.push({
                                ...item,
                                category: `${mainCat} > ${subcat}`
                            });
                        }
                    });
                });
            });
            displaySearchResults(results.slice(0, 20));
        }

        function displaySearchResults(results) {
            const container = document.getElementById('searchResults');
            if (results.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No results found</div>';
            } else {
                container.innerHTML = results.map(item => `
                    <div class="search-result-item">
                        <div class="search-result-info">
                            <div class="search-result-title">${item.name}</div>
                            <div class="search-result-symbol">${item.symbol} - ${item.category}</div>
                        </div>
                        <button class="add-btn" onclick="addToWatchlist('${item.symbol}', '${item.name.replace(/'/g, "\\'")}')">Add</button>
                    </div>
                `).join('');
            }
            container.style.display = 'block';
        }

        document.addEventListener('click', function(e) {
            if (!e.target.closest('.search-container')) {
                document.getElementById('searchResults').style.display = 'none';
            }
        });

        async function addToWatchlist(symbol, name) {
            if (watchlist.find(item => item.symbol === symbol)) {
                alert('This series is already in your watchlist');
                return;
            }
            const btn = document.getElementById(`btn-${symbol}`) || event.target;
            btn.textContent = 'Loading...';
            btn.disabled = true;
            try {
                const data = await fetchSeriesData(symbol);
                if (data && data.length > 0) {
                    seriesData[symbol] = data;
                    watchlist.push({ symbol, name });
                    updateWatchlistDisplay();
                    updateStats();
                    updateAnalytics();
                    updateRiskIndicators(symbol, name);
                    document.getElementById('searchResults').style.display = 'none';
                    document.getElementById('searchInput').value = '';
                    if (failedSeries.size > 0) {
                        document.getElementById('errorNote').style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Error loading series:', error);
                failedSeries.add(symbol);
                alert(`Unable to load data for ${symbol}. This series may not be available through the API.`);
            } finally {
                btn.textContent = 'Add';
                btn.disabled = false;
            }
        }

        async function fetchSeriesData(symbol) {
            try {
                if (USE_MOCK_DATA || API_KEY === 'YOUR_FRED_API_KEY') {
                    console.log(`Using mock data for ${symbol}`);
                    return generateMockData(symbol);
                }
                const endDate = new Date().toISOString().split('T')[0];
                const startDate = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                const url = `${API_BASE}/series/observations?series_id=${symbol}&api_key=${API_KEY}&file_type=json&observation_start=${startDate}&observation_end=${endDate}`;
                const response = await fetch(url, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                if (!data.observations || data.observations.length === 0) {
                    throw new Error('No data available');
                }
                const processedData = data.observations
                    .filter(obs => obs.value !== '.')
                    .map(obs => ({
                        date: new Date(obs.date),
                        value: parseFloat(obs.value)
                    }))
                    .filter(item => !isNaN(item.value))
                    .sort((a, b) => a.date - b.date);
                if (processedData.length === 0) {
                    throw new Error('No valid data points');
                }
                return processedData;
            } catch (error) {
                console.error(`Error fetching ${symbol}:`, error);
                return generateMockData(symbol);
            }
        }

        function generateMockData(symbol) {
            const data = [];
            const now = new Date();
            let baseValue, volatility, trend;
            if (symbol.includes('DGS') || symbol.includes('Treasury')) {
                baseValue = parseFloat(symbol.replace('DGS', '')) || 3;
                volatility = 0.1;
                trend = 0.001;
            } else if (symbol === 'VIX' || symbol === 'VIXCLS') {
                baseValue = 18;
                volatility = 3;
                trend = 0;
            } else if (symbol.includes('SPREAD') || symbol.includes('Y2Y') || symbol.includes('Y3M')) {
                baseValue = 1.5;
                volatility = 0.2;
                trend = -0.001;
            } else if (symbol === 'DFF' || symbol === 'EFFR') {
                baseValue = 5.25;
                volatility = 0.05;
                trend = 0;
            } else if (symbol.includes('M1') || symbol.includes('M2')) {
                baseValue = 20000;
                volatility = 100;
                trend = 50;
            } else if (symbol.includes('UNRATE') || symbol.includes('Unemployment')) {
                baseValue = 4;
                volatility = 0.2;
                trend = 0.002;
            } else if (symbol.includes('CPI') || symbol.includes('Inflation')) {
                baseValue = 3;
                volatility = 0.15;
                trend = 0.01;
            } else {
                baseValue = Math.random() * 100 + 50;
                volatility = Math.random() * 5 + 1;
                trend = (Math.random() - 0.5) * 0.1;
            }
            for (let i = 365; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                if (date.getDay() === 0 || date.getDay() === 6) continue;
                const randomWalk = (Math.random() - 0.5) * volatility;
                const trendComponent = trend * (365 - i);
                const seasonalComponent = Math.sin((365 - i) / 365 * Math.PI * 2) * volatility * 0.5;
                let value = baseValue + randomWalk + trendComponent + seasonalComponent;
                if (Math.random() < 0.02) {
                    value += (Math.random() - 0.5) * volatility * 3;
                }
                data.push({
                    date: date,
                    value: Math.max(0, value)
                });
            }
            return data;
        }

        function calculateChange(data, days) {
            if (!data || data.length < 2) return null;
            const latest = data[data.length - 1];
            const targetDate = new Date(latest.date);
            targetDate.setDate(targetDate.getDate() - days);
            let closest = null;
            let minDiff = Infinity;
            for (let i = data.length - 2; i >= 0; i--) {
                const diff = Math.abs(data[i].date - targetDate);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = data[i];
                }
                if (data[i].date < targetDate && minDiff < 7 * 24 * 60 * 60 * 1000) break;
            }
            if (!closest) return null;
            const change = latest.value - closest.value;
            const percentChange = closest.value !== 0 ? (change / closest.value) * 100 : 0;
            return { change, percentChange };
        }

        function calculateYTDChange(data) {
            if (!data || data.length < 2) return null;
            const latest = data[data.length - 1];
            const currentYear = latest.date.getFullYear();
            const startOfYear = new Date(currentYear, 0, 1);
            let yearStart = null;
            for (let i = 0; i < data.length; i++) {
                if (data[i].date >= startOfYear) {
                    yearStart = i > 0 ? data[i - 1] : data[i];
                    break;
                }
            }
            if (!yearStart) {
                yearStart = data[0];
            }
            const change = latest.value - yearStart.value;
            const percentChange = yearStart.value !== 0 ? (change / yearStart.value) * 100 : 0;
            return { change, percentChange };
        }

        function createSparkline(data, width = 120, height = 40) {
            if (!data || data.length < 2) return '';
            const recentData = data.slice(-30);
            const values = recentData.map(d => d.value);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;
            const points = recentData.map((d, i) => {
                const x = (i / (recentData.length - 1)) * width;
                const y = height - ((d.value - min) / range) * height;
                return `${x},${y}`;
            }).join(' ');
            const firstValue = recentData[0].value;
            const lastValue = recentData[recentData.length - 1].value;
            const color = lastValue >= firstValue ? '#4caf50' : '#ff5252';
            return `
                <svg class="sparkline" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                    <polyline
                        fill="none"
                        stroke="${color}"
                        stroke-width="2"
                        points="${points}"
                    />
                    <circle cx="${width}" cy="${height - ((lastValue - min) / range) * height}" r="3" fill="${color}"/>
                </svg>
            `;
        }

        function formatValue(value) {
            if (value === null || value === undefined) return '--';
            return Number.isInteger(value) ? value : value.toFixed(2);
        }

        function formatPercent(value) {
            if (value === null || value === undefined) return '--';
            return `${value.toFixed(2)}%`;
        }

        function getChangeClass(change) {
            if (change === null || change === undefined) return 'neutral';
            return change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
        }

        function updateWatchlistDisplay() {
            const container = document.getElementById('watchlistContent');
            if (watchlist.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>Your watchlist is empty</h3>
                        <p>Search or browse categories to add series to your watchlist</p>
                    </div>
                `;
                document.getElementById('statsBar').style.display = 'none';
                document.getElementById('analyticsPanel').style.display = 'none';
                return;
            }
            document.getElementById('statsBar').style.display = 'flex';
            document.getElementById('analyticsPanel').style.display = 'block';
            let tableHTML = `
                <table class="watchlist-table">
                    <thead>
                        <tr>
                            <th>Series</th>
                            <th>Sparkline</th>
                            <th>Current Value</th>
                            <th>Daily %</th>
                            <th>Weekly %</th>
                            <th>Monthly %</th>
                            <th>Quarterly %</th>
                            <th>YTD %</th>
                            <th>1 Year %</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) return;
                const latest = data[data.length - 1];
                const daily = calculateChange(data, 1);
                const weekly = calculateChange(data, 7);
                const monthly = calculateChange(data, 30);
                const quarterly = calculateChange(data, 90);
                const ytd = calculateYTDChange(data);
                const yearly = calculateChange(data, 365);
                const sparkline = createSparkline(data);
                tableHTML += `
                    <tr>
                        <td>
                            <div class="series-name-cell">${item.name}</div>
                            <div class="series-symbol-cell">${item.symbol}</div>
                        </td>
                        <td class="sparkline-cell">${sparkline}</td>
                        <td class="value-cell">${formatValue(latest.value)}</td>
                        <td class="value-cell ${getChangeClass(daily?.percentChange)}">${formatPercent(daily?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(weekly?.percentChange)}">${formatPercent(weekly?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(monthly?.percentChange)}">${formatPercent(monthly?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(quarterly?.percentChange)}">${formatPercent(quarterly?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(ytd?.percentChange)}">${formatPercent(ytd?.percentChange)}</td>
                        <td class="value-cell ${getChangeClass(yearly?.percentChange)}">${formatPercent(yearly?.percentChange)}</td>
                        <td><button class="remove-btn" onclick="removeFromWatchlist('${item.symbol}')">Remove</button></td>
                    </tr>
                `;
            });
            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;
        }

        function updateStats() {
            let gainers = 0;
            let losers = 0;
            let totalDataPoints = 0;
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) return;
                totalDataPoints += data.length;
                const daily = calculateChange(data, 1);
                if (daily) {
                    if (daily.percentChange > 0) gainers++;
                    else if (daily.percentChange < 0) losers++;
                }
            });
            document.getElementById('totalSeries').textContent = watchlist.length;
            document.getElementById('gainers').textContent = gainers;
            document.getElementById('losers').textContent = losers;
            document.getElementById('dataPoints').textContent = formatNumber(totalDataPoints);
        }

        function updateAnalytics() {
            if (watchlist.length === 0) return;
            let totalGainers = 0;
            let totalChange = 0;
            let volatilitySum = 0;
            let trendStrength = 0;
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) return;
                const daily = calculateChange(data, 1);
                const weekly = calculateChange(data, 7);
                if (daily) {
                    if (daily.percentChange > 0) totalGainers++;
                    totalChange += daily.percentChange;
                    volatilitySum += Math.abs(daily.percentChange);
                }
                if (weekly && daily) {
                    trendStrength += (Math.sign(weekly.percentChange) === Math.sign(daily.percentChange)) ? 1 : 0;
                }
            });
            const momentum = (totalGainers / watchlist.length * 100).toFixed(1) + '%';
            const avgVolatility = (volatilitySum / watchlist.length).toFixed(2) + '%';
            const trend = (trendStrength / watchlist.length * 100).toFixed(0) + '%';
            document.getElementById('marketMomentum').textContent = momentum;
            document.getElementById('volatilityIndex').textContent = avgVolatility;
            document.getElementById('trendStrength').textContent = trend;
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('dataFreshness').textContent = timeStr;
            updateHeatmap();
            if (currentView === 'correlation') {
                updateCorrelationMatrix();
            } else if (currentView === 'risk') {
                updateRiskAnalysis();
                updateRiskHistogram();
            }
        }

        function updateHeatmap() {
            const heatmapGrid = document.getElementById('heatmapGrid');
            heatmapGrid.innerHTML = '';
            const heatmapData = [];
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) return;
                const daily = calculateChange(data, 1);
                if (daily) {
                    heatmapData.push({
                        symbol: item.symbol,
                        name: item.name,
                        change: daily.percentChange
                    });
                }
            });
            heatmapData.sort((a, b) => b.change - a.change);
            heatmapData.forEach(item => {
                const cell = document.createElement('div');
                cell.className = 'heatmap-cell ' + getHeatmapClass(item.change);
                cell.innerHTML = `
                    <div class="heatmap-symbol">${item.symbol}</div>
                    <div class="heatmap-value">${formatPercent(item.change)}</div>
                `;
                cell.title = item.name;
                heatmapGrid.appendChild(cell);
            });
        }

        function getHeatmapClass(change) {
            if (change > 5) return 'heatmap-extreme-positive';
            if (change > 2) return 'heatmap-positive';
            if (change > 0.5) return 'heatmap-mild-positive';
            if (change > -0.5) return 'heatmap-neutral';
            if (change > -2) return 'heatmap-mild-negative';
            if (change > -5) return 'heatmap-negative';
            return 'heatmap-extreme-negative';
        }

        function calculateCorrelation(data1, data2) {
            const dates1 = data1.map(d => d.date.toISOString().split('T')[0]);
            const dates2 = data2.map(d => d.date.toISOString().split('T')[0]);
            const commonDates = dates1.filter(date => dates2.includes(date));
            if (commonDates.length < 10) return null;
            const values1 = [];
            const values2 = [];
            commonDates.forEach(date => {
                const v1 = data1.find(d => d.date.toISOString().split('T')[0] === date);
                const v2 = data2.find(d => d.date.toISOString().split('T')[0] === date);
                if (v1 && v2) {
                    values1.push(v1.value);
                    values2.push(v2.value);
                }
            });
            const changes1 = [];
            const changes2 = [];
            for (let i = 1; i < values1.length; i++) {
                if (values1[i-1] !== 0 && values2[i-1] !== 0) {
                    changes1.push((values1[i] - values1[i-1]) / values1[i-1] * 100);
                    changes2.push((values2[i] - values2[i-1]) / values2[i-1] * 100);
                }
            }
            if (changes1.length < 5) return null;
            const n = changes1.length;
            const sum1 = changes1.reduce((a, b) => a + b, 0);
            const sum2 = changes2.reduce((a, b) => a + b, 0);
            const sum1Sq = changes1.reduce((a, b) => a + b * b, 0);
            const sum2Sq = changes2.reduce((a, b) => a + b * b, 0);
            const pSum = changes1.reduce((a, b, i) => a + b * changes2[i], 0);
            const num = pSum - (sum1 * sum2 / n);
            const den = Math.sqrt((sum1Sq - sum1 * sum1 / n) * (sum2Sq - sum2 * sum2 / n));
            if (den === 0) return 0;
            return num / den;
        }

        function updateCorrelationMatrix() {
            const container = document.getElementById('correlationMatrix');
            if (watchlist.length < 2) {
                container.innerHTML = '<p style="text-align: center; color: #666;">Add at least 2 series to see correlations</p>';
                return;
            }
            let html = '<table class="correlation-table"><thead><tr><th></th>';
            watchlist.forEach(item => {
                html += `<th>${item.symbol}</th>`;
            });
            html += '</tr></thead><tbody>';
            const correlations = {};
            for (let i = 0; i < watchlist.length; i++) {
                html += `<tr><th>${watchlist[i].symbol}</th>`;
                for (let j = 0; j < watchlist.length; j++) {
                    if (i === j) {
                        html += '<td class="correlation-cell" style="background: #4a9eff; color: white;">1.00</td>';
                    } else {
                        const key = `${watchlist[i].symbol}-${watchlist[j].symbol}`;
                        const reverseKey = `${watchlist[j].symbol}-${watchlist[i].symbol}`;
                        let corr;
                        if (correlations[key] !== undefined) {
                            corr = correlations[key];
                        } else if (correlations[reverseKey] !== undefined) {
                            corr = correlations[reverseKey];
                        } else {
                            corr = calculateCorrelation(
                                seriesData[watchlist[i].symbol],
                                seriesData[watchlist[j].symbol]
                            );
                            correlations[key] = corr;
                        }
                        if (corr !== null) {
                            const color = getCorrelationColor(corr);
                            html += `<td class="correlation-cell" style="background: ${color}; color: white;">${corr.toFixed(2)}</td>`;
                        } else {
                            html += '<td class="correlation-cell" style="background: #333; color: #666;">N/A</td>';
                        }
                    }
                }
                html += '</tr>';
            }
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function getCorrelationColor(corr) {
            if (corr >= 0.7) return '#4caf50';
            if (corr >= 0.5) return '#66bb6a';
            if (corr >= 0.3) return '#81c784';
            if (corr >= 0.1) return '#a5d6a7';
            if (corr >= -0.1) return '#757575';
            if (corr >= -0.3) return '#ef9a9a';
            if (corr >= -0.5) return '#e57373';
            if (corr >= -0.7) return '#ef5350';
            return '#f44336';
        }

        function toggleView(view) {
            currentView = view;
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            document.getElementById('analyticsContent').style.display = 'none';
            document.getElementById('correlationContent').style.display = 'none';
            document.getElementById('riskContent').style.display = 'none';
            if (view === 'analytics') {
                document.getElementById('analyticsContent').style.display = 'block';
                updateAnalytics();
            } else if (view === 'correlation') {
                document.getElementById('correlationContent').style.display = 'block';
                updateCorrelationMatrix();
            } else if (view === 'risk') {
                document.getElementById('riskContent').style.display = 'block';
                updateRiskAnalysis();
                updateRiskHistogram();
            }
        }

        function toggleAutoRefresh() {
            const btn = event.target.closest('.watchlist-btn');
            const icon = document.getElementById('autoRefreshIcon');
            const text = document.getElementById('autoRefreshText');
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                btn.classList.remove('active');
                icon.textContent = '‚ñ∂Ô∏è';
                text.textContent = 'Auto Refresh';
            } else {
                autoRefreshInterval = setInterval(() => {
                    refreshAllData();
                }, 60000);
                btn.classList.add('active');
                icon.textContent = '‚è∏Ô∏è';
                text.textContent = 'Stop Auto';
                refreshAllData();
            }
        }

        async function refreshAllData() {
            const promises = watchlist.map(async item => {
                try {
                    const data = await fetchSeriesData(item.symbol);
                    if (data && data.length > 0) {
                        seriesData[item.symbol] = data;
                    }
                } catch (error) {
                    console.error(`Error refreshing ${item.symbol}:`, error);
                }
            });
            await Promise.all(promises);
            updateWatchlistDisplay();
            updateStats();
            updateAnalytics();
            updateRiskAnalysis();
            updateRiskHistogram();
        }

        function removeFromWatchlist(symbol) {
            watchlist = watchlist.filter(item => item.symbol !== symbol);
            delete seriesData[symbol];
            riskIndicators = riskIndicators.filter(ind => ind.symbol !== symbol);
            updateWatchlistDisplay();
            updateStats();
            updateAnalytics();
            updateRiskIndicators();
            updateRiskHistogram();
        }

        function clearWatchlist() {
            if (!confirm('Are you sure you want to clear your entire watchlist?')) return;
            watchlist = [];
            seriesData = {};
            riskIndicators = [];
            failedSeries.clear();
            document.getElementById('errorNote').style.display = 'none';
            updateWatchlistDisplay();
            updateStats();
            updateAnalytics();
            updateRiskIndicators();
            updateRiskHistogram();
        }

        function downloadWatchlist() {
            if (watchlist.length === 0) {
                alert('Your watchlist is empty. Add some series to download.');
                return;
            }
            let csv = 'Symbol,Name,Date,Value\n';
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length === 0) return;
                data.forEach(point => {
                    csv += `"${item.symbol}","${item.name.replace(/"/g, '""')}","${point.date.toISOString().split('T')[0]}",${point.value}\n`;
                });
            });
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `watchlist_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function updateRiskIndicators(symbol, name) {
            if (symbol && name && !riskIndicators.find(ind => ind.symbol === symbol)) {
                const data = seriesData[symbol];
                if (!data || data.length < 2) return;
                const daily = calculateChange(data, 1);
                const volatility = calculateVolatility(data);
                riskIndicators.push({
                    symbol,
                    name,
                    volatility: volatility.toFixed(2),
                    lastChange: daily ? daily.percentChange.toFixed(2) : '--'
                });
            }
            const container = document.getElementById('riskIndicatorsList');
            if (riskIndicators.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No risk indicators added</p>';
                return;
            }
            container.innerHTML = riskIndicators.map(ind => `
                <div class="risk-indicator-item">
                    <span class="indicator-name">${ind.name} (${ind.symbol})</span>
                    <div>
                        <span class="indicator-value ${getChangeClass(ind.lastChange)}">${ind.lastChange}%</span>
                        <span class="indicator-value">Vol: ${ind.volatility}%</span>
                        <button class="indicator-remove" onclick="removeRiskIndicator('${ind.symbol}')">Remove</button>
                    </div>
                </div>
            `).join('');
        }

        function removeRiskIndicator(symbol) {
            riskIndicators = riskIndicators.filter(ind => ind.symbol !== symbol);
            updateRiskIndicators();
            updateRiskHistogram();
        }

        function calculateVolatility(data) {
            if (!data || data.length < 2) return 0;
            const returns = [];
            for (let i = 1; i < data.length; i++) {
                if (data[i-1].value !== 0) {
                    returns.push((data[i].value - data[i-1].value) / data[i-1].value * 100);
                }
            }
            if (returns.length === 0) return 0;
            const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
            return Math.sqrt(variance);
        }

        function updateRiskAnalysis() {
            if (watchlist.length === 0) {
                document.getElementById('marketRiskScore').textContent = '--';
                document.getElementById('marketRiskLabel').textContent = '--';
                document.getElementById('volatilityPercentile').textContent = '--';
                document.getElementById('stressEvents').textContent = '--';
                return;
            }
            let totalVolatility = 0;
            let stressEvents = 0;
            let volatilities = [];
            watchlist.forEach(item => {
                const data = seriesData[item.symbol];
                if (!data || data.length < 2) return;
                const volatility = calculateVolatility(data);
                totalVolatility += volatility;
                volatilities.push(volatility);
                const daily = calculateChange(data, 1);
                if (daily && Math.abs(daily.percentChange) > 2) {
                    stressEvents++;
                }
            });
            const avgVolatility = totalVolatility / watchlist.length;
            const riskScore = Math.min(100, (avgVolatility * 10)).toFixed(0);
            let riskLabel = 'Low';
            if (riskScore > 80) riskLabel = 'Extreme';
            else if (riskScore > 60) riskLabel = 'High';
            else if (riskScore > 40) riskLabel = 'Moderate';
            document.getElementById('marketRiskScore').textContent = riskScore;
            document.getElementById('marketRiskLabel').textContent = riskLabel;
            document.getElementById('marketRiskLabel').className = `risk-label risk-${riskLabel.toLowerCase()}`;
            volatilities.sort((a, b) => a - b);
            const percentile = volatilities.length > 2 ? ((volatilities.indexOf(avgVolatility) + 1) / volatilities.length * 100).toFixed(0) : 50;
            document.getElementById('volatilityPercentile').textContent = `${percentile}%`;
            document.getElementById('stressEvents').textContent = stressEvents;
        }

        function updateRiskHistogram() {
            const metric = document.getElementById('histogramMetric').value;
            const data = [];
            watchlist.forEach(item => {
                const series = seriesData[item.symbol];
                if (!series || series.length < 2) return;
                if (metric === 'daily_change') {
                    const daily = calculateChange(series, 1);
                    if (daily) data.push(daily.percentChange);
                } else if (metric === 'volatility') {
                    data.push(calculateVolatility(series));
                } else if (metric === 'returns') {
                    const returns = [];
                    for (let i = 1; i < series.length; i++) {
                        if (series[i-1].value !== 0) {
                            returns.push((series[i].value - series[i-1].value) / series[i-1].value * 100);
                        }
                    }
                    data.push(...returns);
                }
            });
            if (data.length === 0) {
                document.getElementById('histogramContainer').innerHTML = '<p style="text-align: center; color: #666;">No data available for histogram</p>';
                return;
            }
            const bins = 20;
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min || 1;
            const binSize = range / bins;
            const histogramData = Array(bins).fill(0);
            data.forEach(value => {
                const binIndex = Math.min(bins - 1, Math.floor((value - min) / binSize));
                histogramData[binIndex]++;
            });
            const labels = Array.from({ length: bins }, (_, i) => {
                const start = (min + i * binSize).toFixed(2);
                const end = (min + (i + 1) * binSize).toFixed(2);
                return `${start} to ${end}`;
            });
            if (histogramChart) {
                histogramChart.destroy();
            }
            const ctx = document.getElementById('riskHistogram').getContext('2d');
            histogramChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: metric === 'daily_change' ? 'Daily % Change' : metric === 'volatility' ? 'Volatility' : 'Returns',
                        data: histogramData,
                        backgroundColor: '#4a9eff',
                        borderColor: '#3949ab',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#333'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: metric === 'daily_change' ? 'Daily % Change' : metric === 'volatility' ? 'Volatility (%)' : 'Returns (%)',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0',
                                autoSkip: true,
                                maxTicksLimit: 10
                            },
                            grid: {
                                color: '#333'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
            const legend = document.getElementById('histogramLegend');
            legend.innerHTML = `
                <div class="legend-item">
                    <span class="legend-color" style="background: #4a9eff;"></span>
                    <span>${metric === 'daily_change' ? 'Daily % Change' : metric === 'volatility' ? 'Volatility' : 'Returns'}</span>
                </div>
            `;
        }

        function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        // Initialize the application
        initializeCategories();
        updateRiskIndicators();
    </script>
</body>
</html>