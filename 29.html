<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBB Platform v9.0 - Advanced Analytics & Momentum Detection</title>
    
    <!-- Required Libraries -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #151932 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        /* Header Styles */
        .header {
            background: rgba(20, 24, 44, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .header-stats {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 1.25rem;
            font-weight: bold;
            color: #00ff88;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }
        
        /* Risk Level Indicator */
        .risk-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .risk-level {
            font-weight: bold;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
        }
        
        .risk-low {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .risk-medium {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
        }
        
        .risk-high {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }
        
        /* API Status Indicators */
        .api-status {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            flex-wrap: wrap;
        }
        
        .api-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #00ff88;
        }
        
        .status-dot.error {
            background: #ff4444;
        }
        
        .status-dot.loading {
            background: #ffaa00;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Container */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 0.5rem;
            overflow-x: auto;
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: #888;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }
        
        .tab-btn.active {
            background: #00ff88;
            color: #000;
            font-weight: bold;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Key Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
        }
        
        .metric-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.1);
        }
        
        .metric-title {
            font-size: 0.875rem;
            color: #888;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            cursor: text;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s;
            display: inline-block;
        }
        
        .metric-title:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .metric-title.editing {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .metric-value {
            font-size: 1.75rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .metric-change {
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .positive { color: #00ff88; }
        .negative { color: #ff4444; }
        .neutral { color: #888; }
        
        /* Enhanced Heatmap Styles */
        .heatmap-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .heatmap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .heatmap-title {
            font-size: 1.25rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .heatmap-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .heatmap-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.3s;
        }
        
        .heatmap-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }
        
        .heatmap-btn.active {
            background: #00ff88;
            color: #000;
            font-weight: bold;
        }
        
        .heatmap-grid {
            display: grid;
            grid-template-columns: minmax(200px, 1.5fr) repeat(5, minmax(100px, 1fr));
            gap: 2px;
            background: rgba(255, 255, 255, 0.05);
            padding: 2px;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        .heatmap-cell {
            padding: 1rem;
            text-align: center;
            font-size: 0.875rem;
            transition: all 0.3s;
            border-radius: 4px;
            position: relative;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .heatmap-cell.header {
            background: rgba(0, 255, 136, 0.1);
            font-weight: bold;
            color: #00ff88;
            text-transform: uppercase;
            font-size: 0.75rem;
        }
        
        .heatmap-cell.indicator-name {
            background: rgba(255, 255, 255, 0.08);
            font-weight: bold;
            text-align: left;
            padding-left: 1.5rem;
            color: #fff;
            cursor: pointer;
            position: relative;
        }
        
        .heatmap-cell.indicator-name:hover {
            background: rgba(0, 255, 136, 0.15);
        }
        
        .indicator-name-text {
            cursor: text;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        .indicator-name-text:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .indicator-name-text.editing {
            background: rgba(0, 255, 136, 0.3);
            outline: 2px solid #00ff88;
        }
        
        .heatmap-value {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }
        
        .heatmap-label {
            font-size: 0.65rem;
            opacity: 0.8;
            text-transform: uppercase;
        }
        
        /* Momentum Indicator */
        .momentum-indicator {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 0.5rem;
            overflow: hidden;
        }
        
        .momentum-bar {
            height: 100%;
            transition: width 0.5s ease, background 0.5s ease;
        }
        
        .momentum-strong-bullish {
            background: linear-gradient(90deg, #00ff44, #00cc33);
        }
        
        .momentum-bullish {
            background: linear-gradient(90deg, #44ff44, #00ff44);
        }
        
        .momentum-neutral {
            background: #888;
        }
        
        .momentum-bearish {
            background: linear-gradient(90deg, #ff4444, #ff6666);
        }
        
        .momentum-strong-bearish {
            background: linear-gradient(90deg, #cc0000, #ff4444);
        }
        
        /* Heatmap color gradients */
        .heat-extreme-negative {
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #fff;
        }
        
        .heat-high-negative {
            background: linear-gradient(135deg, #DC143C, #FF4444);
            color: #fff;
        }
        
        .heat-moderate-negative {
            background: linear-gradient(135deg, #FF4444, #FF6666);
            color: #fff;
        }
        
        .heat-low-negative {
            background: linear-gradient(135deg, #FF6666, #FF8888);
            color: #fff;
        }
        
        .heat-neutral {
            background: rgba(255, 255, 255, 0.05);
            color: #888;
        }
        
        .heat-low-positive {
            background: linear-gradient(135deg, #88FF88, #66FF66);
            color: #000;
        }
        
        .heat-moderate-positive {
            background: linear-gradient(135deg, #66FF66, #44FF44);
            color: #000;
        }
        
        .heat-high-positive {
            background: linear-gradient(135deg, #44FF44, #00FF44);
            color: #000;
        }
        
        .heat-extreme-positive {
            background: linear-gradient(135deg, #00FF44, #00CC33);
            color: #000;
        }
        
        .heatmap-cell:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }
        
        /* Chart Container */
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .chart-title {
            font-size: 1.25rem;
            font-weight: bold;
            color: #fff;
        }
        
        .chart-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .chart-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.3s;
        }
        
        .chart-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }
        
        .chart-btn.active {
            background: #00ff88;
            color: #000;
            font-weight: bold;
        }
        
        /* Advanced Analytics Panel */
        .analytics-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .analytics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .analytics-title {
            font-size: 1.125rem;
            font-weight: bold;
            color: #fff;
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }
        
        .analytics-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .analytics-label {
            font-size: 0.875rem;
            color: #888;
            margin-bottom: 0.5rem;
        }
        
        .analytics-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .trend-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }
        
        .trend-arrow {
            font-size: 1.25rem;
        }
        
        /* Momentum Signal */
        .momentum-signal {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-left: 0.5rem;
        }
        
        .signal-bullish {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .signal-bearish {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }
        
        .signal-neutral {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        
        /* Data Grid */
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .data-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }
        
        .data-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.1);
        }
        
        /* Market Phase Banner */
        .market-phase-banner {
            background: linear-gradient(90deg, #00ff88, #00ccff);
            color: #000;
            padding: 12px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem;
            animation: phaseGlow 2s ease-in-out infinite;
            position: sticky;
            top: 80px;
            z-index: 999;
        }
        
        @keyframes phaseGlow {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
        
        /* Loading Spinner */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .heatmap-grid {
                grid-template-columns: minmax(120px, 1fr) repeat(5, minmax(80px, 1fr));
                font-size: 0.75rem;
            }
            
            .heatmap-cell {
                padding: 0.5rem;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Market Phase Banner -->
    <div class="market-phase-banner" id="marketPhaseBanner">
        📈 MARKET STATUS: ANALYZING...
    </div>
    
    <header class="header">
        <div class="logo">
            📊 OpenBB Platform
            <span style="font-size: 0.875rem; color: #888;">v9.0 Advanced Analytics</span>
        </div>
        
        <div class="header-stats">
            <div class="stat-item">
                <div class="stat-value" id="activeIndicators">143</div>
                <div class="stat-label">Active Indicators</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="momentumScore">0</div>
                <div class="stat-label">Momentum Score</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="trendStrength">0%</div>
                <div class="stat-label">Trend Strength</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="volatilityRank">0</div>
                <div class="stat-label">Volatility Rank</div>
            </div>
        </div>
        
        <div class="risk-indicator">
            <span>Risk Level:</span>
            <span class="risk-level risk-low" id="riskLevel">CALCULATING...</span>
        </div>
        
        <div class="api-status">
            <div class="api-indicator">
                <div class="status-dot loading" id="mainApiStatus"></div>
                <span>Main API</span>
            </div>
            <div class="api-indicator">
                <div class="status-dot loading" id="mlStatus"></div>
                <span>Analytics</span>
            </div>
            <div class="api-indicator">
                <div class="status-dot loading" id="alertsStatus"></div>
                <span>Alerts</span>
            </div>
        </div>
    </header>
    
    <div class="container">
        <!-- Navigation Tabs -->
        <div class="tabs-nav">
            <button class="tab-btn active" data-tab="overview">📈 Overview</button>
            <button class="tab-btn" data-tab="heatmap">🔥 Advanced Heatmap</button>
            <button class="tab-btn" data-tab="momentum">⚡ Momentum Analysis</button>
            <button class="tab-btn" data-tab="trends">📊 Trend Detection</button>
            <button class="tab-btn" data-tab="fed">🏛️ Federal Reserve</button>
            <button class="tab-btn" data-tab="blackswan">🦢 Black Swan</button>
            <button class="tab-btn" data-tab="liquidity">💧 Liquidity</button>
        </div>
        
        <!-- Overview Tab -->
        <div class="tab-content active" id="overview">
            <!-- Advanced Analytics Panel -->
            <div class="analytics-panel">
                <div class="analytics-header">
                    <h2 class="analytics-title">🎯 Early Warning System</h2>
                    <span id="lastUpdate" style="font-size: 0.875rem; color: #888;">Last Update: --</span>
                </div>
                <div class="analytics-grid" id="analyticsGrid">
                    <!-- Analytics cards will be populated here -->
                </div>
            </div>
            
            <!-- Key Metrics - Will be populated dynamically -->
            <div class="metrics-grid" id="keyMetrics">
                <!-- Metrics will be added here dynamically -->
            </div>
            
            <!-- Enhanced Main Chart -->
            <div class="chart-container">
                <div class="chart-header">
                    <h2 class="chart-title">Advanced Market Overview</h2>
                    <div class="chart-controls">
                        <button class="chart-btn active" data-view="combined">Combined</button>
                        <button class="chart-btn" data-view="momentum">Momentum</button>
                        <button class="chart-btn" data-view="volatility">Volatility</button>
                        <button class="chart-btn" data-view="correlation">Correlation</button>
                        <button class="chart-btn" data-view="divergence">Divergence</button>
                    </div>
                </div>
                <div id="mainChart" style="height: 500px;"></div>
            </div>
            
            <!-- Dashboard Data Grid -->
            <div class="data-grid" id="overviewGrid">
                <div class="loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Heatmap Tab -->
        <div class="tab-content" id="heatmap">
            <div class="heatmap-container">
                <div class="heatmap-header">
                    <h2 class="heatmap-title">🔥 Enhanced Real-Time Heatmap</h2>
                    <div class="heatmap-controls">
                        <button class="heatmap-btn active" onclick="updateHeatmapView('all')">All</button>
                        <button class="heatmap-btn" onclick="updateHeatmapView('macro')">Macro</button>
                        <button class="heatmap-btn" onclick="updateHeatmapView('risk')">Risk</button>
                        <button class="heatmap-btn" onclick="updateHeatmapView('liquidity')">Liquidity</button>
                        <button class="heatmap-btn" onclick="updateHeatmapView('momentum')">Momentum</button>
                        <button class="heatmap-btn" onclick="toggleHeatmapSort()">Sort ↕</button>
                    </div>
                </div>
                
                <div class="heatmap-grid" id="heatmapGrid">
                    <div class="heatmap-cell header">Indicator</div>
                    <div class="heatmap-cell header">Current</div>
                    <div class="heatmap-cell header">1D %</div>
                    <div class="heatmap-cell header">1W %</div>
                    <div class="heatmap-cell header">1M %</div>
                    <div class="heatmap-cell header">Momentum</div>
                </div>
            </div>
        </div>
        
        <!-- Momentum Analysis Tab -->
        <div class="tab-content" id="momentum">
            <div class="chart-container">
                <div class="chart-header">
                    <h2 class="chart-title">⚡ Advanced Momentum Analysis</h2>
                </div>
                <div id="momentumChart" style="height: 500px;"></div>
            </div>
            
            <div class="analytics-panel">
                <h2 class="analytics-title">Momentum Signals</h2>
                <div id="momentumSignals" class="analytics-grid">
                    <!-- Momentum signals will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Trend Detection Tab -->
        <div class="tab-content" id="trends">
            <div class="chart-container">
                <div class="chart-header">
                    <h2 class="chart-title">📊 Early Trend Detection System</h2>
                </div>
                <div id="trendChart" style="height: 500px;"></div>
            </div>
            
            <div class="analytics-panel">
                <h2 class="analytics-title">Trend Breakout Candidates</h2>
                <div id="trendCandidates" class="data-grid">
                    <!-- Trend candidates will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Other tabs content continues... -->
        <div class="tab-content" id="fed">
            <div class="chart-container">
                <div id="fedChart" style="height: 500px;"></div>
            </div>
            <div class="data-grid" id="fedGrid">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </div>
        
        <div class="tab-content" id="blackswan">
            <div class="chart-container">
                <div id="blackSwanChart" style="height: 500px;"></div>
            </div>
            <div class="data-grid" id="blackSwanGrid">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </div>
        
        <div class="tab-content" id="liquidity">
            <div class="chart-container">
                <div id="liquidityChart" style="height: 500px;"></div>
            </div>
            <div class="data-grid" id="liquidityGrid">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </div>
    </div>
    
    <script>
        // Enhanced OpenBB Platform Configuration v9.0
        const OPENBB_CONFIG = {
            MAIN_API: {
                baseUrl: 'https://i70jxru6md.execute-api.us-east-1.amazonaws.com/prod/api/v1',
                endpoints: {
                    health: '/health',
                    overview: '/dashboard/overview',
                    mega: '/dashboard/mega',
                    dxy: '/dxy',
                    ice_bofa: '/ice_bofa',
                    fed: '/fed',
                    blackswan: '/blackswan',
                    liquidity: '/liquidity',
                    crisis: '/crisis'
                }
            }
        };
        
        // Enhanced Global State with Advanced Analytics
        let currentData = {
            overview: {},
            fed: {},
            blackswan: {},
            liquidity: {},
            heatmapData: {},
            historicalData: {},
            customNames: {},
            momentumScores: {},
            trendIndicators: {},
            volatilityMetrics: {},
            correlationMatrix: {},
            divergenceSignals: [],
            earlyWarnings: [],
            sortOrder: 'value', // 'value', 'change', 'momentum'
            currentHeatmapView: 'all'
        };
        
        let charts = {
            main: null,
            momentum: null,
            trend: null,
            fed: null,
            blackswan: null,
            liquidity: null
        };
        
        let activeTab = 'overview';
        let currentChartView = 'combined';
        let autoRefreshInterval = null;
        let heatmapStabilityBuffer = [];
        
        // Initialize Enhanced Platform
        async function initializePlatform() {
            console.log('🚀 Initializing OpenBB Platform v9.0 with Advanced Analytics...');
            
            // Load saved customizations
            loadCustomNames();
            
            // Test API connections
            await testAPIConnections();
            
            // Load initial data
            await loadAllData();
            
            // Initialize advanced analytics
            initializeAdvancedAnalytics();
            
            // Set up event listeners
            setupEventListeners();
            
            // Initialize enhanced charts
            initializeEnhancedCharts();
            
            // Start auto-refresh with stability buffer
            startStableAutoRefresh();
            
            console.log('✅ Platform initialized with advanced features');
        }
        
        // Load custom indicator names from localStorage
        function loadCustomNames() {
            const saved = localStorage.getItem('customIndicatorNames');
            if (saved) {
                currentData.customNames = JSON.parse(saved);
            }
        }
        
        // Save custom indicator names
        function saveCustomNames() {
            localStorage.setItem('customIndicatorNames', JSON.stringify(currentData.customNames));
        }
        
        // Make indicator names editable
        function makeIndicatorNameEditable(element, key) {
            element.contentEditable = true;
            element.classList.add('editing');
            
            const originalText = element.textContent;
            
            element.addEventListener('blur', function() {
                element.contentEditable = false;
                element.classList.remove('editing');
                
                const newName = element.textContent.trim();
                if (newName && newName !== originalText) {
                    currentData.customNames[key] = newName;
                    saveCustomNames();
                    // Update all instances of this indicator name
                    updateIndicatorNamesGlobally(key, newName);
                }
            });
            
            element.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    element.blur();
                }
            });
        }
        
        // Update indicator names globally
        function updateIndicatorNamesGlobally(key, newName) {
            // Update in metrics
            document.querySelectorAll(`[data-indicator-key="${key}"]`).forEach(el => {
                const nameEl = el.querySelector('.metric-title, .indicator-name-text');
                if (nameEl) nameEl.textContent = newName;
            });
        }
        
        // Enhanced Analytics Functions
        function calculateMomentumScore(currentValue, historicalValues) {
            if (!historicalValues || historicalValues.length < 5) return 0;
            
            // Calculate rate of change over different periods
            const roc1 = ((currentValue - historicalValues[historicalValues.length - 2]) / historicalValues[historicalValues.length - 2]) * 100;
            const roc5 = ((currentValue - historicalValues[historicalValues.length - 6]) / historicalValues[historicalValues.length - 6]) * 100;
            const roc10 = historicalValues.length > 10 ? ((currentValue - historicalValues[historicalValues.length - 11]) / historicalValues[historicalValues.length - 11]) * 100 : roc5;
            
            // Calculate momentum score (weighted average)
            const momentum = (roc1 * 0.5 + roc5 * 0.3 + roc10 * 0.2);
            
            // Normalize to -100 to +100 scale
            return Math.max(-100, Math.min(100, momentum));
        }
        
        function detectTrendReversal(values) {
            if (!values || values.length < 20) return null;
            
            // Calculate moving averages
            const ma5 = calculateMA(values, 5);
            const ma20 = calculateMA(values, 20);
            
            // Check for crossovers
            const recentMA5 = ma5.slice(-2);
            const recentMA20 = ma20.slice(-2);
            
            if (recentMA5[0] < recentMA20[0] && recentMA5[1] > recentMA20[1]) {
                return { type: 'bullish', strength: 'strong' };
            } else if (recentMA5[0] > recentMA20[0] && recentMA5[1] < recentMA20[1]) {
                return { type: 'bearish', strength: 'strong' };
            }
            
            return null;
        }
        
        function calculateMA(values, period) {
            const ma = [];
            for (let i = period - 1; i < values.length; i++) {
                const sum = values.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                ma.push(sum / period);
            }
            return ma;
        }
        
        function calculateVolatilityRank(values) {
            if (!values || values.length < 10) return 50;
            
            // Calculate standard deviation
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
            const stdDev = Math.sqrt(variance);
            
            // Calculate coefficient of variation
            const cv = (stdDev / Math.abs(mean)) * 100;
            
            // Rank on scale of 1-100
            return Math.min(100, Math.max(1, cv * 2));
        }
        
        function detectDivergence(price, indicator) {
            if (!price || !indicator || price.length < 10) return null;
            
            // Find recent peaks and troughs
            const pricePeaks = findPeaks(price);
            const indicatorPeaks = findPeaks(indicator);
            
            // Check for divergence
            if (pricePeaks.higher && !indicatorPeaks.higher) {
                return { type: 'bearish', strength: 'moderate' };
            } else if (!pricePeaks.higher && indicatorPeaks.higher) {
                return { type: 'bullish', strength: 'moderate' };
            }
            
            return null;
        }
        
        function findPeaks(values) {
            const recent = values.slice(-10);
            const max = Math.max(...recent);
            const maxIndex = recent.indexOf(max);
            const previousMax = Math.max(...recent.slice(0, maxIndex));
            
            return {
                higher: max > previousMax,
                value: max,
                index: maxIndex
            };
        }
        
        // Initialize Advanced Analytics
        async function initializeAdvancedAnalytics() {
            // Calculate momentum scores for all indicators
            for (const [key, data] of Object.entries(currentData.overview.indicators || {})) {
                if (data && data.value) {
                    // Generate historical data (in production, fetch from API)
                    const historical = generateHistoricalData(data.value, 30);
                    currentData.historicalData[key] = historical;
                    
                    // Calculate momentum
                    currentData.momentumScores[key] = calculateMomentumScore(data.value, historical);
                    
                    // Detect trend reversals
                    const reversal = detectTrendReversal(historical);
                    if (reversal) {
                        currentData.earlyWarnings.push({
                            indicator: key,
                            signal: reversal,
                            timestamp: new Date()
                        });
                    }
                    
                    // Calculate volatility
                    currentData.volatilityMetrics[key] = calculateVolatilityRank(historical);
                }
            }
            
            updateAnalyticsDisplay();
        }
        
        // Update Analytics Display
        function updateAnalyticsDisplay() {
            const grid = document.getElementById('analyticsGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Overall Momentum Score
            const avgMomentum = Object.values(currentData.momentumScores).reduce((a, b) => a + b, 0) / Object.values(currentData.momentumScores).length;
            document.getElementById('momentumScore').textContent = avgMomentum.toFixed(0);
            
            // Trend Strength
            const trendStrength = Math.abs(avgMomentum);
            document.getElementById('trendStrength').textContent = trendStrength.toFixed(0) + '%';
            
            // Volatility Rank
            const avgVolatility = Object.values(currentData.volatilityMetrics).reduce((a, b) => a + b, 0) / Object.values(currentData.volatilityMetrics).length;
            document.getElementById('volatilityRank').textContent = avgVolatility.toFixed(0);
            
            // Create analytics cards
            const analyticsData = [
                {
                    label: 'Market Momentum',
                    value: avgMomentum.toFixed(1),
                    trend: avgMomentum > 0 ? 'bullish' : avgMomentum < 0 ? 'bearish' : 'neutral',
                    description: getMomentumDescription(avgMomentum)
                },
                {
                    label: 'Trend Reversals Detected',
                    value: currentData.earlyWarnings.length,
                    trend: currentData.earlyWarnings.length > 3 ? 'bearish' : 'neutral',
                    description: `${currentData.earlyWarnings.length} potential reversals`
                },
                {
                    label: 'Volatility Percentile',
                    value: avgVolatility.toFixed(0) + '%',
                    trend: avgVolatility > 70 ? 'bearish' : avgVolatility < 30 ? 'bullish' : 'neutral',
                    description: getVolatilityDescription(avgVolatility)
                },
                {
                    label: 'Risk Score',
                    value: calculateRiskScore().toFixed(0),
                    trend: calculateRiskScore() > 70 ? 'bearish' : calculateRiskScore() < 30 ? 'bullish' : 'neutral',
                    description: getRiskDescription(calculateRiskScore())
                }
            ];
            
            analyticsData.forEach(item => {
                const card = document.createElement('div');
                card.className = 'analytics-card';
                card.innerHTML = `
                    <div class="analytics-label">${item.label}</div>
                    <div class="analytics-value ${item.trend === 'bullish' ? 'positive' : item.trend === 'bearish' ? 'negative' : 'neutral'}">
                        ${item.value}
                        <span class="momentum-signal signal-${item.trend}">${item.trend.toUpperCase()}</span>
                    </div>
                    <div class="trend-indicator">
                        <span class="trend-arrow">${item.trend === 'bullish' ? '↑' : item.trend === 'bearish' ? '↓' : '→'}</span>
                        <span>${item.description}</span>
                    </div>
                `;
                grid.appendChild(card);
            });
        }
        
        function getMomentumDescription(momentum) {
            if (momentum > 50) return 'Strong upward momentum';
            if (momentum > 20) return 'Moderate upward momentum';
            if (momentum > 0) return 'Weak upward momentum';
            if (momentum > -20) return 'Weak downward momentum';
            if (momentum > -50) return 'Moderate downward momentum';
            return 'Strong downward momentum';
        }
        
        function getVolatilityDescription(volatility) {
            if (volatility > 80) return 'Extreme volatility';
            if (volatility > 60) return 'High volatility';
            if (volatility > 40) return 'Moderate volatility';
            if (volatility > 20) return 'Low volatility';
            return 'Very low volatility';
        }
        
        function getRiskDescription(risk) {
            if (risk > 80) return 'Very high risk';
            if (risk > 60) return 'High risk';
            if (risk > 40) return 'Moderate risk';
            if (risk > 20) return 'Low risk';
            return 'Very low risk';
        }
        
        function calculateRiskScore() {
            const vix = currentData.overview.indicators?.VIXCLS?.value || 20;
            const tedSpread = currentData.overview.indicators?.TEDRATE?.value || 0.3;
            const volatility = Object.values(currentData.volatilityMetrics).reduce((a, b) => a + b, 0) / Object.values(currentData.volatilityMetrics).length || 50;
            
            // Weighted risk score
            const riskScore = (vix * 0.4) + (tedSpread * 100 * 0.3) + (volatility * 0.3);
            return Math.min(100, Math.max(0, riskScore));
        }
        
        // Enhanced Heatmap with Stability
        async function loadStableHeatmapData() {
            try {
                const [overviewData, fedData, blackswanData, liquidityData] = await Promise.all([
                    fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.overview).then(r => r.json()),
                    fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.fed).then(r => r.json()),
                    fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.blackswan).then(r => r.json()),
                    fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.liquidity).then(r => r.json())
                ]);
                
                const allIndicators = {
                    ...overviewData.indicators,
                    ...fedData.indicators,
                    ...blackswanData.indicators,
                    ...liquidityData.indicators
                };
                
                // Apply stability buffer (smooth out rapid changes)
                const stabilizedData = applyStabilityBuffer(allIndicators);
                
                // Calculate enhanced metrics
                const heatmapData = calculateEnhancedHeatmapData(stabilizedData);
                
                currentData.heatmapData = heatmapData;
                updateEnhancedHeatmapDisplay(heatmapData);
                
            } catch (error) {
                console.error('Error loading heatmap data:', error);
            }
        }
        
        function applyStabilityBuffer(indicators) {
            // Add new data to buffer
            heatmapStabilityBuffer.push(indicators);
            
            // Keep only last 3 readings
            if (heatmapStabilityBuffer.length > 3) {
                heatmapStabilityBuffer.shift();
            }
            
            // If we don't have enough data, return as-is
            if (heatmapStabilityBuffer.length < 2) {
                return indicators;
            }
            
            // Average the values for stability
            const stabilized = {};
            for (const key in indicators) {
                const values = heatmapStabilityBuffer.map(buffer => buffer[key]?.value).filter(v => v !== undefined);
                if (values.length > 0) {
                    stabilized[key] = {
                        ...indicators[key],
                        value: values.reduce((a, b) => a + b, 0) / values.length,
                        stabilized: true
                    };
                }
            }
            
            return stabilized;
        }
        
        function calculateEnhancedHeatmapData(indicators) {
            const heatmapData = {};
            
            for (const [key, data] of Object.entries(indicators)) {
                if (!data || data.value === null || data.value === undefined) continue;
                
                const currentValue = parseFloat(data.value);
                const historical = currentData.historicalData[key] || generateHistoricalData(currentValue, 30);
                
                // Calculate more accurate percentage changes
                const dayAgo = historical[historical.length - 2] || currentValue;
                const weekAgo = historical[historical.length - 8] || currentValue;
                const monthAgo = historical[0] || currentValue;
                
                const dayChange = ((currentValue - dayAgo) / dayAgo) * 100;
                const weekChange = ((currentValue - weekAgo) / weekAgo) * 100;
                const monthChange = ((currentValue - monthAgo) / monthAgo) * 100;
                
                // Calculate momentum
                const momentum = calculateMomentumScore(currentValue, historical);
                
                heatmapData[key] = {
                    name: currentData.customNames[key] || getIndicatorDisplayName(key),
                    currentValue: currentValue,
                    dayChange: dayChange,
                    weekChange: weekChange,
                    monthChange: monthChange,
                    momentum: momentum,
                    category: categorizeIndicator(key),
                    volatility: calculateVolatilityRank(historical),
                    trend: momentum > 20 ? 'bullish' : momentum < -20 ? 'bearish' : 'neutral'
                };
            }
            
            return heatmapData;
        }
        
        function updateEnhancedHeatmapDisplay(heatmapData) {
            const grid = document.getElementById('heatmapGrid');
            if (!grid) return;
            
            // Keep headers
            const headers = grid.querySelectorAll('.header');
            grid.innerHTML = '';
            headers.forEach(header => grid.appendChild(header));
            
            // Filter and sort data
            let filteredData = filterHeatmapData(heatmapData);
            let sortedEntries = sortHeatmapData(filteredData);
            
            // Display rows
            sortedEntries.forEach(([key, data]) => {
                // Indicator name (editable)
                const nameCell = document.createElement('div');
                nameCell.className = 'heatmap-cell indicator-name';
                nameCell.dataset.indicatorKey = key;
                nameCell.innerHTML = `
                    <span class="indicator-name-text" onclick="makeIndicatorNameEditable(this, '${key}')">${data.name}</span>
                `;
                grid.appendChild(nameCell);
                
                // Current value
                const valueCell = document.createElement('div');
                valueCell.className = 'heatmap-cell';
                valueCell.innerHTML = `<div class="heatmap-value">${formatValue(data.currentValue, key)}</div>`;
                grid.appendChild(valueCell);
                
                // Day change
                grid.appendChild(createEnhancedHeatmapCell(data.dayChange, '1D'));
                
                // Week change
                grid.appendChild(createEnhancedHeatmapCell(data.weekChange, '1W'));
                
                // Month change
                grid.appendChild(createEnhancedHeatmapCell(data.monthChange, '1M'));
                
                // Momentum indicator
                const momentumCell = document.createElement('div');
                momentumCell.className = 'heatmap-cell';
                momentumCell.innerHTML = `
                    <div class="momentum-indicator">
                        <div class="momentum-bar momentum-${getMomentumClass(data.momentum)}" 
                             style="width: ${Math.abs(data.momentum)}%"></div>
                    </div>
                    <div class="heatmap-label">${data.momentum.toFixed(0)}</div>
                `;
                grid.appendChild(momentumCell);
            });
        }
        
        function filterHeatmapData(data) {
            if (currentData.currentHeatmapView === 'all') {
                return data;
            }
            
            if (currentData.currentHeatmapView === 'momentum') {
                // Show only high momentum indicators
                return Object.fromEntries(
                    Object.entries(data).filter(([_, d]) => Math.abs(d.momentum) > 30)
                );
            }
            
            return Object.fromEntries(
                Object.entries(data).filter(([_, d]) => d.category === currentData.currentHeatmapView)
            );
        }
        
        function sortHeatmapData(data) {
            const entries = Object.entries(data);
            
            switch (currentData.sortOrder) {
                case 'change':
                    return entries.sort((a, b) => Math.abs(b[1].monthChange) - Math.abs(a[1].monthChange));
                case 'momentum':
                    return entries.sort((a, b) => Math.abs(b[1].momentum) - Math.abs(a[1].momentum));
                case 'value':
                default:
                    return entries.sort((a, b) => Math.abs(b[1].currentValue) - Math.abs(a[1].currentValue));
            }
        }
        
        function toggleHeatmapSort() {
            const orders = ['value', 'change', 'momentum'];
            const currentIndex = orders.indexOf(currentData.sortOrder);
            currentData.sortOrder = orders[(currentIndex + 1) % orders.length];
            updateEnhancedHeatmapDisplay(currentData.heatmapData);
        }
        
        function createEnhancedHeatmapCell(value, label) {
            const cell = document.createElement('div');
            cell.className = `heatmap-cell ${getHeatmapColorClass(value)}`;
            
            const formattedValue = value !== null && value !== undefined ? 
                `${value >= 0 ? '+' : ''}${value.toFixed(2)}%` : 'N/A';
            
            cell.innerHTML = `
                <div class="heatmap-value">${formattedValue}</div>
                <div class="heatmap-label">${label}</div>
            `;
            
            return cell;
        }
        
        function getMomentumClass(momentum) {
            if (momentum > 50) return 'strong-bullish';
            if (momentum > 20) return 'bullish';
            if (momentum < -50) return 'strong-bearish';
            if (momentum < -20) return 'bearish';
            return 'neutral';
        }
        
        function getHeatmapColorClass(value) {
            if (value === null || value === undefined) return 'heat-neutral';
            
            if (value < -10) return 'heat-extreme-negative';
            if (value < -5) return 'heat-high-negative';
            if (value < -2) return 'heat-moderate-negative';
            if (value < 0) return 'heat-low-negative';
            if (value < 2) return 'heat-neutral';
            if (value < 5) return 'heat-moderate-positive';
            if (value < 10) return 'heat-high-positive';
            return 'heat-extreme-positive';
        }
        
        // Enhanced Chart Functions
        function initializeEnhancedCharts() {
            const darkTheme = {
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                plot_bgcolor: 'rgba(0, 0, 0, 0.3)',
                font: { color: '#fff' },
                xaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' }
                },
                yaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' }
                },
                showlegend: true,
                legend: {
                    orientation: 'h',
                    y: -0.15,
                    bgcolor: 'rgba(0, 0, 0, 0.5)'
                }
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d']
            };
            
            // Initialize main chart with multiple traces
            Plotly.newPlot('mainChart', [], darkTheme, config);
            
            // Initialize momentum chart
            if (document.getElementById('momentumChart')) {
                Plotly.newPlot('momentumChart', [], darkTheme, config);
            }
            
            // Initialize trend chart
            if (document.getElementById('trendChart')) {
                Plotly.newPlot('trendChart', [], darkTheme, config);
            }
        }
        
        async function updateEnhancedMainChart(view = 'combined') {
            const indicators = currentData.overview.indicators || {};
            const traces = [];
            
            switch(view) {
                case 'combined':
                    // VIX with Bollinger Bands
                    if (indicators.VIXCLS) {
                        const vixData = generateHistoricalData(indicators.VIXCLS.value, 90);
                        const dates = generateDateRange(90);
                        const ma20 = calculateMA(vixData, 20);
                        const stdDev = calculateStandardDeviation(vixData.slice(-20));
                        
                        traces.push({
                            x: dates,
                            y: vixData,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'VIX',
                            line: { color: '#00ff88', width: 2 }
                        });
                        
                        // Upper Bollinger Band
                        traces.push({
                            x: dates.slice(-ma20.length),
                            y: ma20.map(v => v + 2 * stdDev),
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Upper BB',
                            line: { color: 'rgba(255, 68, 68, 0.5)', dash: 'dash' }
                        });
                        
                        // Lower Bollinger Band
                        traces.push({
                            x: dates.slice(-ma20.length),
                            y: ma20.map(v => v - 2 * stdDev),
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Lower BB',
                            line: { color: 'rgba(0, 255, 136, 0.5)', dash: 'dash' }
                        });
                    }
                    break;
                    
                case 'momentum':
                    // Momentum oscillator
                    const momentumValues = [];
                    const momentumDates = generateDateRange(30);
                    
                    for (const [key, score] of Object.entries(currentData.momentumScores)) {
                        if (key === 'VIXCLS' || key === 'SP500' || key === 'DTWEXBGS') {
                            traces.push({
                                x: momentumDates,
                                y: generateRandomWalk(score, 5, 30),
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: `${currentData.customNames[key] || key} Momentum`,
                                line: { width: 2 }
                            });
                        }
                    }
                    break;
                    
                case 'volatility':
                    // Volatility cone
                    const volData = Object.entries(currentData.volatilityMetrics)
                        .slice(0, 20)
                        .map(([key, vol]) => ({
                            name: currentData.customNames[key] || key,
                            volatility: vol
                        }));
                    
                    traces.push({
                        x: volData.map(d => d.name),
                        y: volData.map(d => d.volatility),
                        type: 'bar',
                        marker: {
                            color: volData.map(d => 
                                d.volatility > 70 ? '#ff4444' : 
                                d.volatility > 40 ? '#ffaa00' : '#00ff88'
                            )
                        },
                        name: 'Volatility Rank'
                    });
                    break;
                    
                case 'correlation':
                    // Correlation heatmap
                    const corrMatrix = calculateCorrelationMatrix();
                    traces.push({
                        z: corrMatrix.values,
                        x: corrMatrix.labels,
                        y: corrMatrix.labels,
                        type: 'heatmap',
                        colorscale: 'RdBu',
                        reversescale: true
                    });
                    break;
                    
                case 'divergence':
                    // Show divergence signals
                    if (indicators.VIXCLS && indicators.SP500) {
                        const dates = generateDateRange(60);
                        const vixData = generateHistoricalData(indicators.VIXCLS.value, 60);
                        const spxData = generateHistoricalData(indicators.SP500.value, 60);
                        
                        // Normalize for comparison
                        const vixNorm = normalizeData(vixData);
                        const spxNorm = normalizeData(spxData);
                        
                        traces.push({
                            x: dates,
                            y: vixNorm,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'VIX (normalized)',
                            line: { color: '#ff4444', width: 2 }
                        });
                        
                        traces.push({
                            x: dates,
                            y: spxNorm,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'S&P 500 (normalized)',
                            line: { color: '#00ff88', width: 2 },
                            yaxis: 'y2'
                        });
                        
                        // Highlight divergences
                        const divergencePoints = detectDivergencePoints(vixNorm, spxNorm);
                        if (divergencePoints.length > 0) {
                            traces.push({
                                x: divergencePoints.map(p => dates[p.index]),
                                y: divergencePoints.map(p => vixNorm[p.index]),
                                type: 'scatter',
                                mode: 'markers',
                                name: 'Divergence Signal',
                                marker: {
                                    size: 12,
                                    color: '#ffaa00',
                                    symbol: 'diamond'
                                }
                            });
                        }
                    }
                    break;
            }
            
            const layout = {
                title: `Market Analysis - ${view.charAt(0).toUpperCase() + view.slice(1)} View`,
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                plot_bgcolor: 'rgba(0, 0, 0, 0.3)',
                font: { color: '#fff' },
                xaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' }
                },
                yaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' },
                    title: view === 'volatility' ? 'Volatility Rank' : 'Value'
                },
                yaxis2: {
                    overlaying: 'y',
                    side: 'right',
                    gridcolor: 'rgba(255, 255, 255, 0.05)',
                    tickfont: { color: '#888' }
                },
                showlegend: true,
                legend: {
                    orientation: 'h',
                    y: -0.15,
                    bgcolor: 'rgba(0, 0, 0, 0.5)'
                }
            };
            
            Plotly.newPlot('mainChart', traces, layout);
        }
        
        function normalizeData(data) {
            const min = Math.min(...data);
            const max = Math.max(...data);
            return data.map(v => (v - min) / (max - min));
        }
        
        function detectDivergencePoints(series1, series2) {
            const points = [];
            const window = 5;
            
            for (let i = window; i < series1.length - window; i++) {
                const s1Trend = series1[i] - series1[i - window];
                const s2Trend = series2[i] - series2[i - window];
                
                // Check for divergence
                if ((s1Trend > 0 && s2Trend < 0) || (s1Trend < 0 && s2Trend > 0)) {
                    points.push({
                        index: i,
                        strength: Math.abs(s1Trend - s2Trend)
                    });
                }
            }
            
            return points;
        }
        
        function calculateStandardDeviation(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
            return Math.sqrt(variance);
        }
        
        function calculateCorrelationMatrix() {
            const indicators = ['VIXCLS', 'SP500', 'DTWEXBGS', 'DGS10', 'WALCL'];
            const matrix = [];
            const labels = [];
            
            indicators.forEach((ind1, i) => {
                labels.push(currentData.customNames[ind1] || ind1);
                matrix[i] = [];
                indicators.forEach((ind2, j) => {
                    if (i === j) {
                        matrix[i][j] = 1;
                    } else {
                        // Simulate correlation (in production, calculate from historical data)
                        matrix[i][j] = Math.random() * 2 - 1;
                    }
                });
            });
            
            return { values: matrix, labels: labels };
        }
        
        // Update momentum chart
        async function updateMomentumChart() {
            if (!document.getElementById('momentumChart')) return;
            
            const traces = [];
            const dates = generateDateRange(60);
            
            // RSI-style momentum indicator
            const rsiTrace = {
                x: dates,
                y: generateMomentumOscillator(60),
                type: 'scatter',
                mode: 'lines',
                name: 'Market Momentum Index',
                line: { color: '#00ccff', width: 2 }
            };
            
            traces.push(rsiTrace);
            
            // Add overbought/oversold levels
            traces.push({
                x: dates,
                y: new Array(60).fill(70),
                type: 'scatter',
                mode: 'lines',
                name: 'Overbought',
                line: { color: '#ff4444', dash: 'dash', width: 1 }
            });
            
            traces.push({
                x: dates,
                y: new Array(60).fill(30),
                type: 'scatter',
                mode: 'lines',
                name: 'Oversold',
                line: { color: '#00ff88', dash: 'dash', width: 1 }
            });
            
            const layout = {
                title: 'Advanced Momentum Oscillator',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                plot_bgcolor: 'rgba(0, 0, 0, 0.3)',
                font: { color: '#fff' },
                xaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' }
                },
                yaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' },
                    title: 'Momentum (0-100)',
                    range: [0, 100]
                }
            };
            
            Plotly.newPlot('momentumChart', traces, layout);
            
            // Update momentum signals
            updateMomentumSignals();
        }
        
        function generateMomentumOscillator(length) {
            const values = [];
            let current = 50;
            
            for (let i = 0; i < length; i++) {
                const change = (Math.random() - 0.5) * 10;
                current = Math.max(0, Math.min(100, current + change));
                values.push(current);
            }
            
            return values;
        }
        
        function updateMomentumSignals() {
            const container = document.getElementById('momentumSignals');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Get top momentum movers
            const topMovers = Object.entries(currentData.momentumScores)
                .sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]))
                .slice(0, 6);
            
            topMovers.forEach(([key, score]) => {
                const card = document.createElement('div');
                card.className = 'analytics-card';
                
                const trend = score > 20 ? 'bullish' : score < -20 ? 'bearish' : 'neutral';
                const signal = getSignalFromMomentum(score);
                
                card.innerHTML = `
                    <div class="analytics-label">${currentData.customNames[key] || getIndicatorDisplayName(key)}</div>
                    <div class="analytics-value ${trend === 'bullish' ? 'positive' : trend === 'bearish' ? 'negative' : 'neutral'}">
                        ${score.toFixed(1)}
                        <span class="momentum-signal signal-${trend}">${signal}</span>
                    </div>
                    <div class="momentum-indicator">
                        <div class="momentum-bar momentum-${getMomentumClass(score)}" 
                             style="width: ${Math.abs(score)}%"></div>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }
        
        function getSignalFromMomentum(score) {
            if (score > 50) return 'STRONG BUY';
            if (score > 20) return 'BUY';
            if (score < -50) return 'STRONG SELL';
            if (score < -20) return 'SELL';
            return 'HOLD';
        }
        
        // Update trend chart
        async function updateTrendChart() {
            if (!document.getElementById('trendChart')) return;
            
            const traces = [];
            const dates = generateDateRange(90);
            
            // Create trend channels for key indicators
            const indicators = ['VIXCLS', 'SP500', 'DTWEXBGS'];
            
            indicators.forEach(key => {
                const data = currentData.overview.indicators?.[key];
                if (!data) return;
                
                const values = generateHistoricalData(data.value, 90);
                const trendLine = calculateTrendLine(values);
                const upperChannel = trendLine.map(v => v * 1.05);
                const lowerChannel = trendLine.map(v => v * 0.95);
                
                // Price line
                traces.push({
                    x: dates,
                    y: values,
                    type: 'scatter',
                    mode: 'lines',
                    name: currentData.customNames[key] || key,
                    line: { width: 2 }
                });
                
                // Trend line
                traces.push({
                    x: dates,
                    y: trendLine,
                    type: 'scatter',
                    mode: 'lines',
                    name: `${currentData.customNames[key] || key} Trend`,
                    line: { dash: 'dash', width: 1 },
                    visible: 'legendonly'
                });
            });
            
            const layout = {
                title: 'Multi-Indicator Trend Analysis',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                plot_bgcolor: 'rgba(0, 0, 0, 0.3)',
                font: { color: '#fff' },
                xaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' }
                },
                yaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickfont: { color: '#888' }
                }
            };
            
            Plotly.newPlot('trendChart', traces, layout);
            
            // Update trend candidates
            updateTrendCandidates();
        }
        
        function calculateTrendLine(values) {
            // Simple linear regression
            const n = values.length;
            const x = Array.from({length: n}, (_, i) => i);
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((acc, xi, i) => acc + xi * values[i], 0);
            const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return x.map(xi => slope * xi + intercept);
        }
        
        function updateTrendCandidates() {
            const container = document.getElementById('trendCandidates');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Identify potential breakouts
            const candidates = [];
            
            for (const [key, data] of Object.entries(currentData.overview.indicators || {})) {
                if (!data || !data.value) continue;
                
                const momentum = currentData.momentumScores[key] || 0;
                const volatility = currentData.volatilityMetrics[key] || 50;
                
                // Look for low volatility + building momentum
                if (volatility < 30 && Math.abs(momentum) > 15) {
                    candidates.push({
                        indicator: key,
                        momentum: momentum,
                        volatility: volatility,
                        signal: momentum > 0 ? 'Bullish Breakout' : 'Bearish Breakdown',
                        probability: calculateBreakoutProbability(momentum, volatility)
                    });
                }
            }
            
            // Sort by probability
            candidates.sort((a, b) => b.probability - a.probability);
            
            // Display top candidates
            candidates.slice(0, 6).forEach(candidate => {
                const card = document.createElement('div');
                card.className = 'data-card';
                
                const trend = candidate.momentum > 0 ? 'positive' : 'negative';
                
                card.innerHTML = `
                    <div class="data-card-header">
                        <div class="data-title">${currentData.customNames[candidate.indicator] || getIndicatorDisplayName(candidate.indicator)}</div>
                        <div class="data-source">${candidate.signal}</div>
                    </div>
                    <div class="data-value ${trend}">
                        ${candidate.probability}%
                    </div>
                    <div class="data-change">
                        <span>Momentum: ${candidate.momentum.toFixed(1)}</span>
                        <span style="margin-left: 1rem;">Volatility: ${candidate.volatility.toFixed(0)}</span>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }
        
        function calculateBreakoutProbability(momentum, volatility) {
            // Higher momentum + lower volatility = higher probability
            const momentumScore = Math.min(100, Math.abs(momentum) * 2);
            const volatilityScore = Math.max(0, 100 - volatility);
            return Math.round((momentumScore * 0.6 + volatilityScore * 0.4));
        }
        
        // Helper functions
        function getIndicatorDisplayName(key) {
            const displayNames = {
                'VIXCLS': 'VIX Volatility',
                'SP500': 'S&P 500',
                'DTWEXBGS': 'US Dollar Index',
                'DGS10': '10-Year Treasury',
                'WALCL': 'Fed Balance Sheet',
                'TEDRATE': 'TED Spread',
                'UNRATE': 'Unemployment Rate',
                'CPIAUCSL': 'CPI Inflation',
                'BAMLH0A0HYM2': 'HY Credit Spread',
                'T10Y2Y': 'Term Spread',
                'GOLDAMGBD228NLBM': 'Gold Price',
                'DFF': 'Fed Funds Rate',
                'SOFR': 'SOFR Rate',
                'MORTGAGE30US': '30Y Mortgage Rate'
            };
            
            return currentData.customNames[key] || displayNames[key] || key.replace(/_/g, ' ');
        }
        
        function categorizeIndicator(key) {
            const categories = {
                macro: ['VIXCLS', 'SP500', 'DGS10', 'UNRATE', 'CPIAUCSL', 'GDP'],
                risk: ['VIXCLS', 'TEDRATE', 'BAMLH0A0HYM2', 'T10Y2Y'],
                liquidity: ['WALCL', 'DFF', 'SOFR', 'TEDRATE'],
                currencies: ['DTWEXBGS']
            };
            
            for (const [category, indicators] of Object.entries(categories)) {
                if (indicators.includes(key)) {
                    return category;
                }
            }
            
            return 'other';
        }
        
        function formatValue(value, key) {
            if (value === null || value === undefined) return 'N/A';
            
            if (key === 'WALCL') {
                return `${(value / 1000000).toFixed(2)}T`;
            } else if (key.includes('RATE') || key === 'DGS10' || key === 'UNRATE') {
                return `${value.toFixed(2)}%`;
            } else if (key === 'SP500') {
                return value.toFixed(2);
            }
            
            return typeof value === 'number' ? value.toFixed(2) : value;
        }
        
        function generateHistoricalData(currentValue, days) {
            const data = [];
            let value = currentValue;
            
            for (let i = days; i > 0; i--) {
                const change = (Math.random() - 0.5) * 0.02;
                value = value * (1 + change);
                data.push(value);
            }
            
            data[data.length - 1] = currentValue;
            return data;
        }
        
        function generateDateRange(days) {
            const dates = [];
            const today = new Date();
            
            for (let i = days - 1; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                dates.push(date.toISOString().split('T')[0]);
            }
            
            return dates;
        }
        
        // Load all data
        async function loadAllData() {
            await loadOverviewData();
            
            if (activeTab === 'heatmap') await loadStableHeatmapData();
            if (activeTab === 'momentum') await updateMomentumChart();
            if (activeTab === 'trends') await updateTrendChart();
            if (activeTab === 'fed') await loadFedData();
            if (activeTab === 'blackswan') await loadBlackSwanData();
            if (activeTab === 'liquidity') await loadLiquidityData();
            
            // Update last update time
            document.getElementById('lastUpdate').textContent = 
                `Last Update: ${new Date().toLocaleTimeString()}`;
        }
        
        // Load overview data
        async function loadOverviewData() {
            try {
                const response = await fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.overview);
                const data = await response.json();
                
                currentData.overview = data;
                
                // Initialize advanced analytics
                await initializeAdvancedAnalytics();
                
                // Update displays
                updateKeyMetrics(data.indicators || {});
                displayOverviewGrid(data.indicators || {});
                updateEnhancedMainChart(currentChartView);
                detectMarketPhase(data.indicators || {});
                
            } catch (error) {
                console.error('Error loading overview:', error);
            }
        }
        
        // Update key metrics with editable names
        function updateKeyMetrics(indicators) {
            const metricsGrid = document.getElementById('keyMetrics');
            if (!metricsGrid) return;
            
            metricsGrid.innerHTML = '';
            
            const metricConfigs = [
                { key: 'VIXCLS', display: 'VIX', suffix: '', defaultValue: 16.57 },
                { key: 'SP500', display: 'S&P 500', suffix: '', defaultValue: 6389.45 },
                { key: 'DTWEXBGS', display: 'DXY', suffix: '', defaultValue: 121.61 },
                { key: 'DGS10', display: '10Y Treasury', suffix: '%', defaultValue: 4.23 },
                { key: 'WALCL', display: 'Fed Balance', suffix: '', isTrillions: true, defaultValue: 6640000 },
                { key: 'TEDRATE', display: 'TED Spread', suffix: '%', defaultValue: 0.09 }
            ];
            
            metricConfigs.forEach(config => {
                const data = indicators[config.key] || { value: config.defaultValue, change: Math.random() * 4 - 2 };
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.dataset.indicatorKey = config.key;
                
                const displayName = currentData.customNames[config.key] || config.display;
                const formattedValue = formatMetricValue(data.value, config);
                const changePercent = data.change || 0;
                const momentum = currentData.momentumScores[config.key] || 0;
                
                card.innerHTML = `
                    <div class="metric-title" onclick="makeIndicatorNameEditable(this, '${config.key}')">
                        ${displayName}
                    </div>
                    <div class="metric-value ${changePercent >= 0 ? 'positive' : 'negative'}">
                        ${formattedValue}
                    </div>
                    <div class="metric-change ${changePercent >= 0 ? 'positive' : 'negative'}">
                        <span>${changePercent >= 0 ? '▲' : '▼'}</span> 
                        ${Math.abs(changePercent).toFixed(2)}%
                        ${Math.abs(momentum) > 30 ? `<span class="momentum-signal signal-${momentum > 0 ? 'bullish' : 'bearish'}">${momentum > 0 ? '↗' : '↘'}</span>` : ''}
                    </div>
                `;
                
                metricsGrid.appendChild(card);
            });
        }
        
        function formatMetricValue(value, config) {
            if (config.isTrillions && value) {
                return `${(value / 1000000).toFixed(2)}T`;
            } else if (value) {
                return typeof value === 'number' ? 
                    value.toFixed(2) + config.suffix : 
                    value + config.suffix;
            }
            return 'N/A';
        }
        
        // Display overview grid
        function displayOverviewGrid(indicators) {
            const grid = document.getElementById('overviewGrid');
            grid.innerHTML = '';
            
            const priorityIndicators = ['VIXCLS', 'SP500', 'DTWEXBGS', 'DGS10', 'UNRATE', 'GDP', 'CPIAUCSL', 'GOLDAMGBD228NLBM'];
            
            for (const key of priorityIndicators) {
                if (!indicators[key]) continue;
                
                const data = indicators[key];
                const card = createDataCard(key, data);
                grid.appendChild(card);
            }
        }
        
        function createDataCard(key, data) {
            const card = document.createElement('div');
            card.className = 'data-card';
            card.dataset.indicatorKey = key;
            
            const displayName = currentData.customNames[key] || getIndicatorDisplayName(key);
            const changePercent = data.change || (Math.random() * 6 - 3);
            const momentum = currentData.momentumScores[key] || 0;
            
            card.innerHTML = `
                <div class="data-card-header">
                    <div class="data-title" onclick="makeIndicatorNameEditable(this, '${key}')">${displayName}</div>
                    <div class="data-source">FRED</div>
                </div>
                <div class="data-value ${changePercent >= 0 ? 'positive' : 'negative'}">
                    ${formatValue(data.value, key)}
                </div>
                <div class="data-change ${changePercent >= 0 ? 'positive' : 'negative'}">
                    <span>${changePercent >= 0 ? '▲' : '▼'}</span> 
                    ${Math.abs(changePercent).toFixed(2)}%
                </div>
                ${Math.abs(momentum) > 20 ? `
                <div class="momentum-indicator">
                    <div class="momentum-bar momentum-${getMomentumClass(momentum)}" 
                         style="width: ${Math.abs(momentum)}%"></div>
                </div>` : ''}
            `;
            
            return card;
        }
        
        // Detect market phase
        function detectMarketPhase(indicators) {
            const banner = document.getElementById('marketPhaseBanner');
            if (!banner) return;
            
            const vix = indicators.VIXCLS?.value || 20;
            const sp500Change = indicators.SP500?.change || 0;
            const momentum = Object.values(currentData.momentumScores).reduce((a, b) => a + b, 0) / Object.values(currentData.momentumScores).length || 0;
            
            let phase = '';
            let risk = 'LOW';
            
            if (vix < 15 && momentum > 30) {
                phase = '🚀 STRONG BULL - LOW VOLATILITY + HIGH MOMENTUM';
                risk = 'LOW';
            } else if (vix > 30 && momentum < -30) {
                phase = '🐻 BEAR MARKET - HIGH VOLATILITY + NEGATIVE MOMENTUM';
                risk = 'HIGH';
            } else if (Math.abs(momentum) < 10 && vix < 20) {
                phase = '😴 LOW VOLATILITY GRIND - POTENTIAL BREAKOUT PENDING';
                risk = 'MEDIUM';
            } else {
                phase = '📈 NORMAL MARKET CONDITIONS';
                risk = 'LOW';
            }
            
            banner.textContent = phase;
            
            // Update risk level
            const riskEl = document.getElementById('riskLevel');
            riskEl.textContent = risk;
            riskEl.className = `risk-level risk-${risk.toLowerCase()}`;
        }
        
        // Load Fed data
        async function loadFedData() {
            try {
                const response = await fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.fed);
                const data = await response.json();
                currentData.fed = data;
                displayDataGrid('fedGrid', data.indicators || {}, 'Fed');
            } catch (error) {
                console.error('Error loading Fed data:', error);
            }
        }
        
        // Load Black Swan data
        async function loadBlackSwanData() {
            try {
                const response = await fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.blackswan);
                const data = await response.json();
                currentData.blackswan = data;
                displayDataGrid('blackSwanGrid', data.indicators || {}, 'Risk');
            } catch (error) {
                console.error('Error loading Black Swan data:', error);
            }
        }
        
        // Load Liquidity data
        async function loadLiquidityData() {
            try {
                const response = await fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.liquidity);
                const data = await response.json();
                currentData.liquidity = data;
                displayDataGrid('liquidityGrid', data.indicators || {}, 'Liquidity');
            } catch (error) {
                console.error('Error loading Liquidity data:', error);
            }
        }
        
        // Display data grid
        function displayDataGrid(gridId, indicators, category) {
            const grid = document.getElementById(gridId);
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (const [key, data] of Object.entries(indicators)) {
                if (!data || data.value === null) continue;
                const card = createDataCard(key, data);
                grid.appendChild(card);
            }
        }
        
        // Test API connections
        async function testAPIConnections() {
            const mainStatus = document.getElementById('mainApiStatus');
            const mlStatus = document.getElementById('mlStatus');
            const alertsStatus = document.getElementById('alertsStatus');
            
            try {
                const response = await fetch(OPENBB_CONFIG.MAIN_API.baseUrl + OPENBB_CONFIG.MAIN_API.endpoints.health);
                if (response.ok) {
                    mainStatus.className = 'status-dot connected';
                    mlStatus.className = 'status-dot connected';
                    alertsStatus.className = 'status-dot connected';
                } else {
                    mainStatus.className = 'status-dot error';
                }
            } catch (error) {
                console.error('API connection error:', error);
                mainStatus.className = 'status-dot error';
                mlStatus.className = 'status-dot error';
                alertsStatus.className = 'status-dot error';
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    const tabId = e.target.dataset.tab;
                    document.getElementById(tabId).classList.add('active');
                    
                    activeTab = tabId;
                    loadAllData();
                });
            });
            
            // Chart view controls
            document.querySelectorAll('.chart-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const view = e.target.dataset.view;
                    if (view) {
                        document.querySelectorAll('.chart-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        currentChartView = view;
                        updateEnhancedMainChart(view);
                    }
                });
            });
        }
        
        // Update heatmap view
        function updateHeatmapView(view) {
            currentData.currentHeatmapView = view;
            
            document.querySelectorAll('.heatmap-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase().includes(view) || 
                    (view === 'all' && btn.textContent === 'All')) {
                    btn.classList.add('active');
                }
            });
            
            updateEnhancedHeatmapDisplay(currentData.heatmapData);
        }
        
        // Start stable auto-refresh
        function startStableAutoRefresh() {
            autoRefreshInterval = setInterval(() => {
                console.log('🔄 Auto-refreshing data...');
                loadAllData();
            }, 30000); // 30 seconds
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initializePlatform);
    </script>
</body>
</html>
