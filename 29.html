<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate FRED Financial Intelligence Platform v10.0</title>
    
    <!-- Required Libraries -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary-green: #00ff88;
            --primary-blue: #00ccff;
            --danger-red: #ff4444;
            --warning-orange: #ffaa00;
            --bg-dark: #0a0e27;
            --bg-light: #151932;
            --text-primary: #e0e0e0;
            --text-secondary: #888;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-light) 100%);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        /* Header Styles */
        .header {
            background: rgba(20, 24, 44, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--primary-green), var(--primary-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Alert System */
        .alert-manager {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 350px;
            max-height: 500px;
            overflow-y: auto;
            background: rgba(20, 24, 44, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 1rem;
            display: none;
            z-index: 2000;
        }
        
        .alert-manager.active {
            display: block;
        }
        
        .alert-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .alert-triggered {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid var(--danger-red);
        }
        
        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 0.5rem;
            overflow-x: auto;
            position: relative;
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }
        
        .tab-btn.active {
            background: var(--primary-green);
            color: #000;
            font-weight: bold;
        }
        
        .tab-btn .edit-tab {
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tab-btn:hover .edit-tab {
            opacity: 1;
        }
        
        /* Container */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Indicator Management Panel */
        .indicator-manager {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .indicator-search {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            margin-bottom: 1rem;
            font-size: 1rem;
        }
        
        .indicator-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .indicator-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .indicator-item:hover {
            background: rgba(0, 255, 136, 0.1);
        }
        
        .indicator-item.selected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid var(--primary-green);
        }
        
        /* Advanced Chart Container */
        .advanced-chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .chart-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .timeframe-selector {
            display: flex;
            gap: 0.25rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.25rem;
        }
        
        .timeframe-btn {
            padding: 0.5rem 0.75rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.875rem;
            transition: all 0.3s;
        }
        
        .timeframe-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .timeframe-btn.active {
            background: var(--primary-green);
            color: #000;
        }
        
        /* Chart Tools */
        .chart-tools {
            display: flex;
            gap: 0.5rem;
        }
        
        .tool-btn {
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tool-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: var(--primary-green);
        }
        
        .tool-btn.active {
            background: var(--primary-green);
            color: #000;
        }
        
        /* Comparison Panel */
        .comparison-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .comparison-metric {
            text-align: center;
        }
        
        .comparison-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }
        
        .comparison-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .comparison-change {
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }
        
        /* Data Grid */
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .data-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
        }
        
        .data-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.2);
            border-color: var(--primary-green);
        }
        
        .card-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .data-card:hover .card-actions {
            opacity: 1;
        }
        
        .action-btn {
            padding: 0.25rem 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.3s;
        }
        
        .action-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            color: var(--primary-green);
        }
        
        /* Heatmap Grid */
        .heatmap-grid {
            display: grid;
            grid-template-columns: minmax(200px, 1fr) repeat(7, minmax(100px, 1fr));
            gap: 2px;
            background: rgba(255, 255, 255, 0.05);
            padding: 2px;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        .heatmap-cell {
            padding: 1rem;
            text-align: center;
            font-size: 0.875rem;
            transition: all 0.3s;
            border-radius: 4px;
            position: relative;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .heatmap-cell.header {
            background: rgba(0, 255, 136, 0.1);
            font-weight: bold;
            color: var(--primary-green);
            text-transform: uppercase;
            font-size: 0.75rem;
        }
        
        /* Heatmap color gradients */
        .heat-extreme-negative { background: linear-gradient(135deg, #8B0000, #DC143C); color: #fff; }
        .heat-high-negative { background: linear-gradient(135deg, #DC143C, #FF4444); color: #fff; }
        .heat-moderate-negative { background: linear-gradient(135deg, #FF4444, #FF6666); color: #fff; }
        .heat-low-negative { background: linear-gradient(135deg, #FF6666, #FF8888); color: #fff; }
        .heat-neutral { background: rgba(255, 255, 255, 0.05); color: var(--text-secondary); }
        .heat-low-positive { background: linear-gradient(135deg, #88FF88, #66FF66); color: #000; }
        .heat-moderate-positive { background: linear-gradient(135deg, #66FF66, #44FF44); color: #000; }
        .heat-high-positive { background: linear-gradient(135deg, #44FF44, #00FF44); color: #000; }
        .heat-extreme-positive { background: linear-gradient(135deg, #00FF44, #00CC33); color: #000; }
        
        /* Export Panel */
        .export-panel {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(20, 24, 44, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 1rem;
            display: none;
            z-index: 1000;
        }
        
        .export-panel.active {
            display: block;
        }
        
        .export-btn {
            display: block;
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .export-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: var(--primary-green);
        }
        
        /* Correlation Matrix */
        .correlation-matrix {
            overflow-x: auto;
            margin: 2rem 0;
        }
        
        .correlation-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .correlation-table th,
        .correlation-table td {
            padding: 0.5rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.875rem;
        }
        
        .correlation-table th {
            background: rgba(0, 255, 136, 0.1);
            color: var(--primary-green);
        }
        
        .correlation-cell {
            position: relative;
            cursor: pointer;
        }
        
        .correlation-positive-high { background: rgba(0, 255, 136, 0.3); }
        .correlation-positive-medium { background: rgba(0, 255, 136, 0.15); }
        .correlation-positive-low { background: rgba(0, 255, 136, 0.05); }
        .correlation-negative-low { background: rgba(255, 68, 68, 0.05); }
        .correlation-negative-medium { background: rgba(255, 68, 68, 0.15); }
        .correlation-negative-high { background: rgba(255, 68, 68, 0.3); }
        
        /* Anomaly Detection */
        .anomaly-badge {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            background: var(--danger-red);
            color: #fff;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        /* Loading Spinner */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-top-color: var(--primary-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            backdrop-filter: blur(5px);
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-dark) 100%);
            border-radius: 16px;
            padding: 2rem;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--primary-green), var(--primary-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .close-modal {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .close-modal:hover {
            background: rgba(255, 68, 68, 0.2);
            color: var(--danger-red);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .header { padding: 1rem; }
            .data-grid { grid-template-columns: 1fr; }
            .heatmap-grid { grid-template-columns: minmax(120px, 1fr) repeat(3, minmax(80px, 1fr)); }
            .tabs-nav { overflow-x: auto; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            📊 Ultimate FRED Platform
            <span style="font-size: 0.875rem; color: var(--text-secondary);">v10.0</span>
        </div>
        
        <div style="display: flex; gap: 1rem; align-items: center;">
            <button class="tool-btn" onclick="toggleAlertManager()">
                🔔 Alerts <span id="alertCount" style="background: var(--danger-red); padding: 0.125rem 0.25rem; border-radius: 4px; margin-left: 0.25rem;">0</span>
            </button>
            <button class="tool-btn" onclick="toggleExportPanel()">
                📥 Export
            </button>
            <button class="tool-btn" onclick="openCustomizeDashboard()">
                ⚙️ Customize
            </button>
            <button class="tool-btn" onclick="forceRefreshAllData()">
                🔄 Refresh
            </button>
        </div>
    </header>
    
    <!-- Alert Manager -->
    <div class="alert-manager" id="alertManager">
        <h3 style="margin-bottom: 1rem;">Alert Manager</h3>
        <div id="alertsList"></div>
        <button class="export-btn" onclick="createNewAlert()">+ New Alert</button>
    </div>
    
    <!-- Export Panel -->
    <div class="export-panel" id="exportPanel">
        <h3 style="margin-bottom: 1rem;">Export Data</h3>
        <button class="export-btn" onclick="exportToPDF()">📄 Export to PDF</button>
        <button class="export-btn" onclick="exportToExcel()">📊 Export to Excel</button>
        <button class="export-btn" onclick="exportToCSV()">📁 Export to CSV</button>
        <button class="export-btn" onclick="exportToJSON()">{ } Export to JSON</button>
    </div>
    
    <div class="container">
        <!-- Dynamic Tabs Navigation -->
        <div class="tabs-nav" id="tabsNav">
            <!-- Tabs will be dynamically generated -->
        </div>
        
        <!-- Dynamic Tab Contents -->
        <div id="tabContents">
            <!-- Tab contents will be dynamically generated -->
        </div>
    </div>
    
    <!-- Customize Dashboard Modal -->
    <div class="modal" id="customizeModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Customize Dashboard</h2>
                <button class="close-modal" onclick="closeCustomizeModal()">✕</button>
            </div>
            <div id="customizeContent">
                <!-- Customization options will be loaded here -->
            </div>
        </div>
    </div>
    
    <script>
        // ====================================
        // CONFIGURATION
        // ====================================
        const CONFIG = {
            FRED_API_KEY: '2f057499936072679d8843d7fce99989',
            FRED_BASE_URL: 'https://api.stlouisfed.org/fred',
            
            // OpenBB API endpoints (from your original config)
            OPENBB_API: {
                baseUrl: 'https://i70jxru6md.execute-api.us-east-1.amazonaws.com/prod/api/v1',
                endpoints: {
                    health: '/health',
                    overview: '/dashboard/overview',
                    mega: '/dashboard/mega',
                    dxy: '/dxy',
                    ice_bofa: '/ice_bofa',
                    fed: '/fed',
                    blackswan: '/blackswan',
                    liquidity: '/liquidity',
                    crisis: '/crisis'
                }
            },
            
            // Auto-update settings (twice weekly: Wednesday and Sunday)
            AUTO_UPDATE_DAYS: [0, 3], // 0 = Sunday, 3 = Wednesday
            AUTO_UPDATE_HOUR: 9, // 9 AM
            
            // Chart timeframes
            TIMEFRAMES: {
                '1D': { days: 1, interval: '5min' },
                '5D': { days: 5, interval: '15min' },
                '1M': { days: 30, interval: '1h' },
                '3M': { days: 90, interval: '4h' },
                '6M': { days: 180, interval: '1d' },
                'YTD': { days: 'ytd', interval: '1d' },
                '1Y': { days: 365, interval: '1d' },
                '2Y': { days: 730, interval: '1w' },
                '5Y': { days: 1825, interval: '1w' },
                '10Y': { days: 3650, interval: '1m' },
                'ALL': { days: 'all', interval: '1m' }
            }
        };
        
        // ====================================
        // GLOBAL STATE
        // ====================================
        class GlobalState {
            constructor() {
                this.data = {};
                this.indicators = this.loadIndicators();
                this.tabs = this.loadTabs();
                this.alerts = this.loadAlerts();
                this.correlations = {};
                this.anomalies = {};
                this.customLayouts = this.loadLayouts();
                this.activeTab = 'overview';
                this.selectedTimeframe = '1Y';
                this.chartType = 'line';
                this.comparisonMode = false;
                this.selectedIndicators = new Set();
                this.historicalCache = new Map();
            }
            
            loadIndicators() {
                const saved = localStorage.getItem('fredIndicators');
                if (saved) return JSON.parse(saved);
                
                // Default indicators with categories
                return {
                    'VIXCLS': { name: 'VIX Volatility', category: 'risk', enabled: true },
                    'SP500': { name: 'S&P 500', category: 'equity', enabled: true },
                    'DGS10': { name: '10-Year Treasury', category: 'rates', enabled: true },
                    'DGS2': { name: '2-Year Treasury', category: 'rates', enabled: true },
                    'T10Y2Y': { name: '10Y-2Y Spread', category: 'rates', enabled: true },
                    'DTWEXBGS': { name: 'US Dollar Index', category: 'fx', enabled: true },
                    'WALCL': { name: 'Fed Balance Sheet', category: 'fed', enabled: true },
                    'DFF': { name: 'Fed Funds Rate', category: 'fed', enabled: true },
                    'TEDRATE': { name: 'TED Spread', category: 'credit', enabled: true },
                    'BAMLH0A0HYM2': { name: 'HY Credit Spread', category: 'credit', enabled: true },
                    'UNRATE': { name: 'Unemployment Rate', category: 'macro', enabled: true },
                    'CPIAUCSL': { name: 'CPI', category: 'macro', enabled: true },
                    'GDP': { name: 'GDP', category: 'macro', enabled: true },
                    'GOLDAMGBD228NLBM': { name: 'Gold Price', category: 'commodity', enabled: true },
                    'DCOILWTICO': { name: 'WTI Crude Oil', category: 'commodity', enabled: true },
                    'MORTGAGE30US': { name: '30Y Mortgage Rate', category: 'rates', enabled: true },
                    'DJIA': { name: 'Dow Jones', category: 'equity', enabled: true },
                    'NASDAQCOM': { name: 'NASDAQ', category: 'equity', enabled: true },
                    'RUSSELL2000': { name: 'Russell 2000', category: 'equity', enabled: true },
                    'DEXUSEU': { name: 'USD/EUR', category: 'fx', enabled: true },
                    'DEXJPUS': { name: 'USD/JPY', category: 'fx', enabled: true },
                    'DEXUSUK': { name: 'USD/GBP', category: 'fx', enabled: true },
                    'DEXCHUS': { name: 'USD/CNY', category: 'fx', enabled: true },
                    'SOFR': { name: 'SOFR Rate', category: 'rates', enabled: true },
                    'RRPONTSYD': { name: 'Reverse Repo', category: 'fed', enabled: true }
                };
            }
            
            loadTabs() {
                const saved = localStorage.getItem('fredTabs');
                if (saved) return JSON.parse(saved);
                
                // Default tabs with their indicators
                return [
                    { id: 'overview', name: '📈 Overview', indicators: ['VIXCLS', 'SP500', 'DGS10', 'DTWEXBGS', 'WALCL', 'DFF'] },
                    { id: 'heatmap', name: '🔥 Heatmap', indicators: 'all' },
                    { id: 'rates', name: '📊 Rates', indicators: ['DGS10', 'DGS2', 'T10Y2Y', 'DFF', 'SOFR', 'MORTGAGE30US'] },
                    { id: 'equity', name: '📈 Equity', indicators: ['SP500', 'DJIA', 'NASDAQCOM', 'RUSSELL2000', 'VIXCLS'] },
                    { id: 'fx', name: '💱 FX', indicators: ['DTWEXBGS', 'DEXUSEU', 'DEXJPUS', 'DEXUSUK', 'DEXCHUS'] },
                    { id: 'fed', name: '🏛️ Fed', indicators: ['WALCL', 'DFF', 'RRPONTSYD'] },
                    { id: 'credit', name: '💳 Credit', indicators: ['TEDRATE', 'BAMLH0A0HYM2'] },
                    { id: 'macro', name: '🌍 Macro', indicators: ['GDP', 'UNRATE', 'CPIAUCSL'] },
                    { id: 'commodity', name: '🛢️ Commodity', indicators: ['GOLDAMGBD228NLBM', 'DCOILWTICO'] },
                    { id: 'correlations', name: '🔗 Correlations', indicators: 'special' },
                    { id: 'anomalies', name: '⚠️ Anomalies', indicators: 'special' }
                ];
            }
            
            loadAlerts() {
                const saved = localStorage.getItem('fredAlerts');
                return saved ? JSON.parse(saved) : [];
            }
            
            loadLayouts() {
                const saved = localStorage.getItem('fredLayouts');
                if (saved) return JSON.parse(saved);
                
                return {
                    'Risk Manager': { tabs: ['overview', 'heatmap', 'rates', 'credit', 'anomalies'] },
                    'Macro Trader': { tabs: ['macro', 'fx', 'rates', 'commodity'] },
                    'Fed Watcher': { tabs: ['fed', 'rates', 'credit'] }
                };
            }
            
            saveState() {
                localStorage.setItem('fredIndicators', JSON.stringify(this.indicators));
                localStorage.setItem('fredTabs', JSON.stringify(this.tabs));
                localStorage.setItem('fredAlerts', JSON.stringify(this.alerts));
                localStorage.setItem('fredLayouts', JSON.stringify(this.customLayouts));
            }
        }
        
        const state = new GlobalState();
        
        // ====================================
        // FRED API FUNCTIONS
        // ====================================
        class FREDDataFetcher {
            constructor(apiKey) {
                this.apiKey = apiKey;
                this.baseUrl = CONFIG.FRED_BASE_URL;
                this.cache = new Map();
                this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
            }
            
            async fetchSeries(seriesId, options = {}) {
                const cacheKey = `${seriesId}_${JSON.stringify(options)}`;
                const cached = this.cache.get(cacheKey);
                
                if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
                    return cached.data;
                }
                
                const params = new URLSearchParams({
                    series_id: seriesId,
                    api_key: this.apiKey,
                    file_type: 'json',
                    observation_start: options.start || '1990-01-01',
                    observation_end: options.end || new Date().toISOString().split('T')[0],
                    ...options
                });
                
                try {
                    const response = await fetch(`${this.baseUrl}/series/observations?${params}`);
                    const data = await response.json();
                    
                    if (data.observations) {
                        const result = {
                            seriesId,
                            observations: data.observations.map(obs => ({
                                date: obs.date,
                                value: parseFloat(obs.value)
                            })).filter(obs => !isNaN(obs.value))
                        };
                        
                        this.cache.set(cacheKey, {
                            data: result,
                            timestamp: Date.now()
                        });
                        
                        return result;
                    }
                } catch (error) {
                    console.error(`Error fetching ${seriesId}:`, error);
                }
                
                return null;
            }
            
            async fetchMultipleSeries(seriesIds, options = {}) {
                const promises = seriesIds.map(id => this.fetchSeries(id, options));
                const results = await Promise.all(promises);
                return results.filter(r => r !== null);
            }
            
            calculateChanges(observations) {
                if (!observations || observations.length < 2) return {};
                
                const latest = observations[observations.length - 1];
                const latestValue = latest.value;
                const latestDate = new Date(latest.date);
                
                // Find comparison points
                const dayAgo = new Date(latestDate);
                dayAgo.setDate(dayAgo.getDate() - 1);
                
                const weekAgo = new Date(latestDate);
                weekAgo.setDate(weekAgo.getDate() - 7);
                
                const monthAgo = new Date(latestDate);
                monthAgo.setMonth(monthAgo.getMonth() - 1);
                
                const quarterAgo = new Date(latestDate);
                quarterAgo.setMonth(quarterAgo.getMonth() - 3);
                
                const yearAgo = new Date(latestDate);
                yearAgo.setFullYear(yearAgo.getFullYear() - 1);
                
                // Find closest observations
                const findClosest = (targetDate) => {
                    return observations.reduce((prev, curr) => {
                        const currDate = new Date(curr.date);
                        const prevDate = new Date(prev.date);
                        return Math.abs(currDate - targetDate) < Math.abs(prevDate - targetDate) ? curr : prev;
                    });
                };
                
                const dayAgoObs = findClosest(dayAgo);
                const weekAgoObs = findClosest(weekAgo);
                const monthAgoObs = findClosest(monthAgo);
                const quarterAgoObs = findClosest(quarterAgo);
                const yearAgoObs = findClosest(yearAgo);
                
                return {
                    current: latestValue,
                    date: latest.date,
                    DoD: ((latestValue - dayAgoObs.value) / dayAgoObs.value * 100),
                    WoW: ((latestValue - weekAgoObs.value) / weekAgoObs.value * 100),
                    MoM: ((latestValue - monthAgoObs.value) / monthAgoObs.value * 100),
                    QoQ: ((latestValue - quarterAgoObs.value) / quarterAgoObs.value * 100),
                    YoY: ((latestValue - yearAgoObs.value) / yearAgoObs.value * 100)
                };
            }
            
            detectTrendReversal(observations, window = 20) {
                if (!observations || observations.length < window * 2) return null;
                
                const recent = observations.slice(-window);
                const previous = observations.slice(-window * 2, -window);
                
                const recentTrend = this.calculateTrend(recent);
                const previousTrend = this.calculateTrend(previous);
                
                if (previousTrend.slope > 0 && recentTrend.slope < 0) {
                    return { type: 'bearish', strength: Math.abs(recentTrend.slope) };
                } else if (previousTrend.slope < 0 && recentTrend.slope > 0) {
                    return { type: 'bullish', strength: Math.abs(recentTrend.slope) };
                }
                
                return null;
            }
            
            calculateTrend(observations) {
                const n = observations.length;
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                
                observations.forEach((obs, i) => {
                    sumX += i;
                    sumY += obs.value;
                    sumXY += i * obs.value;
                    sumX2 += i * i;
                });
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return { slope, intercept };
            }
            
            calculateMomentum(observations, period = 14) {
                if (!observations || observations.length < period + 1) return null;
                
                const recent = observations.slice(-period - 1);
                const gains = [];
                const losses = [];
                
                for (let i = 1; i < recent.length; i++) {
                    const change = recent[i].value - recent[i - 1].value;
                    if (change > 0) {
                        gains.push(change);
                        losses.push(0);
                    } else {
                        gains.push(0);
                        losses.push(Math.abs(change));
                    }
                }
                
                const avgGain = gains.reduce((a, b) => a + b, 0) / period;
                const avgLoss = losses.reduce((a, b) => a + b, 0) / period;
                
                if (avgLoss === 0) return 100;
                
                const rs = avgGain / avgLoss;
                const rsi = 100 - (100 / (1 + rs));
                
                return {
                    rsi,
                    momentum: recent[recent.length - 1].value - recent[0].value,
                    interpretation: rsi > 70 ? 'overbought' : rsi < 30 ? 'oversold' : 'neutral'
                };
            }
        }
        
        const fredAPI = new FREDDataFetcher(CONFIG.FRED_API_KEY);
        
        // ====================================
        // ALERT SYSTEM
        // ====================================
        class AlertSystem {
            constructor() {
                this.alerts = state.alerts;
                this.checkInterval = 60000; // Check every minute
                this.notificationPermission = false;
                this.requestNotificationPermission();
            }
            
            requestNotificationPermission() {
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        this.notificationPermission = permission === 'granted';
                    });
                }
            }
            
            addAlert(indicator, condition, threshold, action = 'notify') {
                const alert = {
                    id: Date.now(),
                    indicator,
                    condition, // 'above', 'below', 'change', 'crossover'
                    threshold,
                    action, // 'notify', 'email', 'webhook'
                    active: true,
                    triggered: false,
                    createdAt: new Date().toISOString()
                };
                
                this.alerts.push(alert);
                state.alerts = this.alerts;
                state.saveState();
                this.updateAlertDisplay();
                
                return alert;
            }
            
            checkAlerts(data) {
                let triggeredCount = 0;
                
                this.alerts.forEach(alert => {
                    if (!alert.active || alert.triggered) return;
                    
                    const indicatorData = data[alert.indicator];
                    if (!indicatorData) return;
                    
                    let triggered = false;
                    
                    switch (alert.condition) {
                        case 'above':
                            triggered = indicatorData.current > alert.threshold;
                            break;
                        case 'below':
                            triggered = indicatorData.current < alert.threshold;
                            break;
                        case 'change':
                            triggered = Math.abs(indicatorData.DoD || 0) > alert.threshold;
                            break;
                        case 'crossover':
                            // Check if indicator crossed threshold since last check
                            const prev = this.previousValues[alert.indicator];
                            if (prev) {
                                triggered = (prev < alert.threshold && indicatorData.current > alert.threshold) ||
                                          (prev > alert.threshold && indicatorData.current < alert.threshold);
                            }
                            break;
                    }
                    
                    if (triggered) {
                        this.triggerAlert(alert, indicatorData.current);
                        triggeredCount++;
                    }
                });
                
                // Store current values for crossover detection
                this.previousValues = {};
                Object.keys(data).forEach(key => {
                    this.previousValues[key] = data[key].current;
                });
                
                if (triggeredCount > 0) {
                    this.updateAlertDisplay();
                }
            }
            
            triggerAlert(alert, value) {
                alert.triggered = true;
                alert.triggeredAt = new Date().toISOString();
                alert.triggeredValue = value;
                
                const indicatorName = state.indicators[alert.indicator]?.name || alert.indicator;
                const message = `${indicatorName} is ${alert.condition} ${alert.threshold} (Current: ${value.toFixed(2)})`;
                
                switch (alert.action) {
                    case 'notify':
                        this.showNotification('Alert Triggered!', message);
                        break;
                    case 'email':
                        this.sendEmail(alert, message);
                        break;
                    case 'webhook':
                        this.callWebhook(alert, message);
                        break;
                }
                
                state.saveState();
            }
            
            showNotification(title, body) {
                if (this.notificationPermission && 'Notification' in window) {
                    new Notification(title, {
                        body,
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">📊</text></svg>',
                        badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">🔔</text></svg>'
                    });
                }
                
                // Also show in-app notification
                this.showInAppNotification(title, body);
            }
            
            showInAppNotification(title, body) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 204, 255, 0.2));
                    border: 1px solid var(--primary-green);
                    border-radius: 12px;
                    padding: 1rem;
                    max-width: 300px;
                    z-index: 5000;
                    animation: slideIn 0.3s ease;
                `;
                
                notification.innerHTML = `
                    <h4 style="margin-bottom: 0.5rem;">${title}</h4>
                    <p style="font-size: 0.875rem;">${body}</p>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }
            
            updateAlertDisplay() {
                const alertsList = document.getElementById('alertsList');
                const alertCount = document.getElementById('alertCount');
                
                if (alertsList) {
                    alertsList.innerHTML = '';
                    
                    this.alerts.forEach(alert => {
                        const indicatorName = state.indicators[alert.indicator]?.name || alert.indicator;
                        const alertDiv = document.createElement('div');
                        alertDiv.className = `alert-item ${alert.triggered ? 'alert-triggered' : ''}`;
                        
                        alertDiv.innerHTML = `
                            <div>
                                <strong>${indicatorName}</strong><br>
                                <small>${alert.condition} ${alert.threshold}</small>
                                ${alert.triggered ? `<br><small>Triggered: ${new Date(alert.triggeredAt).toLocaleString()}</small>` : ''}
                            </div>
                            <button class="action-btn" onclick="alertSystem.removeAlert(${alert.id})">×</button>
                        `;
                        
                        alertsList.appendChild(alertDiv);
                    });
                }
                
                if (alertCount) {
                    const activeAlerts = this.alerts.filter(a => a.active && !a.triggered).length;
                    alertCount.textContent = activeAlerts;
                    alertCount.style.display = activeAlerts > 0 ? 'inline-block' : 'none';
                }
            }
            
            removeAlert(id) {
                this.alerts = this.alerts.filter(a => a.id !== id);
                state.alerts = this.alerts;
                state.saveState();
                this.updateAlertDisplay();
            }
        }
        
        const alertSystem = new AlertSystem();
        
        // ====================================
        // DATA MANAGEMENT
        // ====================================
        class DataManager {
            constructor() {
                this.updateInProgress = false;
                this.lastUpdate = null;
                this.setupAutoUpdate();
            }
            
            async fetchAllData() {
                if (this.updateInProgress) return;
                
                this.updateInProgress = true;
                console.log('📊 Fetching all FRED data...');
                
                try {
                    // Get all enabled indicators
                    const enabledIndicators = Object.entries(state.indicators)
                        .filter(([_, config]) => config.enabled)
                        .map(([id, _]) => id);
                    
                    // Fetch data for all indicators
                    const dataPromises = enabledIndicators.map(async (id) => {
                        const data = await fredAPI.fetchSeries(id);
                        if (data) {
                            const changes = fredAPI.calculateChanges(data.observations);
                            const trend = fredAPI.detectTrendReversal(data.observations);
                            const momentum = fredAPI.calculateMomentum(data.observations);
                            
                            return {
                                id,
                                ...changes,
                                trend,
                                momentum,
                                observations: data.observations
                            };
                        }
                        return null;
                    });
                    
                    const results = await Promise.all(dataPromises);
                    
                    // Process results
                    results.forEach(result => {
                        if (result) {
                            state.data[result.id] = result;
                        }
                    });
                    
                    // Calculate correlations
                    this.calculateCorrelations();
                    
                    // Detect anomalies
                    this.detectAnomalies();
                    
                    // Check alerts
                    alertSystem.checkAlerts(state.data);
                    
                    // Update UI
                    this.updateAllDisplays();
                    
                    this.lastUpdate = new Date();
                    console.log('✅ Data update complete');
                    
                } catch (error) {
                    console.error('Error fetching data:', error);
                } finally {
                    this.updateInProgress = false;
                }
            }
            
            calculateCorrelations() {
                const indicators = Object.keys(state.data);
                const correlationMatrix = {};
                
                indicators.forEach(id1 => {
                    correlationMatrix[id1] = {};
                    indicators.forEach(id2 => {
                        if (id1 === id2) {
                            correlationMatrix[id1][id2] = 1;
                        } else {
                            const corr = this.pearsonCorrelation(
                                state.data[id1].observations,
                                state.data[id2].observations
                            );
                            correlationMatrix[id1][id2] = corr;
                        }
                    });
                });
                
                state.correlations = correlationMatrix;
            }
            
            pearsonCorrelation(obs1, obs2) {
                // Match observations by date
                const matched = [];
                obs1.forEach(o1 => {
                    const o2 = obs2.find(o => o.date === o1.date);
                    if (o2) {
                        matched.push([o1.value, o2.value]);
                    }
                });
                
                if (matched.length < 2) return 0;
                
                const n = matched.length;
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
                
                matched.forEach(([x, y]) => {
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                    sumY2 += y * y;
                });
                
                const numerator = n * sumXY - sumX * sumY;
                const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
                
                return denominator === 0 ? 0 : numerator / denominator;
            }
            
            detectAnomalies() {
                Object.entries(state.data).forEach(([id, data]) => {
                    if (!data.observations || data.observations.length < 30) return;
                    
                    const values = data.observations.map(o => o.value);
                    const mean = values.reduce((a, b) => a + b, 0) / values.length;
                    const stdDev = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / values.length);
                    
                    const latest = values[values.length - 1];
                    const zScore = Math.abs((latest - mean) / stdDev);
                    
                    if (zScore > 3) {
                        state.anomalies[id] = {
                            zScore,
                            direction: latest > mean ? 'above' : 'below',
                            severity: zScore > 4 ? 'extreme' : 'high'
                        };
                    }
                });
            }
            
            setupAutoUpdate() {
                // Check if we should update
                const checkUpdate = () => {
                    const now = new Date();
                    const day = now.getDay();
                    const hour = now.getHours();
                    
                    if (CONFIG.AUTO_UPDATE_DAYS.includes(day) && hour === CONFIG.AUTO_UPDATE_HOUR) {
                        const lastUpdateDate = this.lastUpdate ? new Date(this.lastUpdate) : null;
                        
                        if (!lastUpdateDate || now - lastUpdateDate > 3600000) { // More than 1 hour since last update
                            this.fetchAllData();
                        }
                    }
                };
                
                // Check every hour
                setInterval(checkUpdate, 3600000);
                
                // Initial check
                checkUpdate();
            }
            
            updateAllDisplays() {
                // Update active tab
                const activeTabElement = document.querySelector('.tab-content.active');
                if (activeTabElement) {
                    const tabId = activeTabElement.id;
                    this.updateTabContent(tabId);
                }
                
                // Update header stats
                this.updateHeaderStats();
            }
            
            updateHeaderStats() {
                // Update any header statistics if needed
            }
            
            updateTabContent(tabId) {
                const tab = state.tabs.find(t => t.id === tabId);
                if (!tab) return;
                
                const container = document.getElementById(`${tabId}-content`);
                if (!container) return;
                
                // Clear existing content
                container.innerHTML = '';
                
                // Special tabs
                if (tabId === 'heatmap') {
                    this.renderHeatmap(container);
                } else if (tabId === 'correlations') {
                    this.renderCorrelations(container);
                } else if (tabId === 'anomalies') {
                    this.renderAnomalies(container);
                } else {
                    // Regular indicator tabs
                    this.renderIndicatorTab(container, tab);
                }
            }
            
            renderIndicatorTab(container, tab) {
                // Add indicator manager
                const managerDiv = document.createElement('div');
                managerDiv.className = 'indicator-manager';
                managerDiv.innerHTML = `
                    <h3>Manage Indicators</h3>
                    <input type="text" class="indicator-search" placeholder="Search indicators..." 
                           onkeyup="dataManager.filterIndicators(this.value, '${tab.id}')">
                    <div class="indicator-list" id="${tab.id}-indicators"></div>
                `;
                container.appendChild(managerDiv);
                
                // Render indicator list
                this.renderIndicatorList(tab.id);
                
                // Add main chart
                const chartDiv = document.createElement('div');
                chartDiv.className = 'advanced-chart-container';
                chartDiv.innerHTML = `
                    <div class="chart-toolbar">
                        <div class="timeframe-selector">
                            ${Object.keys(CONFIG.TIMEFRAMES).map(tf => `
                                <button class="timeframe-btn ${tf === state.selectedTimeframe ? 'active' : ''}" 
                                        onclick="chartManager.setTimeframe('${tf}')">${tf}</button>
                            `).join('')}
                        </div>
                        <div class="chart-tools">
                            <button class="tool-btn" onclick="chartManager.toggleComparison()">
                                📊 Compare
                            </button>
                            <button class="tool-btn" onclick="chartManager.toggleChartType()">
                                📈 Chart Type
                            </button>
                            <button class="tool-btn" onclick="chartManager.addIndicator()">
                                ➕ Add Indicator
                            </button>
                        </div>
                    </div>
                    <div id="${tab.id}-chart" style="height: 500px;"></div>
                    <div class="comparison-panel" id="${tab.id}-comparison"></div>
                `;
                container.appendChild(chartDiv);
                
                // Render chart
                this.renderChart(tab.id);
                
                // Add data grid
                const gridDiv = document.createElement('div');
                gridDiv.className = 'data-grid';
                gridDiv.id = `${tab.id}-grid`;
                container.appendChild(gridDiv);
                
                // Render data cards
                this.renderDataCards(tab.id);
            }
            
            renderIndicatorList(tabId) {
                const container = document.getElementById(`${tabId}-indicators`);
                if (!container) return;
                
                const tab = state.tabs.find(t => t.id === tabId);
                if (!tab) return;
                
                container.innerHTML = '';
                
                Object.entries(state.indicators).forEach(([id, config]) => {
                    const isInTab = tab.indicators === 'all' || tab.indicators.includes(id);
                    
                    const indicatorDiv = document.createElement('div');
                    indicatorDiv.className = `indicator-item ${isInTab ? 'selected' : ''}`;
                    indicatorDiv.innerHTML = `
                        <span>${config.name}</span>
                        <input type="checkbox" ${isInTab ? 'checked' : ''} 
                               onchange="dataManager.toggleIndicatorInTab('${tabId}', '${id}', this.checked)">
                    `;
                    
                    container.appendChild(indicatorDiv);
                });
            }
            
            toggleIndicatorInTab(tabId, indicatorId, enabled) {
                const tab = state.tabs.find(t => t.id === tabId);
                if (!tab) return;
                
                if (tab.indicators === 'all') {
                    tab.indicators = [];
                }
                
                if (enabled) {
                    if (!tab.indicators.includes(indicatorId)) {
                        tab.indicators.push(indicatorId);
                    }
                } else {
                    tab.indicators = tab.indicators.filter(id => id !== indicatorId);
                }
                
                state.saveState();
                this.updateTabContent(tabId);
            }
            
            renderChart(tabId) {
                const tab = state.tabs.find(t => t.id === tabId);
                if (!tab || tab.indicators === 'special') return;
                
                const indicators = tab.indicators === 'all' 
                    ? Object.keys(state.indicators) 
                    : tab.indicators;
                
                const traces = [];
                
                indicators.forEach(id => {
                    const data = state.data[id];
                    if (!data || !data.observations) return;
                    
                    const trace = {
                        x: data.observations.map(o => o.date),
                        y: data.observations.map(o => o.value),
                        type: state.chartType,
                        mode: 'lines',
                        name: state.indicators[id]?.name || id,
                        line: { width: 2 }
                    };
                    
                    traces.push(trace);
                });
                
                const layout = {
                    title: `${tab.name.replace(/[^a-zA-Z\s]/g, '')} Chart`,
                    paper_bgcolor: 'rgba(0, 0, 0, 0)',
                    plot_bgcolor: 'rgba(0, 0, 0, 0.3)',
                    font: { color: '#fff' },
                    xaxis: {
                        gridcolor: 'rgba(255, 255, 255, 0.1)',
                        tickfont: { color: '#888' }
                    },
                    yaxis: {
                        gridcolor: 'rgba(255, 255, 255, 0.1)',
                        tickfont: { color: '#888' }
                    },
                    showlegend: true,
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    }
                };
                
                Plotly.newPlot(`${tabId}-chart`, traces, layout, { responsive: true });
            }
            
            renderDataCards(tabId) {
                const container = document.getElementById(`${tabId}-grid`);
                if (!container) return;
                
                const tab = state.tabs.find(t => t.id === tabId);
                if (!tab || tab.indicators === 'special') return;
                
                container.innerHTML = '';
                
                const indicators = tab.indicators === 'all' 
                    ? Object.keys(state.indicators) 
                    : tab.indicators;
                
                indicators.forEach(id => {
                    const data = state.data[id];
                    if (!data) return;
                    
                    const card = document.createElement('div');
                    card.className = 'data-card';
                    
                    // Check for anomaly
                    const anomaly = state.anomalies[id];
                    if (anomaly) {
                        const badge = document.createElement('div');
                        badge.className = 'anomaly-badge';
                        badge.textContent = `Anomaly: ${anomaly.severity}`;
                        card.appendChild(badge);
                    }
                    
                    // Add card actions
                    const actions = document.createElement('div');
                    actions.className = 'card-actions';
                    actions.innerHTML = `
                        <button class="action-btn" onclick="dataManager.editIndicatorName('${id}')">✏️</button>
                        <button class="action-btn" onclick="dataManager.viewDetails('${id}')">📊</button>
                        <button class="action-btn" onclick="alertSystem.addAlert('${id}')">🔔</button>
                    `;
                    card.appendChild(actions);
                    
                    // Card content
                    const indicatorName = state.indicators[id]?.name || id;
                    const changeClass = data.DoD > 0 ? 'positive' : 'negative';
                    
                    card.innerHTML += `
                        <h3>${indicatorName}</h3>
                        <div style="font-size: 2rem; font-weight: bold; margin: 1rem 0;">
                            ${data.current ? data.current.toFixed(2) : 'N/A'}
                        </div>
                        <div class="${changeClass}">
                            DoD: ${data.DoD ? data.DoD.toFixed(2) : 0}%
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.875rem;">
                            WoW: ${data.WoW ? data.WoW.toFixed(2) : 0}% | 
                            MoM: ${data.MoM ? data.MoM.toFixed(2) : 0}% | 
                            YoY: ${data.YoY ? data.YoY.toFixed(2) : 0}%
                        </div>
                        ${data.trend ? `
                            <div style="margin-top: 0.5rem; font-size: 0.875rem;">
                                Trend: <span class="${data.trend.type === 'bullish' ? 'positive' : 'negative'}">
                                    ${data.trend.type} (${data.trend.strength.toFixed(2)})
                                </span>
                            </div>
                        ` : ''}
                        ${data.momentum ? `
                            <div style="margin-top: 0.5rem; font-size: 0.875rem;">
                                RSI: ${data.momentum.rsi.toFixed(1)} (${data.momentum.interpretation})
                            </div>
                        ` : ''}
                    `;
                    
                    container.appendChild(card);
                });
            }
            
            renderHeatmap(container) {
                container.innerHTML = '<h2>Market Heatmap</h2>';
                
                const heatmapDiv = document.createElement('div');
                heatmapDiv.className = 'heatmap-grid';
                
                // Headers
                const headers = ['Indicator', '1D', '1W', '1M', '3M', '1Y', 'Trend', 'RSI'];
                headers.forEach(header => {
                    const cell = document.createElement('div');
                    cell.className = 'heatmap-cell header';
                    cell.textContent = header;
                    heatmapDiv.appendChild(cell);
                });
                
                // Data rows
                Object.entries(state.data).forEach(([id, data]) => {
                    if (!data) return;
                    
                    // Indicator name
                    const nameCell = document.createElement('div');
                    nameCell.className = 'heatmap-cell';
                    nameCell.textContent = state.indicators[id]?.name || id;
                    nameCell.style.textAlign = 'left';
                    nameCell.style.fontWeight = 'bold';
                    heatmapDiv.appendChild(nameCell);
                    
                    // Changes
                    const changes = [data.DoD, data.WoW, data.MoM, data.QoQ, data.YoY];
                    changes.forEach(change => {
                        const cell = document.createElement('div');
                        cell.className = `heatmap-cell ${this.getHeatmapClass(change)}`;
                        cell.textContent = change ? `${change.toFixed(1)}%` : '0%';
                        heatmapDiv.appendChild(cell);
                    });
                    
                    // Trend
                    const trendCell = document.createElement('div');
                    trendCell.className = 'heatmap-cell';
                    if (data.trend) {
                        trendCell.className += data.trend.type === 'bullish' ? ' heat-moderate-positive' : ' heat-moderate-negative';
                        trendCell.textContent = data.trend.type;
                    } else {
                        trendCell.textContent = '-';
                    }
                    heatmapDiv.appendChild(trendCell);
                    
                    // RSI
                    const rsiCell = document.createElement('div');
                    rsiCell.className = 'heatmap-cell';
                    if (data.momentum) {
                        const rsi = data.momentum.rsi;
                        if (rsi > 70) {
                            rsiCell.className += ' heat-high-negative';
                        } else if (rsi < 30) {
                            rsiCell.className += ' heat-high-positive';
                        } else {
                            rsiCell.className += ' heat-neutral';
                        }
                        rsiCell.textContent = rsi.toFixed(0);
                    } else {
                        rsiCell.textContent = '-';
                    }
                    heatmapDiv.appendChild(rsiCell);
                });
                
                container.appendChild(heatmapDiv);
            }
            
            getHeatmapClass(value) {
                if (!value) return 'heat-neutral';
                if (value < -10) return 'heat-extreme-negative';
                if (value < -5) return 'heat-high-negative';
                if (value < -2) return 'heat-moderate-negative';
                if (value < 0) return 'heat-low-negative';
                if (value < 2) return 'heat-neutral';
                if (value < 5) return 'heat-moderate-positive';
                if (value < 10) return 'heat-high-positive';
                return 'heat-extreme-positive';
            }
            
            renderCorrelations(container) {
                container.innerHTML = '<h2>Correlation Matrix</h2>';
                
                const tableDiv = document.createElement('div');
                tableDiv.className = 'correlation-matrix';
                
                const table = document.createElement('table');
                table.className = 'correlation-table';
                
                // Headers
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = '<th></th>';
                Object.keys(state.correlations).forEach(id => {
                    const th = document.createElement('th');
                    th.textContent = state.indicators[id]?.name || id;
                    th.style.fontSize = '0.75rem';
                    headerRow.appendChild(th);
                });
                table.appendChild(headerRow);
                
                // Data rows
                Object.entries(state.correlations).forEach(([id1, correlations]) => {
                    const row = document.createElement('tr');
                    const th = document.createElement('th');
                    th.textContent = state.indicators[id1]?.name || id1;
                    row.appendChild(th);
                    
                    Object.entries(correlations).forEach(([id2, corr]) => {
                        const td = document.createElement('td');
                        td.className = 'correlation-cell';
                        
                        if (corr > 0.7) td.className += ' correlation-positive-high';
                        else if (corr > 0.3) td.className += ' correlation-positive-medium';
                        else if (corr > 0) td.className += ' correlation-positive-low';
                        else if (corr > -0.3) td.className += ' correlation-negative-low';
                        else if (corr > -0.7) td.className += ' correlation-negative-medium';
                        else td.className += ' correlation-negative-high';
                        
                        td.textContent = corr.toFixed(2);
                        row.appendChild(td);
                    });
                    
                    table.appendChild(row);
                });
                
                tableDiv.appendChild(table);
                container.appendChild(tableDiv);
            }
            
            renderAnomalies(container) {
                container.innerHTML = '<h2>Anomaly Detection</h2>';
                
                const anomalyList = document.createElement('div');
                anomalyList.className = 'data-grid';
                
                Object.entries(state.anomalies).forEach(([id, anomaly]) => {
                    const data = state.data[id];
                    if (!data) return;
                    
                    const card = document.createElement('div');
                    card.className = 'data-card';
                    card.style.border = `2px solid ${anomaly.severity === 'extreme' ? 'var(--danger-red)' : 'var(--warning-orange)'}`;
                    
                    card.innerHTML = `
                        <div class="anomaly-badge">${anomaly.severity.toUpperCase()}</div>
                        <h3>${state.indicators[id]?.name || id}</h3>
                        <div style="font-size: 2rem; font-weight: bold; margin: 1rem 0;">
                            ${data.current ? data.current.toFixed(2) : 'N/A'}
                        </div>
                        <div>Z-Score: ${anomaly.zScore.toFixed(2)}</div>
                        <div>Direction: ${anomaly.direction}</div>
                        <div style="margin-top: 1rem;">
                            <button class="export-btn" onclick="dataManager.investigateAnomaly('${id}')">
                                Investigate
                            </button>
                        </div>
                    `;
                    
                    anomalyList.appendChild(card);
                });
                
                if (Object.keys(state.anomalies).length === 0) {
                    anomalyList.innerHTML = '<p style="text-align: center; padding: 2rem;">No anomalies detected</p>';
                }
                
                container.appendChild(anomalyList);
            }
            
            editIndicatorName(id) {
                const currentName = state.indicators[id]?.name || id;
                const newName = prompt('Enter new name:', currentName);
                
                if (newName && newName !== currentName) {
                    state.indicators[id].name = newName;
                    state.saveState();
                    this.updateAllDisplays();
                }
            }
            
            viewDetails(id) {
                // Open detailed view modal
                console.log('View details for', id);
            }
            
            investigateAnomaly(id) {
                // Open anomaly investigation modal
                console.log('Investigate anomaly for', id);
            }
        }
        
        const dataManager = new DataManager();
        
        // ====================================
        // CHART MANAGER
        // ====================================
        class ChartManager {
            setTimeframe(timeframe) {
                state.selectedTimeframe = timeframe;
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.textContent === timeframe);
                });
                dataManager.updateAllDisplays();
            }
            
            toggleComparison() {
                state.comparisonMode = !state.comparisonMode;
                dataManager.updateAllDisplays();
            }
            
            toggleChartType() {
                const types = ['line', 'bar', 'candlestick', 'area'];
                const currentIndex = types.indexOf(state.chartType);
                state.chartType = types[(currentIndex + 1) % types.length];
                dataManager.updateAllDisplays();
            }
            
            addIndicator() {
                // Open indicator selector modal
                console.log('Add indicator');
            }
        }
        
        const chartManager = new ChartManager();
        
        // ====================================
        // EXPORT FUNCTIONS
        // ====================================
        async function exportToPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF();
            
            pdf.setFontSize(20);
            pdf.text('FRED Financial Report', 20, 20);
            
            pdf.setFontSize(12);
            pdf.text(`Generated: ${new Date().toLocaleString()}`, 20, 30);
            
            let y = 50;
            Object.entries(state.data).forEach(([id, data]) => {
                if (y > 250) {
                    pdf.addPage();
                    y = 20;
                }
                
                pdf.setFontSize(14);
                pdf.text(state.indicators[id]?.name || id, 20, y);
                y += 10;
                
                pdf.setFontSize(10);
                pdf.text(`Current: ${data.current?.toFixed(2) || 'N/A'}`, 20, y);
                y += 7;
                pdf.text(`Changes - DoD: ${data.DoD?.toFixed(2)}%, WoW: ${data.WoW?.toFixed(2)}%, MoM: ${data.MoM?.toFixed(2)}%, YoY: ${data.YoY?.toFixed(2)}%`, 20, y);
                y += 15;
            });
            
            pdf.save('fred-report.pdf');
        }
        
        async function exportToExcel() {
            const workbook = XLSX.utils.book_new();
            
            // Create main data sheet
            const wsData = [];
            wsData.push(['Indicator', 'Current', 'DoD %', 'WoW %', 'MoM %', 'QoQ %', 'YoY %', 'Trend', 'RSI']);
            
            Object.entries(state.data).forEach(([id, data]) => {
                wsData.push([
                    state.indicators[id]?.name || id,
                    data.current || 0,
                    data.DoD || 0,
                    data.WoW || 0,
                    data.MoM || 0,
                    data.QoQ || 0,
                    data.YoY || 0,
                    data.trend?.type || '',
                    data.momentum?.rsi || 0
                ]);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(workbook, ws, 'Data');
            
            // Create correlations sheet
            if (Object.keys(state.correlations).length > 0) {
                const corrData = [];
                const headers = [''];
                Object.keys(state.correlations).forEach(id => {
                    headers.push(state.indicators[id]?.name || id);
                });
                corrData.push(headers);
                
                Object.entries(state.correlations).forEach(([id1, correlations]) => {
                    const row = [state.indicators[id1]?.name || id1];
                    Object.values(correlations).forEach(corr => {
                        row.push(corr);
                    });
                    corrData.push(row);
                });
                
                const corrWs = XLSX.utils.aoa_to_sheet(corrData);
                XLSX.utils.book_append_sheet(workbook, corrWs, 'Correlations');
            }
            
            XLSX.writeFile(workbook, 'fred-data.xlsx');
        }
        
        async function exportToCSV() {
            let csv = 'Indicator,Current,DoD %,WoW %,MoM %,QoQ %,YoY %\n';
            
            Object.entries(state.data).forEach(([id, data]) => {
                csv += `"${state.indicators[id]?.name || id}",${data.current || 0},${data.DoD || 0},${data.WoW || 0},${data.MoM || 0},${data.QoQ || 0},${data.YoY || 0}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fred-data.csv';
            a.click();
        }
        
        async function exportToJSON() {
            const exportData = {
                timestamp: new Date().toISOString(),
                data: state.data,
                indicators: state.indicators,
                correlations: state.correlations,
                anomalies: state.anomalies
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fred-data.json';
            a.click();
        }
        
        // ====================================
        // UI FUNCTIONS
        // ====================================
        function initializeTabs() {
            const tabsNav = document.getElementById('tabsNav');
            const tabContents = document.getElementById('tabContents');
            
            tabsNav.innerHTML = '';
            tabContents.innerHTML = '';
            
            state.tabs.forEach((tab, index) => {
                // Create tab button
                const tabBtn = document.createElement('button');
                tabBtn.className = `tab-btn ${index === 0 ? 'active' : ''}`;
                tabBtn.dataset.tab = tab.id;
                tabBtn.innerHTML = `
                    ${tab.name}
                    <span class="edit-tab" onclick="editTab('${tab.id}')">✏️</span>
                `;
                tabBtn.onclick = (e) => {
                    if (!e.target.classList.contains('edit-tab')) {
                        switchTab(tab.id);
                    }
                };
                tabsNav.appendChild(tabBtn);
                
                // Create tab content
                const tabContent = document.createElement('div');
                tabContent.className = `tab-content ${index === 0 ? 'active' : ''}`;
                tabContent.id = tab.id;
                
                const contentDiv = document.createElement('div');
                contentDiv.id = `${tab.id}-content`;
                tabContent.appendChild(contentDiv);
                
                tabContents.appendChild(tabContent);
            });
        }
        
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabId);
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === tabId);
            });
            
            state.activeTab = tabId;
            dataManager.updateTabContent(tabId);
        }
        
        function editTab(tabId) {
            const tab = state.tabs.find(t => t.id === tabId);
            if (!tab) return;
            
            const newName = prompt('Enter new tab name:', tab.name);
            if (newName && newName !== tab.name) {
                tab.name = newName;
                state.saveState();
                initializeTabs();
            }
        }
        
        function toggleAlertManager() {
            const manager = document.getElementById('alertManager');
            manager.classList.toggle('active');
            if (manager.classList.contains('active')) {
                alertSystem.updateAlertDisplay();
            }
        }
        
        function toggleExportPanel() {
            const panel = document.getElementById('exportPanel');
            panel.classList.toggle('active');
        }
        
        function createNewAlert() {
            const indicators = Object.entries(state.indicators).map(([id, config]) => 
                `<option value="${id}">${config.name}</option>`
            ).join('');
            
            const html = `
                <div style="padding: 1rem;">
                    <h3>Create New Alert</h3>
                    <select id="alertIndicator" style="width: 100%; margin: 0.5rem 0; padding: 0.5rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff;">
                        ${indicators}
                    </select>
                    <select id="alertCondition" style="width: 100%; margin: 0.5rem 0; padding: 0.5rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff;">
                        <option value="above">Above</option>
                        <option value="below">Below</option>
                        <option value="change">Change %</option>
                        <option value="crossover">Crossover</option>
                    </select>
                    <input type="number" id="alertThreshold" placeholder="Threshold value" style="width: 100%; margin: 0.5rem 0; padding: 0.5rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff;">
                    <button onclick="saveNewAlert()" style="width: 100%; padding: 0.75rem; background: var(--primary-green); color: #000; border: none; border-radius: 8px; cursor: pointer; margin-top: 1rem;">Create Alert</button>
                </div>
            `;
            
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    ${html}
                </div>
            `;
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            document.body.appendChild(modal);
        }
        
        function saveNewAlert() {
            const indicator = document.getElementById('alertIndicator').value;
            const condition = document.getElementById('alertCondition').value;
            const threshold = parseFloat(document.getElementById('alertThreshold').value);
            
            if (indicator && condition && !isNaN(threshold)) {
                alertSystem.addAlert(indicator, condition, threshold);
                document.querySelector('.modal').remove();
            }
        }
        
        function openCustomizeDashboard() {
            const modal = document.getElementById('customizeModal');
            const content = document.getElementById('customizeContent');
            
            content.innerHTML = `
                <h3>Dashboard Layouts</h3>
                <div style="margin-bottom: 2rem;">
                    ${Object.keys(state.customLayouts).map(name => `
                        <button class="export-btn" onclick="applyLayout('${name}')">${name}</button>
                    `).join('')}
                </div>
                
                <h3>Add New Tab</h3>
                <input type="text" id="newTabName" placeholder="Tab name" style="width: 100%; margin: 0.5rem 0; padding: 0.5rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff;">
                <button onclick="addNewTab()" style="width: 100%; padding: 0.75rem; background: var(--primary-green); color: #000; border: none; border-radius: 8px; cursor: pointer; margin-top: 1rem;">Add Tab</button>
                
                <h3 style="margin-top: 2rem;">Manage Indicators</h3>
                <button onclick="addNewIndicator()" style="width: 100%; padding: 0.75rem; background: var(--primary-blue); color: #000; border: none; border-radius: 8px; cursor: pointer;">Add Custom Indicator</button>
            `;
            
            modal.classList.add('active');
        }
        
        function closeCustomizeModal() {
            document.getElementById('customizeModal').classList.remove('active');
        }
        
        function applyLayout(layoutName) {
            const layout = state.customLayouts[layoutName];
            if (layout) {
                // Apply layout logic
                console.log('Applying layout:', layoutName);
                closeCustomizeModal();
            }
        }
        
        function addNewTab() {
            const name = document.getElementById('newTabName').value;
            if (name) {
                const newTab = {
                    id: name.toLowerCase().replace(/\s+/g, '-'),
                    name: name,
                    indicators: []
                };
                state.tabs.push(newTab);
                state.saveState();
                initializeTabs();
                closeCustomizeModal();
            }
        }
        
        function addNewIndicator() {
            const symbol = prompt('Enter FRED symbol (e.g., CPILFESL for Core CPI):');
            if (symbol) {
                const name = prompt('Enter display name:');
                if (name) {
                    state.indicators[symbol] = {
                        name: name,
                        category: 'custom',
                        enabled: true
                    };
                    state.saveState();
                    dataManager.fetchAllData();
                }
            }
        }
        
        function forceRefreshAllData() {
            dataManager.fetchAllData();
        }
        
        // ====================================
        // INITIALIZATION
        // ====================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 Initializing Ultimate FRED Platform...');
            
            // Initialize UI
            initializeTabs();
            
            // Load initial data
            dataManager.fetchAllData();
            
            // Set up periodic refresh (every 5 minutes)
            setInterval(() => {
                dataManager.fetchAllData();
            }, 5 * 60 * 1000);
            
            console.log('✅ Platform ready');
        });
        
        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
