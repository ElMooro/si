<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>OpenBB Financial Dashboard - Real Data</title>
   
   <!-- Required Libraries -->
   <script src="https://cdn.plot.ly/plotly-latest.min.js" charset="utf-8"></script>
   
   <style>
       * { margin: 0; padding: 0; box-sizing: border-box; }
       
       body {
           font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
           background: #f5f5f5;
           color: #333;
           min-height: 100vh;
       }
       
       /* Header */
       .header {
           background: #fff;
           padding: 1rem 2rem;
           border-bottom: 1px solid #e0e0e0;
           box-shadow: 0 2px 4px rgba(0,0,0,0.1);
           position: sticky;
           top: 0;
           z-index: 1000;
       }
       
       .header-content {
           display: flex;
           justify-content: space-between;
           align-items: center;
           max-width: 1800px;
           margin: 0 auto;
       }
       
       .logo {
           font-size: 1.5rem;
           font-weight: bold;
           color: #1565c0;
       }
       
       .api-status {
           display: flex;
           gap: 1rem;
           align-items: center;
       }
       
       .api-indicator {
           display: flex;
           align-items: center;
           gap: 0.5rem;
           padding: 0.5rem 1rem;
           background: #f0f0f0;
           border-radius: 20px;
           font-size: 0.875rem;
       }
       
       .status-dot {
           width: 8px;
           height: 8px;
           border-radius: 50%;
       }
       
       .status-dot.connected { background: #4caf50; }
       .status-dot.error { background: #f44336; }
       .status-dot.loading { background: #ff9800; }
       
       /* Container */
       .container {
           max-width: 1800px;
           margin: 0 auto;
           padding: 2rem;
       }
       
       /* Search Bar */
       .search-container {
           margin-bottom: 2rem;
           position: relative;
       }
       
       .search-input {
           width: 100%;
           padding: 1rem 1.5rem;
           background: #fff;
           border: 2px solid #e0e0e0;
           border-radius: 8px;
           font-size: 1rem;
           transition: all 0.3s;
       }
       
       .search-input:focus {
           outline: none;
           border-color: #1565c0;
           box-shadow: 0 0 0 3px rgba(21, 101, 192, 0.1);
       }
       
       .search-results {
           position: absolute;
           top: 100%;
           left: 0;
           right: 0;
           background: #fff;
           border: 1px solid #e0e0e0;
           border-radius: 8px;
           margin-top: 0.5rem;
           max-height: 400px;
           overflow-y: auto;
           display: none;
           z-index: 1000;
           box-shadow: 0 4px 12px rgba(0,0,0,0.1);
       }
       
       .search-results.active {
           display: block;
       }
       
       .search-result-item {
           padding: 1rem 1.5rem;
           cursor: pointer;
           transition: all 0.2s;
           border-bottom: 1px solid #f0f0f0;
           display: flex;
           justify-content: space-between;
           align-items: center;
       }
       
       .search-result-item:hover {
           background: #f5f5f5;
       }
       
       .search-result-name {
           font-weight: 500;
           color: #333;
       }
       
       .search-result-symbol {
           font-size: 0.875rem;
           color: #666;
           margin-top: 0.25rem;
       }
       
       .search-result-value {
           font-size: 1.125rem;
           font-weight: bold;
           color: #1565c0;
       }
       
       /* Chart Container */
       .chart-container {
           background: #fff;
           border-radius: 8px;
           padding: 1.5rem;
           margin-bottom: 2rem;
           box-shadow: 0 2px 8px rgba(0,0,0,0.1);
       }
       
       .chart-header {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 1rem;
           padding-bottom: 1rem;
           border-bottom: 1px solid #e0e0e0;
       }
       
       .chart-title {
           font-size: 1.25rem;
           font-weight: 600;
           color: #333;
       }
       
       .chart-controls {
           display: flex;
           gap: 0.5rem;
       }
       
       .chart-btn {
           padding: 0.5rem 1rem;
           background: #fff;
           border: 1px solid #e0e0e0;
           border-radius: 4px;
           color: #666;
           cursor: pointer;
           font-size: 0.875rem;
           transition: all 0.2s;
       }
       
       .chart-btn:hover {
           background: #f5f5f5;
           border-color: #1565c0;
           color: #1565c0;
       }
       
       .chart-btn.active {
           background: #1565c0;
           color: #fff;
           border-color: #1565c0;
       }
       
       /* Data Info Box */
       .data-info {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
           gap: 1rem;
           margin-bottom: 1rem;
           padding: 1rem;
           background: #f8f9fa;
           border-radius: 4px;
       }
       
       .data-info-item {
           display: flex;
           flex-direction: column;
       }
       
       .data-info-label {
           font-size: 0.75rem;
           color: #666;
           text-transform: uppercase;
           margin-bottom: 0.25rem;
       }
       
       .data-info-value {
           font-size: 1.25rem;
           font-weight: bold;
           color: #333;
       }
       
       #mainChart {
           height: 500px;
           background: #fff;
       }
       
       /* Watchlist */
       .watchlist-container {
           background: #fff;
           border-radius: 8px;
           padding: 1.5rem;
           box-shadow: 0 2px 8px rgba(0,0,0,0.1);
       }
       
       .watchlist-header {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 1.5rem;
           padding-bottom: 1rem;
           border-bottom: 1px solid #e0e0e0;
       }
       
       .watchlist-title {
           font-size: 1.25rem;
           font-weight: 600;
           color: #333;
       }
       
       .watchlist-table {
           width: 100%;
           border-collapse: collapse;
       }
       
       .watchlist-table thead {
           background: #f8f9fa;
       }
       
       .watchlist-table th {
           padding: 0.75rem;
           text-align: left;
           font-size: 0.75rem;
           color: #666;
           font-weight: 600;
           text-transform: uppercase;
           border-bottom: 2px solid #e0e0e0;
       }
       
       .watchlist-table td {
           padding: 0.75rem;
           border-bottom: 1px solid #f0f0f0;
           font-size: 0.875rem;
       }
       
       .watchlist-table tbody tr {
           cursor: pointer;
           transition: all 0.2s;
       }
       
       .watchlist-table tbody tr:hover {
           background: #f8f9fa;
       }
       
       .watchlist-table tbody tr.selected {
           background: #e3f2fd;
       }
       
       .positive { color: #4caf50; }
       .negative { color: #f44336; }
       
       .remove-btn {
           background: #fff;
           border: 1px solid #e0e0e0;
           color: #666;
           padding: 0.25rem 0.75rem;
           border-radius: 4px;
           cursor: pointer;
           font-size: 0.75rem;
           transition: all 0.2s;
       }
       
       .remove-btn:hover {
           background: #ffebee;
           border-color: #f44336;
           color: #f44336;
       }
       
       .empty-watchlist {
           text-align: center;
           padding: 3rem;
           color: #999;
       }
       
       .loading-spinner {
           display: inline-block;
           width: 20px;
           height: 20px;
           border: 2px solid #f3f3f3;
           border-top: 2px solid #1565c0;
           border-radius: 50%;
           animation: spin 1s linear infinite;
       }
       
       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }
       
       /* Error message */
       .error-message {
           background: #ffebee;
           color: #c62828;
           padding: 1rem;
           border-radius: 4px;
           margin-bottom: 1rem;
           display: none;
       }
       
       .error-message.active {
           display: block;
       }
   </style>
</head>
<body>
   <header class="header">
       <div class="header-content">
           <div class="logo">ðŸ“Š OpenBB Financial Dashboard</div>
           <div class="api-status">
               <div class="api-indicator">
                   <div class="status-dot loading" id="fredStatus"></div>
                   <span>FRED</span>
               </div>
               <div class="api-indicator">
                   <div class="status-dot loading" id="dataStatus"></div>
                   <span>Data API</span>
               </div>
           </div>
       </div>
   </header>
   
   <div class="container">
       <!-- Error Message -->
       <div class="error-message" id="errorMessage"></div>
       
       <!-- Search Bar -->
       <div class="search-container">
           <input 
               type="text" 
               class="search-input" 
               id="searchInput" 
               placeholder="Search indicators: Try BAMLH0A2HYB, DXY, VIX, SOFR, DGS10, SP500..."
           >
           <div class="search-results" id="searchResults"></div>
       </div>
       
       <!-- Chart -->
       <div class="chart-container">
           <div class="chart-header">
               <div class="chart-title" id="chartTitle">Select an indicator to view data</div>
               <div class="chart-controls">
                   <button class="chart-btn" data-range="1M">1M</button>
                   <button class="chart-btn" data-range="3M">3M</button>
                   <button class="chart-btn" data-range="6M">6M</button>
                   <button class="chart-btn" data-range="YTD">YTD</button>
                   <button class="chart-btn active" data-range="1Y">1Y</button>
                   <button class="chart-btn" data-range="5Y">5Y</button>
                   <button class="chart-btn" data-range="10Y">10Y</button>
                   <button class="chart-btn" data-range="ALL">All</button>
               </div>
           </div>
           
           <div class="data-info" id="dataInfo" style="display: none;">
               <div class="data-info-item">
                   <span class="data-info-label">Latest Value</span>
                   <span class="data-info-value" id="latestValue">--</span>
               </div>
               <div class="data-info-item">
                   <span class="data-info-label">Date</span>
                   <span class="data-info-value" id="latestDate">--</span>
               </div>
               <div class="data-info-item">
                   <span class="data-info-label">MoM Change</span>
                   <span class="data-info-value" id="momChange">--</span>
               </div>
               <div class="data-info-item">
                   <span class="data-info-label">QoQ Change</span>
                   <span class="data-info-value" id="qoqChange">--</span>
               </div>
               <div class="data-info-item">
                   <span class="data-info-label">YoY Change</span>
                   <span class="data-info-value" id="yoyChange">--</span>
               </div>
               <div class="data-info-item">
                   <span class="data-info-label">52W Range</span>
                   <span class="data-info-value" id="range52w">--</span>
               </div>
           </div>
           
           <div id="mainChart"></div>
       </div>
       
       <!-- Watchlist -->
       <div class="watchlist-container">
           <div class="watchlist-header">
               <div class="watchlist-title">My Watchlist</div>
               <div class="watchlist-controls">
                   <button class="chart-btn" onclick="refreshWatchlist()">Refresh</button>
                   <button class="chart-btn" onclick="clearWatchlist()">Clear All</button>
               </div>
           </div>
           
           <div id="watchlistContent">
               <div class="empty-watchlist">
                   <div style="font-size: 3rem; opacity: 0.3;">ðŸ“Š</div>
                   <div>Your watchlist is empty</div>
                   <div style="margin-top: 0.5rem; font-size: 0.875rem; color: #999;">Search and add indicators to track</div>
               </div>
           </div>
       </div>
   </div>
   
   <script>
       // Configuration
       const FRED_API_KEY = '2f057499936072679d8843d7fce99989'; // Your FRED API key
       const FRED_BASE_URL = 'https://api.stlouisfed.org/fred';
       
       // Your API endpoints
       const API_CONFIG = {
           FRED: {
               baseUrl: 'https://i70jxru6md.execute-api.us-east-1.amazonaws.com/prod/api/v1',
               endpoints: {
                   overview: '/dashboard/overview',
                   iceBofA: '/ice_bofa'
               }
           }
       };
       
       // Common FRED series IDs
       const FRED_SERIES = {
           // ICE BofA Indices
           'BAMLH0A2HYB': 'ICE BofA B US High Yield Index',
           'BAMLH0A2HYBEY': 'ICE BofA B US High Yield Index Effective Yield',
           'BAMLC0A0CM': 'ICE BofA US Corporate Master Index',
           'BAMLH0A0HYM2': 'ICE BofA US High Yield Master II Index',
           'BAMLC0A1CAAA': 'ICE BofA AAA US Corporate Index',
           'BAMLC0A4CBBB': 'ICE BofA BBB US Corporate Index',
           
           // Treasury Yields
           'DGS1': '1-Year Treasury Rate',
           'DGS2': '2-Year Treasury Rate',
           'DGS5': '5-Year Treasury Rate',
           'DGS10': '10-Year Treasury Rate',
           'DGS30': '30-Year Treasury Rate',
           
           // Economic Indicators
           'VIXCLS': 'VIX Volatility Index',
           'SP500': 'S&P 500 Index',
           'DEXUSEU': 'US Dollar to Euro Exchange Rate',
           'DTWEXBGS': 'US Dollar Index (DXY)',
           'SOFR': 'SOFR Rate',
           'EFFR': 'Effective Federal Funds Rate',
           'UNRATE': 'Unemployment Rate',
           'CPIAUCSL': 'Consumer Price Index',
           'GDP': 'Gross Domestic Product',
           'WALCL': 'Fed Balance Sheet Total Assets',
           'RRPONTSYD': 'Overnight Reverse Repo',
           'M2SL': 'M2 Money Supply'
       };
       
       // Global state
       let watchlist = [];
       let selectedIndicator = null;
       let chartData = {};
       let currentRange = '1Y';
       
       // Initialize
       document.addEventListener('DOMContentLoaded', function() {
           // Wait for Plotly to load
           if (typeof Plotly === 'undefined') {
               console.error('Plotly not loaded, loading fallback...');
               // Load Plotly from alternative CDN
               const script = document.createElement('script');
               script.src = 'https://unpkg.com/plotly.js@2.27.0/dist/plotly.min.js';
               script.onload = function() {
                   console.log('Plotly loaded successfully');
                   initializeApp();
               };
               script.onerror = function() {
                   console.error('Failed to load Plotly');
                   showError('Failed to load charting library. Please refresh the page.');
               };
               document.head.appendChild(script);
           } else {
               initializeApp();
           }
       });
       
       function initializeApp() {
           initializeAPIs();
           setupSearch();
           setupChartControls();
           loadWatchlistFromStorage();
           initializeChart();
       }
       
       // Initialize APIs
       async function initializeAPIs() {
           // Check FRED API
           try {
               const response = await fetch(`${FRED_BASE_URL}/series/observations?series_id=DGS10&api_key=${FRED_API_KEY}&file_type=json&limit=1&sort_order=desc`);
               if (response.ok) {
                   document.getElementById('fredStatus').className = 'status-dot connected';
               } else {
                   document.getElementById('fredStatus').className = 'status-dot error';
               }
           } catch (error) {
               document.getElementById('fredStatus').className = 'status-dot error';
           }
           
           // Check your API
           try {
               const response = await fetch(API_CONFIG.FRED.baseUrl + API_CONFIG.FRED.endpoints.overview);
               if (response.ok) {
                   document.getElementById('dataStatus').className = 'status-dot connected';
               } else {
                   document.getElementById('dataStatus').className = 'status-dot error';
               }
           } catch (error) {
               document.getElementById('dataStatus').className = 'status-dot error';
           }
       }
       
       // Setup search
       function setupSearch() {
           const searchInput = document.getElementById('searchInput');
           const searchResults = document.getElementById('searchResults');
           
           let searchTimeout;
           
           searchInput.addEventListener('input', function(e) {
               const query = e.target.value.trim().toUpperCase();
               
               clearTimeout(searchTimeout);
               
               if (query.length < 1) {
                   searchResults.classList.remove('active');
                   return;
               }
               
               searchTimeout = setTimeout(() => {
                   performSearch(query);
               }, 300);
           });
           
           document.addEventListener('click', function(e) {
               if (!e.target.closest('.search-container')) {
                   searchResults.classList.remove('active');
               }
           });
       }
       
       // Perform search
       function performSearch(query) {
           const searchResults = document.getElementById('searchResults');
           
           // Filter FRED series
           const results = Object.entries(FRED_SERIES).filter(([symbol, name]) => 
               symbol.includes(query) || name.toUpperCase().includes(query)
           );
           
           if (results.length === 0) {
               searchResults.innerHTML = '<div class="search-result-item">No indicators found</div>';
           } else {
               searchResults.innerHTML = results.slice(0, 20).map(([symbol, name]) => `
                   <div class="search-result-item" onclick="addToWatchlist('${symbol}', '${name}')">
                       <div>
                           <div class="search-result-name">${name}</div>
                           <div class="search-result-symbol">${symbol}</div>
                       </div>
                       <div class="search-result-value" id="value-${symbol}">
                           <span class="loading-spinner"></span>
                       </div>
                   </div>
               `).join('');
               
               // Fetch current values for search results
               results.forEach(([symbol]) => {
                   fetchLatestValue(symbol);
               });
           }
           
           searchResults.classList.add('active');
       }
       
       // Fetch latest value for a series
       async function fetchLatestValue(symbol) {
           try {
               const response = await fetch(
                   `${FRED_BASE_URL}/series/observations?series_id=${symbol}&api_key=${FRED_API_KEY}&file_type=json&limit=1&sort_order=desc`
               );
               
               if (response.ok) {
                   const data = await response.json();
                   const observations = data.observations;
                   
                   if (observations && observations.length > 0) {
                       const value = parseFloat(observations[0].value);
                       const element = document.getElementById(`value-${symbol}`);
                       if (element) {
                           element.textContent = formatValue(value);
                       }
                   }
               }
           } catch (error) {
               console.error(`Error fetching ${symbol}:`, error);
           }
       }
       
       // Fetch historical data
       async function fetchHistoricalData(symbol, startDate = null) {
           try {
               showError(''); // Clear any previous errors
               
               // Calculate date range
               const endDate = new Date();
               let start = new Date();
               
               if (startDate) {
                   start = new Date(startDate);
               } else {
                   // Default to 10 years of data
                   start.setFullYear(start.getFullYear() - 10);
               }
               
               const params = new URLSearchParams({
                   series_id: symbol,
                   api_key: FRED_API_KEY,
                   file_type: 'json',
                   observation_start: start.toISOString().split('T')[0],
                   observation_end: endDate.toISOString().split('T')[0],
                   sort_order: 'asc'
               });
               
               console.log(`Fetching data for ${symbol}...`);
               const response = await fetch(`${FRED_BASE_URL}/series/observations?${params}`);
               
               if (!response.ok) {
                   throw new Error(`HTTP ${response.status}: ${response.statusText}`);
               }
               
               const data = await response.json();
               console.log(`Received data for ${symbol}:`, data);
               
               if (data.error_message) {
                   throw new Error(data.error_message);
               }
               
               const observations = data.observations || [];
               
               // Filter out invalid values and convert to numbers
               const validData = observations
                   .filter(obs => obs.value !== '.' && obs.value !== '')
                   .map(obs => ({
                       date: obs.date,
                       value: parseFloat(obs.value)
                   }))
                   .filter(obs => !isNaN(obs.value));
               
               if (validData.length === 0) {
                   throw new Error(`No valid data found for ${symbol}`);
               }
               
               console.log(`Processed ${validData.length} data points for ${symbol}`);
               return validData;
               
           } catch (error) {
               console.error(`Error fetching historical data for ${symbol}:`, error);
               showError(`Failed to fetch data for ${symbol}: ${error.message}`);
               return [];
           }
       }
       
       // Add to watchlist
       async function addToWatchlist(symbol, name) {
           // Check if already in watchlist
           if (watchlist.find(item => item.symbol === symbol)) {
               selectIndicator(symbol);
               document.getElementById('searchResults').classList.remove('active');
               document.getElementById('searchInput').value = '';
               return;
           }
           
           // Fetch historical data
           const historicalData = await fetchHistoricalData(symbol);
           
           if (historicalData.length > 0) {
               const item = {
                   symbol: symbol,
                   name: name,
                   data: historicalData,
                   latestValue: historicalData[historicalData.length - 1].value,
                   latestDate: historicalData[historicalData.length - 1].date
               };
               
               // Calculate changes
               item.changes = calculateChanges(historicalData);
               
               watchlist.push(item);
               chartData[symbol] = historicalData;
               
               updateWatchlistDisplay();
               saveWatchlistToStorage();
               selectIndicator(symbol);
           }
           
           document.getElementById('searchResults').classList.remove('active');
           document.getElementById('searchInput').value = '';
       }
       
       // Calculate percentage changes
       function calculateChanges(data) {
           if (data.length < 2) return {};
           
           const latest = data[data.length - 1].value;
           const changes = {};
           
           // MoM (1 month)
           const oneMonthAgo = new Date();
           oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
           const monthData = data.filter(d => new Date(d.date) >= oneMonthAgo);
           if (monthData.length > 1) {
               changes.mom = ((latest - monthData[0].value) / monthData[0].value * 100).toFixed(2);
           }
           
           // QoQ (3 months)
           const threeMonthsAgo = new Date();
           threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
           const quarterData = data.filter(d => new Date(d.date) >= threeMonthsAgo);
           if (quarterData.length > 1) {
               changes.qoq = ((latest - quarterData[0].value) / quarterData[0].value * 100).toFixed(2);
           }
           
           // YoY (1 year)
           const oneYearAgo = new Date();
           oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
           const yearData = data.filter(d => new Date(d.date) >= oneYearAgo);
           if (yearData.length > 1) {
               changes.yoy = ((latest - yearData[0].value) / yearData[0].value * 100).toFixed(2);
           }
           
           // 52-week range
           const last52w = data.slice(-252); // Approximately 252 trading days in a year
           if (last52w.length > 0) {
               const values = last52w.map(d => d.value);
               changes.low52w = Math.min(...values);
               changes.high52w = Math.max(...values);
           }
           
           return changes;
       }
       
       // Select indicator
       function selectIndicator(symbol) {
           selectedIndicator = symbol;
           const item = watchlist.find(w => w.symbol === symbol);
           
           if (!item) return;
           
           // Update chart title
           document.getElementById('chartTitle').textContent = `${item.name} (${item.symbol})`;
           
           // Update data info
           document.getElementById('dataInfo').style.display = 'grid';
           document.getElementById('latestValue').textContent = formatValue(item.latestValue);
           document.getElementById('latestDate').textContent = item.latestDate;
           
           const changes = item.changes;
           document.getElementById('momChange').textContent = changes.mom ? `${changes.mom}%` : '--';
           document.getElementById('momChange').className = changes.mom > 0 ? 'data-info-value positive' : 'data-info-value negative';
           
           document.getElementById('qoqChange').textContent = changes.qoq ? `${changes.qoq}%` : '--';
           document.getElementById('qoqChange').className = changes.qoq > 0 ? 'data-info-value positive' : 'data-info-value negative';
           
           document.getElementById('yoyChange').textContent = changes.yoy ? `${changes.yoy}%` : '--';
           document.getElementById('yoyChange').className = changes.yoy > 0 ? 'data-info-value positive' : 'data-info-value negative';
           
           if (changes.low52w && changes.high52w) {
               document.getElementById('range52w').textContent = `${formatValue(changes.low52w)} - ${formatValue(changes.high52w)}`;
           }
           
           // Update watchlist display
           updateWatchlistDisplay();
           
           // Plot chart
           plotChart(item.data, currentRange);
       }
       
       // Plot chart (FRED style)
       function plotChart(data, range) {
           if (!data || data.length === 0) {
               console.error('No data to plot');
               return;
           }
           
           if (typeof Plotly === 'undefined') {
               console.error('Plotly not available for plotting');
               showError('Charting library not loaded. Please refresh the page.');
               return;
           }
           
           // Filter data based on range
           let filteredData = filterDataByRange(data, range);
           
           if (filteredData.length === 0) {
               console.error('No data after filtering');
               return;
           }
           
           console.log(`Plotting ${filteredData.length} data points`);
           
           // Create FRED-style chart
           const trace = {
               x: filteredData.map(d => d.date),
               y: filteredData.map(d => d.value),
               type: 'scatter',
               mode: 'lines',
               line: {
                   color: '#1565c0',
                   width: 2
               },
               hovertemplate: '<b>%{x}</b><br>Value: %{y:.2f}<extra></extra>'
           };
           
           const layout = {
               paper_bgcolor: '#fff',
               plot_bgcolor: '#fff',
               font: {
                   family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
                   color: '#333'
               },
               xaxis: {
                   showgrid: true,
                   gridcolor: '#e0e0e0',
                   tickfont: { color: '#666', size: 11 },
                   zeroline: false
               },
               yaxis: {
                   showgrid: true,
                   gridcolor: '#e0e0e0',
                   tickfont: { color: '#666', size: 11 },
                   zeroline: true,
                   zerolinecolor: '#e0e0e0',
                   tickformat: ',.2f'
               },
               margin: { t: 20, r: 40, b: 40, l: 60 },
               hovermode: 'x unified',
               showlegend: false
           };
           
           const config = {
               responsive: true,
               displayModeBar: true,
               displaylogo: false,
               modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'autoScale2d', 'toggleSpikelines']
           };
           
           Plotly.newPlot('mainChart', [trace], layout, config);
       }
       
       // Filter data by range
       function filterDataByRange(data, range) {
           const endDate = new Date(data[data.length - 1].date);
           let startDate = new Date(endDate);
           
           switch(range) {
               case '1M':
                   startDate.setMonth(startDate.getMonth() - 1);
                   break;
               case '3M':
                   startDate.setMonth(startDate.getMonth() - 3);
                   break;
               case '6M':
                   startDate.setMonth(startDate.getMonth() - 6);
                   break;
               case 'YTD':
                   startDate = new Date(endDate.getFullYear(), 0, 1);
                   break;
               case '1Y':
                   startDate.setFullYear(startDate.getFullYear() - 1);
                   break;
               case '5Y':
                   startDate.setFullYear(startDate.getFullYear() - 5);
                   break;
               case '10Y':
                   startDate.setFullYear(startDate.getFullYear() - 10);
                   break;
               case 'ALL':
               default:
                   return data;
           }
           
           return data.filter(d => new Date(d.date) >= startDate);
       }
       
       // Setup chart controls
       function setupChartControls() {
           document.querySelectorAll('.chart-btn[data-range]').forEach(btn => {
               btn.addEventListener('click', function() {
                   document.querySelectorAll('.chart-btn[data-range]').forEach(b => b.classList.remove('active'));
                   this.classList.add('active');
                   
                   currentRange = this.dataset.range;
                   
                   if (selectedIndicator) {
                       const item = watchlist.find(w => w.symbol === selectedIndicator);
                       if (item) {
                           plotChart(item.data, currentRange);
                       }
                   }
               });
           });
       }
       
       // Update watchlist display
       function updateWatchlistDisplay() {
           const content = document.getElementById('watchlistContent');
           
           if (watchlist.length === 0) {
               content.innerHTML = `
                   <div class="empty-watchlist">
                       <div style="font-size: 3rem; opacity: 0.3;">ðŸ“Š</div>
                       <div>Your watchlist is empty</div>
                       <div style="margin-top: 0.5rem; font-size: 0.875rem; color: #999;">Search and add indicators to track</div>
                   </div>
               `;
               return;
           }
           
           let tableHTML = `
               <table class="watchlist-table">
                   <thead>
                       <tr>
                           <th>Indicator</th>
                           <th>Value</th>
                           <th>MoM %</th>
                           <th>QoQ %</th>
                           <th>YoY %</th>
                           <th>Action</th>
                       </tr>
                   </thead>
                   <tbody>`;
           
           watchlist.forEach((item, index) => {
               const isSelected = selectedIndicator === item.symbol;
               tableHTML += `
                   <tr class="${isSelected ? 'selected' : ''}" onclick="selectIndicator('${item.symbol}')">
                       <td>
                           <div style="font-weight: 500;">${item.name}</div>
                           <div style="font-size: 0.75rem; color: #999;">${item.symbol}</div>
                       </td>
                       <td style="font-weight: bold;">${formatValue(item.latestValue)}</td>
                       <td class="${item.changes.mom > 0 ? 'positive' : 'negative'}">
                           ${item.changes.mom ? item.changes.mom + '%' : '--'}
                       </td>
                       <td class="${item.changes.qoq > 0 ? 'positive' : 'negative'}">
                           ${item.changes.qoq ? item.changes.qoq + '%' : '--'}
                       </td>
                       <td class="${item.changes.yoy > 0 ? 'positive' : 'negative'}">
                           ${item.changes.yoy ? item.changes.yoy + '%' : '--'}
                       </td>
                       <td>
                           <button class="remove-btn" onclick="event.stopPropagation(); removeFromWatchlist(${index})">Remove</button>
                       </td>
                   </tr>`;
           });
           
           tableHTML += `
                   </tbody>
               </table>`;
           
           content.innerHTML = tableHTML;
       }
       
       // Format value
       function formatValue(value) {
           if (value === null || value === undefined) return '--';
           
           if (value >= 1000000000) {
               return (value / 1000000000).toFixed(2) + 'B';
           } else if (value >= 1000000) {
               return (value / 1000000).toFixed(2) + 'M';
           } else if (value >= 1000) {
               return (value / 1000).toFixed(2) + 'K';
           } else {
               return value.toFixed(2);
           }
       }
       
       // Initialize chart
       function initializeChart() {
           if (typeof Plotly === 'undefined') {
               console.error('Plotly not available for chart initialization');
               return;
           }
           
           const layout = {
               paper_bgcolor: '#fff',
               plot_bgcolor: '#fff',
               font: { color: '#666' },
               xaxis: {
                   showgrid: true,
                   gridcolor: '#e0e0e0'
               },
               yaxis: {
                   showgrid: true,
                   gridcolor: '#e0e0e0'
               },
               margin: { t: 20, r: 40, b: 40, l: 60 }
           };
           
           Plotly.newPlot('mainChart', [], layout, {responsive: true});
       }
       
       // Refresh watchlist
       async function refreshWatchlist() {
           for (let item of watchlist) {
               const newData = await fetchHistoricalData(item.symbol);
               if (newData.length > 0) {
                   item.data = newData;
                   item.latestValue = newData[newData.length - 1].value;
                   item.latestDate = newData[newData.length - 1].date;
                   item.changes = calculateChanges(newData);
                   chartData[item.symbol] = newData;
               }
           }
           
           updateWatchlistDisplay();
           saveWatchlistToStorage();
           
           if (selectedIndicator) {
               const item = watchlist.find(w => w.symbol === selectedIndicator);
               if (item) {
                   selectIndicator(selectedIndicator);
               }
           }
       }
       
       // Clear watchlist
       function clearWatchlist() {
           if (confirm('Are you sure you want to clear your watchlist?')) {
               watchlist = [];
               selectedIndicator = null;
               chartData = {};
               updateWatchlistDisplay();
               saveWatchlistToStorage();
               document.getElementById('chartTitle').textContent = 'Select an indicator to view data';
               document.getElementById('dataInfo').style.display = 'none';
               initializeChart();
           }
       }
       
       // Remove from watchlist
       function removeFromWatchlist(index) {
           const symbol = watchlist[index].symbol;
           watchlist.splice(index, 1);
           delete chartData[symbol];
           
           if (selectedIndicator === symbol) {
               selectedIndicator = null;
               document.getElementById('chartTitle').textContent = 'Select an indicator to view data';
               document.getElementById('dataInfo').style.display = 'none';
               initializeChart();
           }
           
           updateWatchlistDisplay();
           saveWatchlistToStorage();
       }
       
       // Save watchlist to localStorage
       function saveWatchlistToStorage() {
           const watchlistData = watchlist.map(item => ({
               symbol: item.symbol,
               name: item.name
           }));
           localStorage.setItem('openbb_watchlist', JSON.stringify(watchlistData));
       }
       
       // Load watchlist from localStorage
       async function loadWatchlistFromStorage() {
           const stored = localStorage.getItem('openbb_watchlist');
           if (stored) {
               try {
                   const watchlistData = JSON.parse(stored);
                   for (const item of watchlistData) {
                       if (FRED_SERIES[item.symbol]) {
                           await addToWatchlist(item.symbol, item.name || FRED_SERIES[item.symbol]);
                       }
                   }
               } catch (error) {
                   console.error('Error loading watchlist:', error);
               }
           }
       }
       
       // Show error message
       function showError(message) {
           const errorDiv = document.getElementById('errorMessage');
           if (!message) {
               errorDiv.classList.remove('active');
               return;
           }
           errorDiv.textContent = message;
           errorDiv.classList.add('active');
           
           setTimeout(() => {
               errorDiv.classList.remove('active');
           }, 5000);
       }
       
       // Auto-refresh every 5 minutes
       setInterval(() => {
           if (watchlist.length > 0) {
               refreshWatchlist();
           }
       }, 300000);
   </script>
</body>
</html>
