<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBB Financial Intelligence Platform</title>
   
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
   
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
       
        /* Header */
        .header {
            background: #121212;
            padding: 15px 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo {
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
       
        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 71px);
        }
       
        /* Search Section */
        .search-section {
            background: #121212;
            padding: 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 15px;
        }
        .search-container {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        .search-box {
            width: 100%;
            padding: 15px 50px 15px 20px;
            background: #222;
            border: 2px solid #333;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .search-box:focus {
            outline: none;
            border-color: #00ff88;
        }
        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            font-size: 18px;
        }
       
        /* Enhanced Ticker Type Filter */
        .ticker-type-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }
        .type-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .type-toggle:hover {
            background: #333;
            border-color: #555;
        }
        .type-toggle.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
       
        /* Data Source Filter */
        .data-source-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .source-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .source-toggle:hover {
            background: #333;
            border-color: #555;
        }
        .source-toggle.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
        .source-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }
        .source-indicator.connected {
            background: #00dd77;
        }
       
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            margin-top: 5px;
            max-height: 500px;
            overflow-y: auto;
            background: #181818;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .search-loading {
            padding: 20px;
            text-align: center;
            color: #00ff88;
        }
        .search-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-item:last-child { border-bottom: none; }
        .search-item:hover { background: #252525; }
        .search-item-left {
            flex: 1;
        }
        .search-item-symbol {
            font-weight: bold;
            color: #00dd77;
            font-size: 16px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }
        .search-item-name {
            font-size: 14px;
            color: #ddd;
            margin-bottom: 4px;
        }
        .search-item-description {
            font-size: 12px;
            color: #aaa;
            line-height: 1.3;
        }
        .search-item-source {
            font-size: 11px;
            color: #888;
            background: #2a2a2a;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }
        .search-item-type {
            font-size: 10px;
            color: #fff;
            background: #0066cc;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            text-transform: uppercase;
        }
       
        /* Charts and Watchlist Container */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
       
        /* Charts Area */
        .charts-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #0f0f0f;
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
        }
        .chart-window {
            background: #131313;
            border: 1px solid #282828;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: border-color 0.3s;
            min-height: 500px;
        }
        .chart-window.active-chart {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .chart-title-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
        }
        .chart-title {
            font-size: 18px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chart-symbols {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .chart-symbol-tag {
            background: #252525;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid #333;
        }
        .symbol-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .remove-symbol {
            cursor: pointer;
            color: #ff5555;
            font-weight: bold;
            margin-left: 5px;
            opacity: 0.7;
            font-size: 14px;
        }
        .remove-symbol:hover { opacity: 1; }

        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .timeframe-buttons {
            display: flex;
            gap: 2px;
            background: #080808;
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #252525;
        }
        .timeframe-btn {
            background: transparent;
            border: none;
            color: #888;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            border-radius: 4px;
        }
        .timeframe-btn:hover {
            background: #2e2e2e;
            color: #fff;
        }
        .timeframe-btn.active {
            background: #00dd77;
            color: #000;
            font-weight: bold;
        }
       
        /* Chart Display Controls */
        .chart-display-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        .display-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .display-toggle:hover {
            background: #333;
            border-color: #555;
        }
        .display-toggle.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
       
        .chart-canvas {
            background: #0a0a0a;
            border-radius: 6px;
            height: 500px;
            flex-grow: 1;
            min-height: 450px;
        }
        .chart-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #555;
            font-size: 16px;
            text-align: center;
            padding: 20px;
        }
       
        .control-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
        }
        .control-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        .close-btn {
            background: #dd4444;
            border-color: #dd4444;
            color: #fff;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }
        .close-btn:hover { background: #ff5555; }
       
        /* Watchlist Section */
        .watchlist-section {
            background: #121212;
            border-top: 1px solid #282828;
            height: 300px;
            overflow-y: auto;
        }
       
        .watchlist-header {
            background: #1a1a1a;
            padding: 15px 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
       
        .watchlist-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
       
        .watchlist-selector {
            background: #252525;
            color: #fff;
            border: 1px solid #333;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
       
        .watchlist-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
       
        .sort-button {
            background: #252525;
            color: #fff;
            border: 1px solid #333;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .sort-button:hover {
            background: #333;
            border-color: #555;
        }
       
        .sort-button.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
       
        .add-watchlist {
            background: #00dd77;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .add-watchlist:hover { background: #00ff88; }
       
        /* CoinMarketCap Style Table */
        .watchlist-table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
        }
       
        .watchlist-table th {
            background: #f5f5f5;
            color: #333;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            padding: 12px 15px;
            text-align: left;
            border-bottom: 2px solid #e0e0e0;
            position: sticky;
            top: 57px;
            z-index: 5;
        }
       
        .watchlist-table th.sortable:hover {
            background: #e8e8e8;
        }
       
        .sort-indicator {
            font-size: 10px;
            margin-left: 4px;
            color: #999;
        }
       
        .sort-indicator.asc::after {
            content: "▲";
            color: #00dd77;
        }
       
        .sort-indicator.desc::after {
            content: "▼";
            color: #ff4444;
        }
       
        .watchlist-table tbody tr {
            transition: background-color 0.2s;
            cursor: pointer;
            background: #fff;
            color: #333;
        }
       
        .watchlist-table tbody tr:hover {
            background: #f8f8f8;
        }
       
        .watchlist-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
            color: #333;
        }
       
        .symbol-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
       
        .symbol-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
            font-size: 10px;
        }
       
        .symbol-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
       
        .symbol-name {
            font-weight: bold;
            color: #000;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
       
        .symbol-fullname {
            color: #666;
            font-size: 11px;
        }
       
        .edit-icon {
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 12px;
            color: #666;
        }
       
        .symbol-cell:hover .edit-icon {
            opacity: 1;
        }
       
        .color-tag {
            width: 8px;
            height: 24px;
            border-radius: 2px;
            margin-right: 4px;
            cursor: pointer;
        }
       
        .price-cell {
            font-weight: bold;
            color: #000;
            text-align: right;
        }
       
        .change-cell {
            text-align: right;
            font-weight: bold;
        }
       
        .positive { color: #00dd77; }
        .negative { color: #ff4444; }
        .neutral { color: #666; }
       
        /* Enhanced flashing animations for significant changes (15%+) */
        @keyframes flashGreen {
            0%, 100% { background-color: #fff; }
            50% { background-color: #00ff8830; }
        }
       
        @keyframes flashRed {
            0%, 100% { background-color: #fff; }
            50% { background-color: #ff444430; }
        }
       
        .flash-green {
            animation: flashGreen 2s ease-in-out infinite;
        }
       
        .flash-red {
            animation: flashRed 2s ease-in-out infinite;
        }
       
        /* Loading */
        .loading-pulse { animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
       
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f0f0f; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }
       
        /* Message Popup */
        .message-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #222;
            border: 1px solid #333;
            padding: 15px 20px;
            border-radius: 6px;
            z-index: 2000;
            animation: slideInAndOut 3s ease-in-out forwards;
        }
        .message-popup.info { border-color: #00dd77; }
        .message-popup.error { border-color: #ff4444; color: #ff6666; }
       
        @keyframes slideInAndOut {
            0% { transform: translateX(120%); opacity: 0; }
            15%, 85% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(120%); opacity: 0; }
        }
       
        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
       
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }
       
        .status-dot.connected {
            background: #00dd77;
        }
       
        /* Liquidity Dashboard Alert */
        .liquidity-alert {
            background: linear-gradient(45deg, #ff4444, #ff6666);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            animation: pulse 2s infinite;
            cursor: pointer;
        }
       
        .liquidity-alert.moderate {
            background: linear-gradient(45deg, #ffaa00, #ffcc00);
            color: #000;
        }
       
        .liquidity-alert.low {
            background: linear-gradient(45deg, #00dd77, #00ff88);
            color: #000;
        }

        /* Risk/Liquidity Histogram Dashboard */
        .risk-dashboard {
            background: #131313;
            border: 1px solid #282828;
            border-radius: 10px;
            padding: 20px;
            margin: 20px;
            display: none;
        }
       
        .risk-dashboard.active {
            display: block;
        }
       
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
       
        .dashboard-title {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
       
        .alert-indicators {
            display: flex;
            gap: 10px;
            align-items: center;
        }
       
        .alert-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
       
        .alert-badge.low {
            background: #00dd77;
            color: #000;
        }
       
        .alert-badge.moderate {
            background: #ffaa00;
            color: #000;
        }
       
        .alert-badge.high {
            background: #ff4444;
            color: #fff;
        }
       
        .alert-badge.extreme {
            background: #8b0000;
            color: #fff;
            animation: flashAlert 1s infinite;
        }
       
        @keyframes flashAlert {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
       
        .gauge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
       
        .gauge-container {
            background: #0a0a0a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
        }
       
        .gauge-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 10px;
            text-align: center;
        }
       
        .gauge-chart {
            height: 300px;
            width: 100%;
        }
       
        .watchlist-config {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
       
        .config-header {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .config-toggle {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }
       
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
       
        .config-category {
            background: #252525;
            border-radius: 6px;
            padding: 15px;
        }
       
        .category-title {
            font-size: 14px;
            font-weight: bold;
            color: #00dd77;
            margin-bottom: 10px;
        }
       
        .symbol-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #ccc;
        }
       
        .symbol-checkbox input[type="checkbox"] {
            accent-color: #00dd77;
        }
       
        .threshold-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
       
        .threshold-input {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ccc;
        }
       
        .threshold-input input {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
            font-size: 12px;
        }

        /* WebSocket Real-Time Section */
        .websocket-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #888;
        }

        .websocket-status.connected {
            color: #00dd77;
        }

        .websocket-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .websocket-indicator.connected {
            background: #00dd77;
        }

        .realtime-btn {
            background: linear-gradient(45deg, #ff6600, #ff9900);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            animation: pulse 3s infinite;
        }

        .realtime-btn:hover {
            background: linear-gradient(45deg, #ff7700, #ffaa00);
            transform: scale(1.05);
        }

        /* AI Predictions Button */
        .ai-predictions-btn {
            background: linear-gradient(45deg, #6600ff, #9900ff);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .ai-predictions-btn:hover {
            background: linear-gradient(45deg, #7700ff, #aa00ff);
            transform: scale(1.05);
        }

        /* Search Dashboard Button */
        .search-dashboard-btn {
            background: linear-gradient(45deg, #0066ff, #0099ff);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .search-dashboard-btn:hover {
            background: linear-gradient(45deg, #0077ff, #00aaff);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">📊 OPENBB FINANCIAL INTELLIGENCE</div>
        <div class="header-controls">
            <div class="websocket-status" id="websocketStatus">
                <div class="websocket-indicator" id="websocketIndicator"></div>
                <span id="websocketStatusText">WebSocket: Checking...</span>
            </div>
            <div class="liquidity-alert" id="liquidityAlert" onclick="showLiquidityDashboard()" style="display: none;">
                <span id="liquidityAlertText">Checking Liquidity...</span>
            </div>
            <div class="api-status">
                <div class="status-dot" id="apiStatus"></div>
                <span id="apiStatusText">Checking connections...</span>
            </div>
            <button class="realtime-btn" onclick="openRealtimeDashboard()">🚀 Real-Time Data</button>
            <button class="ai-predictions-btn" onclick="openAIPredictions()">🤖 AI Predictions</button>
            <button class="search-dashboard-btn" onclick="openExponentialSearch()">🔍 Exponential Search</button>
            <button class="control-btn" onclick="addNewChart()">+ New Chart</button>
            <span id="clock" style="color: #888; font-size: 14px;"></span>
        </div>
    </div>

    <div class="main-container">
        <div class="search-section">
            <div class="search-container">
                <input type="text" class="search-box" id="searchBox"
                       placeholder="Search all financial instruments (Stocks, ETFs, Crypto, Bonds, Indices, Economic Data)..."
                       onkeyup="performSearch(this.value)"
                       autocomplete="off">
                <span class="search-icon">🔍</span>
                <div class="search-results" id="searchResults" style="display: none;"></div>
            </div>
           
            <div class="ticker-type-filter">
                <button class="type-toggle active" data-type="CS" onclick="toggleTickerType('CS')">📈 Stocks</button>
                <button class="type-toggle active" data-type="ETF" onclick="toggleTickerType('ETF')">🎯 ETFs</button>
                <button class="type-toggle active" data-type="CRYPTO" onclick="toggleTickerType('CRYPTO')">₿ Crypto</button>
                <button class="type-toggle active" data-type="MF" onclick="toggleTickerType('MF')">🏛️ Mutual Funds</button>
                <button class="type-toggle active" data-type="BOND" onclick="toggleTickerType('BOND')">🏦 Bonds</button>
                <button class="type-toggle active" data-type="INDEX" onclick="toggleTickerType('INDEX')">📊 Indices</button>
                <button class="type-toggle active" data-type="OTHER" onclick="toggleTickerType('OTHER')">🔧 Other</button>
            </div>
           
            <div class="data-source-filter">
                <button class="source-toggle active" data-source="polygon" onclick="toggleDataSource('polygon')">
                    <span class="source-indicator" id="polygon-indicator"></span>
                    Polygon
                </button>
                <button class="source-toggle active" data-source="fred" onclick="toggleDataSource('fred')">
                    <span class="source-indicator" id="fred-indicator"></span>
                    FRED
                </button>
                <button class="source-toggle active" data-source="ny_fed" onclick="toggleDataSource('ny_fed')">
                    <span class="source-indicator" id="ny_fed-indicator"></span>
                    NY Fed
                </button>
                <button class="source-toggle active" data-source="ecb" onclick="toggleDataSource('ecb')">
                    <span class="source-indicator" id="ecb-indicator"></span>
                    ECB
                </button>
                <button class="source-toggle active" data-source="ofr" onclick="toggleDataSource('ofr')">
                    <span class="source-indicator" id="ofr-indicator"></span>
                    OFR
                </button>
                <button class="source-toggle active" data-source="treasury" onclick="toggleDataSource('treasury')">
                    <span class="source-indicator" id="treasury-indicator"></span>
                    Treasury
                </button>
                <button class="source-toggle active" data-source="liquidity" onclick="toggleDataSource('liquidity')">
                    <span class="source-indicator" id="liquidity-indicator"></span>
                    Liquidity Intelligence
                </button>
                <button class="source-toggle" data-source="websocket" onclick="toggleDataSource('websocket')">
                    <span class="source-indicator" id="websocket-indicator"></span>
                    WebSocket Live
                </button>
            </div>
        </div>

        <div class="content">
            <div class="charts-area" style="display: none;" id="chartsArea">
                <div class="chart-grid" id="chartGrid"></div>
            </div>
           
            <div class="risk-dashboard" id="riskDashboard">
                <div class="dashboard-header">
                    <div class="dashboard-title">
                        🎯 Market Risk & Liquidity Intelligence
                    </div>
                    <div class="alert-indicators" id="alertIndicators">
                    </div>
                </div>
               
                <div class="gauge-grid" id="gaugeGrid">
                </div>
               
                <div class="watchlist-config" id="watchlistConfig" style="display: none;">
                    <div class="config-header">
                        📝 Configure Risk Categories
                        <button class="config-toggle" onclick="toggleConfig()">Toggle Config</button>
                    </div>
                   
                    <div class="config-grid">
                        <div class="config-category">
                            <div class="category-title">🔴 Risk Indicators</div>
                            <div id="riskSymbols">
                            </div>
                        </div>
                       
                        <div class="config-category">
                            <div class="category-title">💧 Liquidity Indicators</div>
                            <div id="liquiditySymbols">
                            </div>
                        </div>
                       
                        <div class="config-category">
                            <div class="category-title">📈 Economic Stress</div>
                            <div id="economicSymbols">
                            </div>
                        </div>
                       
                        <div class="config-category">
                            <div class="category-title">🌍 Global Stability</div>
                            <div id="globalSymbols">
                            </div>
                        </div>
                    </div>
                   
                    <div class="threshold-controls">
                        <div class="threshold-input">
                            <label>🟡 Warning:</label>
                            <input type="number" id="warningThreshold" value="60" min="0" max="100">%
                        </div>
                        <div class="threshold-input">
                            <label>🔴 Critical:</label>
                            <input type="number" id="criticalThreshold" value="80" min="0" max="100">%
                        </div>
                        <div class="threshold-input">
                            <label>⚫ Extreme:</label>
                            <input type="number" id="extremeThreshold" value="95" min="0" max="100">%
                        </div>
                        <button class="control-btn" onclick="updateRiskDashboard()">Update Dashboard</button>
                    </div>
                </div>
            </div>
           
            <div class="watchlist-section" style="flex: 1;">
                <div class="watchlist-header">
                    <div class="watchlist-title">
                        <select class="watchlist-selector" id="watchlistSelector" onchange="switchWatchlist(this.value)">
                            <option value="MAIN">MAIN</option>
                            <option value="STOCKS">STOCKS</option>
                            <option value="NY FED RATES">NY FED RATES</option>
                            <option value="ECB SYSTEMIC STRESS">ECB SYSTEMIC STRESS</option>
                            <option value="DOLLAR & EXCHANGE">DOLLAR & EXCHANGE</option>
                            <option value="GLOBAL LIQUIDITY">GLOBAL LIQUIDITY</option>
                            <option value="BLACK SWAN INDICATORS">BLACK SWAN INDICATORS</option>
                            <option value="ECONOMIC INDICATORS">ECONOMIC INDICATORS</option>
                            <option value="RATES & MONETARY">RATES & MONETARY</option>
                            <option value="OFR FUNDING MONITOR">OFR FUNDING MONITOR</option>
                            <option value="TREASURY AUCTIONS">TREASURY AUCTIONS</option>
                            <option value="LIQUIDITY INTELLIGENCE">LIQUIDITY INTELLIGENCE</option>
                        </select>
                    </div>
                    <div class="watchlist-controls">
                        <button class="sort-button" onclick="changeSortOrder('default')" id="sortDefault">Default</button>
                        <button class="sort-button" onclick="changeSortOrder('increase')" id="sortIncrease">↑ Largest Increase</button>
                        <button class="sort-button" onclick="changeSortOrder('decrease')" id="sortDecrease">↓ Largest Decrease</button>
                        <button class="control-btn" onclick="showChartView()" id="chartViewBtn" style="display: none;">📊 Chart View</button>
                        <button class="add-watchlist" onclick="document.getElementById('searchBox').focus()">+ Add Symbol</button>
                        <button class="control-btn" onclick="toggleRiskDashboard()" id="riskDashboardBtn">📊 Risk Dashboard</button>
                    </div>
                </div>
                <table class="watchlist-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th class="text-right">Price / Value</th>
                            <th class="text-right">Daily Change (Units)</th>
                            <th class="text-right sortable" onclick="sortByColumn('1d')" style="cursor: pointer;">
                                1D % <span class="sort-indicator" id="sort-1d"></span>
                            </th>
                            <th class="text-right sortable" onclick="sortByColumn('1w')" style="cursor: pointer;">
                                1W % <span class="sort-indicator" id="sort-1w"></span>
                            </th>
                            <th class="text-right sortable" onclick="sortByColumn('1m')" style="cursor: pointer;">
                                1M % <span class="sort-indicator" id="sort-1m"></span>
                            </th>
                            <th class="text-right sortable" onclick="sortByColumn('1y')" style="cursor: pointer;">
                                1Y % <span class="sort-indicator" id="sort-1y"></span>
                            </th>
                            <th class="text-right">Yearly Change (Units)</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="watchlistBody">
                        <!-- Watchlist items will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Configuration matching your exact backend
        const API_BASE = 'https://ped8gafyuz.us-east-1.awsapprunner.com';
        
        // WebSocket Lambda Function URL
        const WEBSOCKET_URL = 'https://7xaylc6nonthix4j377lelbnmm0tziuj.lambda-url.us-east-1.on.aws/';
        
        // Supabase Auth API
        const SUPABASE_API = 'https://j4o7j86qqb.execute-api.us-east-1.amazonaws.com/prod';
       
        // Enhanced data source configurations for all APIs including new liquidity intelligence and WebSocket
        const DATA_SOURCES = {
            polygon: {
                name: 'Polygon Financial Data',
                provider: 'polygon_direct',
                active: true,
                searchSymbols: ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'SPY', 'QQQ', 'IWM', 'VTI', 'VOO', 'NVDA', 'META', 'NFLX', 'CRM', 'AMD']
            },
            fred: {
                name: 'Federal Reserve Economic Data',
                provider: 'fred_direct',
                active: true,
                searchSymbols: [
                    // Core Economic Indicators
                    'FEDFUNDS', 'UNRATE', 'GDP', 'CPIAUCSL', 'DFF', 'M2SL', 'PAYEMS', 'HOUST', 'INDPRO',
                    // Dollar & Exchange Rates
                    'DTWEXBGS', 'DTWEXAFEGS', 'DTWEXEMEGS',
                    // Treasury Rates
                    'DGS10', 'DGS2', 'DGS30', 'DGS5', 'DGS1',
                    // Global Liquidity Indicators
                    'RESPPNTEPNWW', 'RESPPALGUOXAWXCH52NWW', 'RESPPALGUONNWW', 'SWP1690', 'OTHL1690',
                    'SUBLPDCISTQNQ', 'DRISCFLM', 'RMFSL', 'SBCACBW027SBOG', 'MABMM301EZM189S',
                    'DRISCFS', 'MABMM301JPM189S', 'TREAS911Y', 'RREP15', 'OTHL15', 'RESH4MFNWW',
                    'BOGZ1FL663067003Q', 'BOGMBASE', 'WSHOSHO', 'WRESBAL', 'TOTRESNS', 'NONBORRES',
                    // Black Swan Indicators
                    'NFCINONFINLEVERAGE', 'FRBKCLMCIM', 'AMTMUO', 'TREAS1590', 'T10YIE', 'AMERIBOR',
                    'INTGSTMXM193N', 'WLCFLPCL', 'CC4WSA', 'VIXCLS',
                    // Additional Economic Data
                    'ISRATIO', 'MNFCTRIRSA', 'SOFR', 'EFFR', 'OBFR',
                    // ICE BofA Series - Added for search
                    'BAMLC0A1CAAA', 'BAMLC4A0C710YEY', 'BAMLEMCBPIOAS', 'BAMLCC0A0CMTRIV', 'BAMLEMHBHYCRPIOAS',
                    'BAMLHE00EHYITRIV', 'BAMLC1A0C13YEY', 'BAMLEMHBHYCRPIEY', 'BAMLC2A0C35YEY', 'BAMLC8A0C15PYEY',
                    'BAMLC0A1CAAAOAS', 'BAMLC0A2CAAOAS', 'BAMLC0A3CAOAS', 'BAMLC0A4CBBBOAS', 'BAMLH0A0HYM2OAS',
                    'BAMLH0A1HYBBOAS', 'BAMLH0A2HYBOAS', 'BAMLH0A3HYCOAS', 'BAMLHE00EHYIOAS', 'BAMLEMCBPIEY',
                    'BAMLEMCBPITRIV', 'BAMLEMHBHYCRPITRIV', 'BAMLHE00EHYIEY', 'BAMLHYH0A0HYM2EY', 'BAMLC0A0CMEY',
                    'BAMLC0A0CMOAS', 'BAMLC5A0C510YEY', 'BAMLC3A0C57YEY', 'BAMLC6A0C1015YEY', 'BAMLC7A0C1520YEY'
                ]
            },
            ny_fed: {
                name: 'New York Federal Reserve',
                provider: 'ny_fed_direct',
                active: true,
                searchSymbols: ['sofr', 'effr', 'obfr', 'tgcr', 'bgcr']
            },
            ecb: {
                name: 'European Central Bank',
                provider: 'ecb_direct',
                active: true,
                searchSymbols: [
                    // Exchange Rates
                    'EXR.D.USD.EUR.SP00.A', 'EXR.D.GBP.EUR.SP00.A', 'EXR.D.JPY.EUR.SP00.A',
                    // CISS - Composite Indicator of Systemic Stress
                    'CISS.D.CN.Z0Z.4F.EC.SS_CIN.IDX', 'CISS.D.U2.Z0Z.4F.EC.SS_CIN.IDX', 'CISS.D.US.Z0Z.4F.EC.SS_CI.IDX',
                    // Country-specific Sovereign CISS
                    'CISS.M.SE.Z0Z.4F.EC.SOV_CI.IDX', 'CISS.M.FR.Z0Z.4F.EC.SOV_CI.IDX', 'CISS.M.FI.Z0Z.4F.EC.SOV_CI.IDX',
                    'CISS.M.DK.Z0Z.4F.EC.SOV_CI.IDX', 'CISS.M.GB.Z0Z.4F.EC.SOV_CI.IDX', 'CISS.M.BE.Z0Z.4F.EC.SOV_CI.IDX',
                    // CLIFS - Country-Level Index of Financial Stress
                    'CLIFS.M.DE._Z.4F.EC.CLIFS_CI.IDX',
                    // ILM - Interest Rate and Liquidity Measures
                    'ILM.W.U2.C.A030000.U2.Z06', 'ILM.W.U2.C.L060000.U4.EUR',
                    // BSI - Balance Sheet Items (Claims on euro area residents)
                    'BSI.W.U2.N.A.A20.A.1.U2.2240.Z01.E', 'BSI.W.U2.N.A.A30.A.1.U2.2240.Z01.E',
                    'BSI.W.U2.N.C.A20.A.1.U2.2240.Z01.E', 'BSI.W.U2.N.C.A30.A.1.U2.2240.Z01.E'
                ]
            },
            ofr: {
                name: 'Office of Financial Research',
                provider: 'ofr_direct',
                active: true,
                searchSymbols: [
                    'NYPD-PD_AFtR_T-A', 'NYPD-PD_AFtD_TOT-A', 'REPO_OV_TOT_P75', 'REPO_OV_TOT_P25',
                    'MMF_OV_TOT', 'DEALER_OV_TOT', 'BANK_OV_TOT', 'TGCR_VOL', 'SOFR_VOL'
                ]
            },
            treasury: {
                name: 'US Treasury Direct',
                provider: 'treasury_direct',
                active: true,
                searchSymbols: [
                    'BILLS_4W', 'BILLS_8W', 'BILLS_13W', 'BILLS_17W', 'BILLS_26W', 'BILLS_52W',
                    'NOTES_2Y', 'NOTES_3Y', 'NOTES_5Y', 'NOTES_7Y', 'NOTES_10Y',
                    'BONDS_20Y', 'BONDS_30Y', 'TIPS_5Y', 'TIPS_10Y', 'TIPS_20Y', 'TIPS_30Y'
                ]
            },
            liquidity: {
                name: 'Liquidity Intelligence Layer',
                provider: 'liquidity_intelligence',
                active: true,
                searchSymbols: ['OFR_FSI', 'TREASURY_MONITOR', 'NYFED_FAILS', 'LIQUIDITY_DASHBOARD']
            },
            websocket: {
                name: 'WebSocket Real-Time',
                provider: 'websocket_live',
                active: true,
                searchSymbols: ['SPX_LIVE', 'VIX_LIVE', 'DXY_LIVE', 'BTC_LIVE']
            }
        };

        // Ticker type configuration for Polygon
        const TICKER_TYPES = {
            CS: { name: 'Common Stock', active: true },
            ETF: { name: 'Exchange Traded Fund', active: true },
            CRYPTO: { name: 'Cryptocurrency', active: true },
            MF: { name: 'Mutual Fund', active: true },
            BOND: { name: 'Bond', active: true },
            INDEX: { name: 'Index', active: true },
            OTHER: { name: 'Other (ADR, REIT, etc.)', active: true }
        };
       
        let activeTickerTypes = Object.keys(TICKER_TYPES);
        let polygonTickers = [];
        let polygonTickersLoaded = false;
       
        const charts = {};
        let chartIdCounter = 0;
        let activeChartId = null;
        let searchTimeout = null;
        let activeSources = ['polygon', 'fred', 'ny_fed', 'ecb', 'ofr', 'treasury', 'liquidity']; // Removed 'websocket' from default
        
        // WebSocket polling interval
        let websocketInterval = null;
       
        // Enhanced watchlists with comprehensive coverage including new liquidity intelligence
        const watchlists = {
            'MAIN': {
                symbols: [
                    { symbol: 'AAPL', provider: 'polygon_direct' },
                    { symbol: 'FEDFUNDS', provider: 'fred_direct' },
                    { symbol: 'UNRATE', provider: 'fred_direct' },
                    { symbol: 'sofr', provider: 'ny_fed_direct' },
                    { symbol: 'EXR.D.USD.EUR.SP00.A', provider: 'ecb_direct' },
                    { symbol: 'CISS.D.U2.Z0Z.4F.EC.SS_CIN.IDX', provider: 'ecb_direct' },
                    { symbol: 'NYPD-PD_AFtR_T-A', provider: 'ofr_direct' },
                    { symbol: 'BILLS_13W', provider: 'treasury_direct' }
                ],
                active: true
            },
            'STOCKS': {
                symbols: [
                    { symbol: 'AAPL', provider: 'polygon_direct' },
                    { symbol: 'MSFT', provider: 'polygon_direct' },
                    { symbol: 'GOOGL', provider: 'polygon_direct' },
                    { symbol: 'AMZN', provider: 'polygon_direct' },
                    { symbol: 'TSLA', provider: 'polygon_direct' },
                    { symbol: 'SPY', provider: 'polygon_direct' },
                    { symbol: 'QQQ', provider: 'polygon_direct' },
                    { symbol: 'NVDA', provider: 'polygon_direct' },
                    { symbol: 'META', provider: 'polygon_direct' },
                    { symbol: 'NFLX', provider: 'polygon_direct' }
                ],
                active: false
            },
            'NY FED RATES': {
                symbols: [
                    { symbol: 'sofr', provider: 'ny_fed_direct' },
                    { symbol: 'effr', provider: 'ny_fed_direct' },
                    { symbol: 'obfr', provider: 'ny_fed_direct' },
                    { symbol: 'tgcr', provider: 'ny_fed_direct' },
                    { symbol: 'bgcr', provider: 'ny_fed_direct' }
                ],
                active: false
            },
            'ECB SYSTEMIC STRESS': {
                symbols: [
                    { symbol: 'CISS.D.U2.Z0Z.4F.EC.SS_CIN.IDX', provider: 'ecb_direct' },
                    { symbol: 'CISS.D.US.Z0Z.4F.EC.SS_CI.IDX', provider: 'ecb_direct' },
                    { symbol: 'CISS.D.CN.Z0Z.4F.EC.SS_CIN.IDX', provider: 'ecb_direct' },
                    { symbol: 'CISS.M.SE.Z0Z.4F.EC.SOV_CI.IDX', provider: 'ecb_direct' },
                    { symbol: 'CISS.M.FR.Z0Z.4F.EC.SOV_CI.IDX', provider: 'ecb_direct' },
                    { symbol: 'CISS.M.GB.Z0Z.4F.EC.SOV_CI.IDX', provider: 'ecb_direct' },
                    { symbol: 'CLIFS.M.DE._Z.4F.EC.CLIFS_CI.IDX', provider: 'ecb_direct' }
                ],
                active: false
            },
            'DOLLAR & EXCHANGE': {
                symbols: [
                    { symbol: 'DTWEXBGS', provider: 'fred_direct' },
                    { symbol: 'DTWEXAFEGS', provider: 'fred_direct' },
                    { symbol: 'DTWEXEMEGS', provider: 'fred_direct' },
                    { symbol: 'EXR.D.USD.EUR.SP00.A', provider: 'ecb_direct' },
                    { symbol: 'EXR.D.GBP.EUR.SP00.A', provider: 'ecb_direct' },
                    { symbol: 'EXR.D.JPY.EUR.SP00.A', provider: 'ecb_direct' }
                ],
                active: false
            },
            'GLOBAL LIQUIDITY': {
                symbols: [
                    { symbol: 'RESPPNTEPNWW', provider: 'fred_direct' },
                    { symbol: 'RESPPALGUOXAWXCH52NWW', provider: 'fred_direct' },
                    { symbol: 'RESPPALGUONNWW', provider: 'fred_direct' },
                    { symbol: 'SWP1690', provider: 'fred_direct' },
                    { symbol: 'OTHL1690', provider: 'fred_direct' },
                    { symbol: 'RMFSL', provider: 'fred_direct' },
                    { symbol: 'BOGMBASE', provider: 'fred_direct' },
                    { symbol: 'WSHOSHO', provider: 'fred_direct' },
                    { symbol: 'WRESBAL', provider: 'fred_direct' },
                    { symbol: 'TOTRESNS', provider: 'fred_direct' },
                    { symbol: 'NONBORRES', provider: 'fred_direct' },
                    { symbol: 'ILM.W.U2.C.A030000.U2.Z06', provider: 'ecb_direct' }
                ],
                active: false
            },
            'BLACK SWAN INDICATORS': {
                symbols: [
                    { symbol: 'NFCINONFINLEVERAGE', provider: 'fred_direct' },
                    { symbol: 'FRBKCLMCIM', provider: 'fred_direct' },
                    { symbol: 'AMTMUO', provider: 'fred_direct' },
                    { symbol: 'T10YIE', provider: 'fred_direct' },
                    { symbol: 'WLCFLPCL', provider: 'fred_direct' },
                    { symbol: 'CC4WSA', provider: 'fred_direct' },
                    { symbol: 'VIXCLS', provider: 'fred_direct' },
                    { symbol: 'TREAS1590', provider: 'fred_direct' }
                ],
                active: false
            },
            'ECONOMIC INDICATORS': {
                symbols: [
                    { symbol: 'GDP', provider: 'fred_direct' },
                    { symbol: 'UNRATE', provider: 'fred_direct' },
                    { symbol: 'CPIAUCSL', provider: 'fred_direct' },
                    { symbol: 'PAYEMS', provider: 'fred_direct' },
                    { symbol: 'INDPRO', provider: 'fred_direct' },
                    { symbol: 'HOUST', provider: 'fred_direct' },
                    { symbol: 'ISRATIO', provider: 'fred_direct' },
                    { symbol: 'MNFCTRIRSA', provider: 'fred_direct' }
                ],
                active: false
            },
            'RATES & MONETARY': {
                symbols: [
                    { symbol: 'FEDFUNDS', provider: 'fred_direct' },
                    { symbol: 'DGS10', provider: 'fred_direct' },
                    { symbol: 'DGS2', provider: 'fred_direct' },
                    { symbol: 'DGS30', provider: 'fred_direct' },
                    { symbol: 'sofr', provider: 'ny_fed_direct' },
                    { symbol: 'effr', provider: 'ny_fed_direct' },
                    { symbol: 'M2SL', provider: 'fred_direct' }
                ],
                active: false
            },
            'OFR FUNDING MONITOR': {
                symbols: [
                    { symbol: 'NYPD-PD_AFtR_T-A', provider: 'ofr_direct' },
                    { symbol: 'NYPD-PD_AFtD_TOT-A', provider: 'ofr_direct' },
                    { symbol: 'REPO_OV_TOT_P75', provider: 'ofr_direct' },
                    { symbol: 'REPO_OV_TOT_P25', provider: 'ofr_direct' },
                    { symbol: 'MMF_OV_TOT', provider: 'ofr_direct' },
                    { symbol: 'DEALER_OV_TOT', provider: 'ofr_direct' }
                ],
                active: false
            },
            'TREASURY AUCTIONS': {
                symbols: [
                    { symbol: 'BILLS_4W', provider: 'treasury_direct' },
                    { symbol: 'BILLS_13W', provider: 'treasury_direct' },
                    { symbol: 'BILLS_26W', provider: 'treasury_direct' },
                    { symbol: 'BILLS_52W', provider: 'treasury_direct' },
                    { symbol: 'NOTES_2Y', provider: 'treasury_direct' },
                    { symbol: 'NOTES_5Y', provider: 'treasury_direct' },
                    { symbol: 'NOTES_10Y', provider: 'treasury_direct' },
                    { symbol: 'BONDS_30Y', provider: 'treasury_direct' },
                    { symbol: 'TIPS_10Y', provider: 'treasury_direct' },
                    { symbol: 'TIPS_30Y', provider: 'treasury_direct' }
                ],
                active: false
            },
            'LIQUIDITY INTELLIGENCE': {
                symbols: [
                    { symbol: 'OFR_FSI', provider: 'liquidity_intelligence' },
                    { symbol: 'TREASURY_MONITOR', provider: 'liquidity_intelligence' },
                    { symbol: 'NYFED_FAILS', provider: 'liquidity_intelligence' },
                    { symbol: 'LIQUIDITY_DASHBOARD', provider: 'liquidity_intelligence' }
                ],
                active: false
            }
        };
       
        let currentWatchlist = 'MAIN';
        let watchlistSymbols = [];
        let watchlistData = {};
        let sortOrder = 'default';
        let columnSort = { column: null, direction: null };
       
        // Color palette for charts
        const colorPalette = [
            '#00AEEF', '#FF4444', '#F4D03F', '#58D68D', '#FF7043',
            '#AF7AC5', '#48C9B0', '#EC7063', '#5DADE2', '#F5B041'
        ];
       
        // Enhanced flashing logic - store flash timers
        let flashTimers = {};

        // Risk Dashboard Variables
        const riskCategories = {
            'risk': {
                name: '🔴 Market Risk',
                symbols: ['VIXCLS', 'T10YIE', 'NFCINONFINLEVERAGE', 'CC4WSA', 'WLCFLPCL', 'CISS.D.U2.Z0Z.4F.EC.SS_CIN.IDX'],
                color: '#ff4444',
                thresholds: { warning: 60, critical: 80, extreme: 95 }
            },
            'liquidity': {
                name: '💧 Liquidity Stress',
                symbols: ['M2SL', 'TOTRESNS', 'WRESBAL', 'RMFSL', 'BOGMBASE', 'sofr', 'effr'],
                color: '#00aaff',
                thresholds: { warning: 65, critical: 85, extreme: 95 }
            },
            'economic': {
                name: '📈 Economic Stress',
                symbols: ['UNRATE', 'CPIAUCSL', 'PAYEMS', 'INDPRO', 'FEDFUNDS', 'DGS10'],
                color: '#ffaa00',
                thresholds: { warning: 70, critical: 85, extreme: 95 }
            },
            'global': {
                name: '🌍 Global Stability',
                symbols: ['DTWEXBGS', 'EXR.D.USD.EUR.SP00.A', 'CISS.D.US.Z0Z.4F.EC.SS_CI.IDX', 'CISS.D.CN.Z0Z.4F.EC.SS_CIN.IDX'],
                color: '#aa00ff',
                thresholds: { warning: 60, critical: 80, extreme: 90 }
            }
        };
       
        let riskDashboardData = {};
        let riskAlerts = {};
       
        // Initialize the dashboard
        async function init() {
            updateClock();
            setInterval(updateClock, 1000);
           
            loadWatchlists();
            await checkAPIConnections();
            
            // Check WebSocket but don't block if it fails
            const wsConnected = await checkWebSocketConnection();
            if (wsConnected) {
                startWebSocketPolling();
            }
            
            loadWatchlistData();
            setInterval(loadWatchlistData, 60000);
           
            // Load liquidity dashboard
            setInterval(loadLiquidityDashboard, 300000); // Every 5 minutes
            loadLiquidityDashboard();
           
            updateSortButtons();
            document.getElementById('searchBox').focus();

            // Initialize risk dashboard
            initializeRiskDashboard();
           
            // Load Polygon tickers
            loadPolygonTickers();
        }

        // Check WebSocket connection
        async function checkWebSocketConnection() {
            try {
                const response = await fetch(WEBSOCKET_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'test' })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('websocketIndicator').classList.add('connected');
                    document.getElementById('websocketStatusText').textContent = 'WebSocket: Connected';
                    document.getElementById('websocket-indicator').classList.add('connected');
                    console.log('WebSocket Lambda connected:', data);
                    return true;
                } else {
                    throw new Error(`WebSocket returned ${response.status}`);
                }
            } catch (error) {
                console.warn('WebSocket connection check failed:', error);
                document.getElementById('websocketIndicator').classList.remove('connected');
                document.getElementById('websocketStatusText').textContent = 'WebSocket: Offline';
                document.getElementById('websocket-indicator').classList.remove('connected');
                return false;
            }
        }
        
        // Start WebSocket polling
        function startWebSocketPolling() {
            if (websocketInterval) {
                clearInterval(websocketInterval);
            }
            
            // Poll every 10 seconds for real-time data (reduced frequency to avoid errors)
            websocketInterval = setInterval(async () => {
                if (activeSources.includes('websocket')) {
                    try {
                        const response = await fetch(WEBSOCKET_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'getData' })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.market_data) {
                                updateWebSocketData(data.market_data);
                            }
                        }
                    } catch (error) {
                        // Silently handle polling errors to avoid console spam
                        console.debug('WebSocket polling skipped:', error.message);
                    }
                }
            }, 10000); // Reduced to 10 seconds
        }
        
        // Update WebSocket data
        function updateWebSocketData(marketData) {
            // Update any watchlist items that are using websocket_live provider
            Object.keys(marketData).forEach(symbol => {
                const wsSymbol = symbol.toUpperCase() + '_LIVE';
                if (watchlistData[wsSymbol]) {
                    const oldValue = watchlistData[wsSymbol].price || 0;
                    const newValue = marketData[symbol];
                    const change = oldValue !== 0 ? ((newValue - oldValue) / oldValue) * 100 : 0;
                    
                    watchlistData[wsSymbol] = {
                        ...watchlistData[wsSymbol],
                        price: newValue,
                        changes: {
                            '1d': change,
                            '1w': change * 2, // Simulated
                            '1m': change * 4, // Simulated
                            '3m': change * 8, // Simulated
                            '1y': change * 16 // Simulated
                        },
                        changeUnits: {
                            'daily': newValue - oldValue,
                            'yearly': (newValue - oldValue) * 365
                        },
                        hasData: true,
                        lastUpdateTime: Date.now()
                    };
                    
                    // Check for significant changes
                    checkForSignificantChanges(wsSymbol, watchlistData[wsSymbol].changes);
                }
            });
            
            // Re-render if we have websocket data in current watchlist
            const hasWebSocketData = watchlistSymbols.some(s => 
                (s.provider || 'fred_direct') === 'websocket_live'
            );
            if (hasWebSocketData) {
                renderWatchlist();
            }
        }
        
        // Open Real-Time Dashboard
        function openRealtimeDashboard() {
            window.open('openbb-realtime-dashboard.html', '_blank');
        }
        
        // Open AI Predictions
        function openAIPredictions() {
            window.open('ai-predictions-supabase.html', '_blank');
        }
        
        // Open Exponential Search
        function openExponentialSearch() {
            window.open('exponential-search-dashboard.html', '_blank');
        }

        // Load Polygon tickers from new API endpoint
        async function loadPolygonTickers() {
            if (polygonTickersLoaded) return;
           
            try {
                console.log('Loading Polygon tickers from search endpoint...');
                const response = await fetch(`${API_BASE}/api/v1/search/polygon`);
                if (response.ok) {
                    const data = await response.json();
                    if (Array.isArray(data) && data.length > 0) {
                        polygonTickers = data.map(ticker => ({
                            ticker: ticker.ticker,
                            name: ticker.name,
                            type: ticker.type || 'CS',
                            market: ticker.market || 'stocks',
                            active: true
                        }));
                        polygonTickersLoaded = true;
                        console.log(`Loaded ${polygonTickers.length} Polygon tickers from search endpoint`);
                    }
                } else {
                    console.warn('Failed to load Polygon tickers from search endpoint:', response.status);
                    // Fallback to default symbols
                    polygonTickers = DATA_SOURCES.polygon.searchSymbols.map(symbol => ({
                        ticker: symbol,
                        name: symbol,
                        type: 'CS',
                        market: 'stocks',
                        active: true
                    }));
                    polygonTickersLoaded = true;
                }
            } catch (error) {
                console.warn('Error loading Polygon tickers:', error);
                // Fallback to default symbols
                polygonTickers = DATA_SOURCES.polygon.searchSymbols.map(symbol => ({
                    ticker: symbol,
                    name: symbol,
                    type: 'CS',
                    market: 'stocks',
                    active: true
                }));
                polygonTickersLoaded = true;
            }
        }

        // Toggle ticker type filter
        function toggleTickerType(type) {
            const button = document.querySelector(`.ticker-type-filter [data-type="${type}"]`);
            const isActive = button.classList.contains('active');
           
            if (isActive) {
                button.classList.remove('active');
                activeTickerTypes = activeTickerTypes.filter(t => t !== type);
            } else {
                button.classList.add('active');
                activeTickerTypes.push(type);
            }
        }

        // Get ticker type description
        function getTickerTypeDescription(type) {
            const descriptions = {
                CS: 'Common Stock',
                ETF: 'Exchange Traded Fund',
                CRYPTO: 'Cryptocurrency',
                MF: 'Mutual Fund',
                BOND: 'Bond',
                INDEX: 'Index',
                ADRC: 'American Depositary Receipt',
                ADRW: 'ADR Warrant',
                ADRR: 'ADR Rights',
                FUND: 'Closed-End Fund',
                SP: 'Structured Product',
                WARRANT: 'Warrant',
                RIGHT: 'Rights',
                UNIT: 'Unit',
                OTHER: 'Other Security Type'
            };
            return descriptions[type] || 'Financial Instrument';
        }
       
        // Enhanced API connection check for all providers including liquidity intelligence
        async function checkAPIConnections() {
            let connectedCount = 0;
            const totalSources = Object.keys(DATA_SOURCES).length;
           
            // Test health endpoint first
            try {
                const healthResponse = await fetch(`${API_BASE}/api/v1/health`);
                if (healthResponse.ok) {
                    const healthData = await healthResponse.json();
                    console.log('Health check:', healthData);
                }
            } catch (error) {
                console.warn('Health check failed:', error);
            }
           
            // Test each provider with more comprehensive checks
            for (const [source, config] of Object.entries(DATA_SOURCES)) {
                try {
                    let testUrl;
                   
                    if (source === 'liquidity') {
                        // Test liquidity intelligence endpoints
                        testUrl = `${API_BASE}/api/v1/liquidity/dashboard`;
                    } else if (source === 'websocket') {
                        // Skip websocket here as it's checked separately
                        continue;
                    } else {
                        const testSymbol = config.searchSymbols[0];
                       
                        if (source === 'polygon') {
                            testUrl = `${API_BASE}/api/v1/universal/data?symbol=${testSymbol}&provider=${config.provider}&data_type=quote`;
                        } else if (source === 'fred') {
                            testUrl = `${API_BASE}/api/v1/universal/data?symbol=${testSymbol}&provider=fred_direct&include_changes=false`;
                        } else if (source === 'ny_fed') {
                            testUrl = `${API_BASE}/api/v1/universal/data?symbol=${testSymbol}&provider=ny_fed_direct&include_changes=false`;
                        } else if (source === 'ecb') {
                            testUrl = `${API_BASE}/api/v1/universal/data?symbol=${testSymbol}&provider=${config.provider}&include_changes=false`;
                        } else if (source === 'ofr') {
                            testUrl = `${API_BASE}/api/v1/universal/data?symbol=${testSymbol}&provider=${config.provider}&include_changes=false`;
                        } else if (source === 'treasury') {
                            testUrl = `${API_BASE}/api/v1/universal/data?symbol=${testSymbol}&provider=${config.provider}&include_changes=false`;
                        }
                    }
                   
                    const response = await fetch(testUrl);
                   
                    if (response.ok) {
                        const data = await response.json();
                        if (data && (data.metrics || data.data || data.symbol || data.overall_stress_score !== undefined)) {
                            document.getElementById(`${source}-indicator`).classList.add('connected');
                            connectedCount++;
                            console.log(`${source} connected successfully`);
                        }
                    } else if (response.status === 404) {
                        // 404 might just mean symbol not found, but API is working
                        document.getElementById(`${source}-indicator`).classList.add('connected');
                        connectedCount++;
                        console.log(`${source} connected (404 but API responsive)`);
                    }
                } catch (error) {
                    console.warn(`${source} API connection failed:`, error);
                    document.getElementById(`${source}-indicator`).classList.remove('connected');
                }
            }
           
            const statusText = `${connectedCount}/${totalSources} APIs Connected`;
            document.getElementById('apiStatusText').textContent = statusText;
           
            if (connectedCount > 0) {
                document.getElementById('apiStatus').classList.add('connected');
                showTemporaryMessage(`Connected to ${connectedCount} data sources`, 'info');
            } else {
                showTemporaryMessage('No API connections available', 'error');
            }
        }
       
        // Load liquidity dashboard
        async function loadLiquidityDashboard() {
            try {
                const response = await fetch(`${API_BASE}/api/v1/liquidity/dashboard`);
                if (response.ok) {
                    const data = await response.json();
                    updateLiquidityAlert(data);
                    document.getElementById('liquidity-indicator').classList.add('connected');
                }
            } catch (error) {
                console.warn('Liquidity dashboard failed:', error);
                document.getElementById('liquidity-indicator').classList.remove('connected');
            }
        }
       
        // Update liquidity alert
        function updateLiquidityAlert(data) {
            const alertElement = document.getElementById('liquidityAlert');
            const alertText = document.getElementById('liquidityAlertText');
           
            if (!data || data.overall_stress_score === undefined) {
                alertElement.style.display = 'none';
                return;
            }
           
            const stressScore = data.overall_stress_score;
            const stressLevel = data.stress_level;
           
            alertElement.style.display = 'block';
            alertText.textContent = `Liquidity: ${stressLevel} (${(stressScore * 100).toFixed(1)}%)`;
           
            // Update alert styling based on stress level
            alertElement.className = 'liquidity-alert';
            if (stressLevel === 'EXTREME' || stressLevel === 'HIGH') {
                alertElement.classList.add('high');
            } else if (stressLevel === 'MODERATE') {
                alertElement.classList.add('moderate');
            } else {
                alertElement.classList.add('low');
            }
        }
       
        // Show liquidity dashboard
        function showLiquidityDashboard() {
            showTemporaryMessage('Loading comprehensive liquidity dashboard...', 'info');
            // You could open a modal or navigate to a detailed view here
        }
       
        // Toggle data source
        function toggleDataSource(source) {
            const button = document.querySelector(`[data-source="${source}"]`);
            const isActive = button.classList.contains('active');
           
            if (isActive) {
                button.classList.remove('active');
                activeSources = activeSources.filter(s => s !== source);
            } else {
                button.classList.add('active');
                activeSources.push(source);
            }
        }
       
        // Enhanced search across all providers including liquidity intelligence and Polygon types
        async function performSearch(query) {
            const resultsDiv = document.getElementById('searchResults');
           
            if (!query || query.trim().length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }
           
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                resultsDiv.innerHTML = '<div class="search-loading">Searching across all data sources...</div>';
                resultsDiv.style.display = 'block';
               
                try {
                    const allResults = [];
                    
                    // Search using the exponential search index from S3
                    if (activeSources.includes('fred') || activeSources.includes('ecb') || activeSources.includes('ofr')) {
                        try {
                            // Fetch the universal indicator index from S3
                            const indexResponse = await fetch('https://macro-data-lake.s3.amazonaws.com/index/universal_indicator_index.json');
                            if (indexResponse.ok) {
                                const indexData = await indexResponse.json();
                                
                                // Search through all indicators in the index
                                indexData.indicators.forEach(indicator => {
                                    const queryLower = query.toLowerCase();
                                    const nameMatch = indicator.name.toLowerCase().includes(queryLower);
                                    const symbolMatch = indicator.symbol.toLowerCase().includes(queryLower);
                                    const tagMatch = indicator.tags.some(tag => tag.toLowerCase().includes(queryLower));
                                    const categoryMatch = indicator.category.toLowerCase().includes(queryLower);
                                    
                                    if (nameMatch || symbolMatch || tagMatch || categoryMatch) {
                                        // Map providers correctly
                                        let provider = indicator.provider || 'fred_direct';
                                        if (indicator.category === 'FRED Economics') provider = 'fred_direct';
                                        else if (indicator.category === 'ECB Financial') provider = 'ecb_direct';
                                        else if (indicator.category === 'OFR Risk') provider = 'ofr_direct';
                                        else if (indicator.category === 'Treasury Auctions') provider = 'treasury_direct';
                                        else if (indicator.category === 'NY Fed Rates') provider = 'ny_fed_direct';
                                        
                                        allResults.push({
                                            symbol: indicator.symbol,
                                            name: indicator.name,
                                            provider: provider,
                                            source: provider.replace('_direct', ''),
                                            description: `${indicator.category} - Priority: ${indicator.priority}`,
                                            priority: indicator.priority
                                        });
                                    }
                                });
                                
                                // Sort by priority (higher priority first)
                                allResults.sort((a, b) => (b.priority || 0) - (a.priority || 0));
                            }
                        } catch (error) {
                            console.warn('Failed to load exponential search index:', error);
                        }
                    }
                    
                    // Search scraped data from S3
                    if (activeSources.includes('fred')) {
                        try {
                            // List all scraped data files
                            const scrapedDataUrls = [
                                'https://macro-data-lake.s3.amazonaws.com/scraped_data/economic_calendar.json',
                                'https://macro-data-lake.s3.amazonaws.com/scraped_data/market_overview.json',
                                'https://macro-data-lake.s3.amazonaws.com/scraped_data/treasury_yields.json',
                                'https://macro-data-lake.s3.amazonaws.com/scraped_data/fed_data.json',
                                'https://macro-data-lake.s3.amazonaws.com/scraped_data/global_markets.json'
                            ];
                            
                            for (const url of scrapedDataUrls) {
                                try {
                                    const response = await fetch(url);
                                    if (response.ok) {
                                        const data = await response.json();
                                        const queryLower = query.toLowerCase();
                                        
                                        // Extract filename for context
                                        const filename = url.split('/').pop().replace('.json', '').replace(/_/g, ' ');
                                        
                                        // Search through the data
                                        if (JSON.stringify(data).toLowerCase().includes(queryLower)) {
                                            allResults.push({
                                                symbol: filename.toUpperCase().replace(/ /g, '_'),
                                                name: `Scraped Data: ${filename}`,
                                                provider: 'fred_direct',
                                                source: 'scraped',
                                                description: `Latest scraped ${filename} data from Lambda scraper`
                                            });
                                        }
                                    }
                                } catch (err) {
                                    console.debug(`Failed to load ${url}:`, err);
                                }
                            }
                        } catch (error) {
                            console.warn('Failed to search scraped data:', error);
                        }
                    }
                    if (activeSources.includes('fred') || activeSources.includes('liquidity')) {
                        try {
                            const aiResponse = await fetch('https://macro-data-lake.s3.amazonaws.com/predictions/ai_output.json');
                            if (aiResponse.ok) {
                                const aiData = await aiResponse.json();
                                const queryLower = query.toLowerCase();
                                
                                // Add AI predictions to search results
                                if ('ai predictions'.includes(queryLower) || 'market forecast'.includes(queryLower)) {
                                    allResults.push({
                                        symbol: 'AI_FORECAST',
                                        name: 'OpenBB AI Market Predictions',
                                        provider: 'liquidity_intelligence',
                                        source: 'ai',
                                        description: `Latest AI forecast: ${aiData.market_sentiment || 'Available'}`
                                    });
                                }
                            }
                        } catch (error) {
                            console.warn('Failed to load AI predictions:', error);
                        }
                    }
                   
                    // Search Polygon tickers with type filtering
                    if (activeSources.includes('polygon')) {
                        if (!polygonTickersLoaded) await loadPolygonTickers();
                       
                        const filteredPolygonTickers = polygonTickers.filter(ticker => {
                            // Check ticker type matches active filters
                            let typeMatch = false;
                            const tickerTypeUpper = ticker.type ? ticker.type.toUpperCase() : 'OTHER';
                           
                            if (activeTickerTypes.includes(tickerTypeUpper)) {
                                typeMatch = true;
                            } else if (activeTickerTypes.includes('OTHER')) {
                                // If OTHER is selected, include types not in the main categories
                                const commonTypes = ['CS', 'ETF', 'CRYPTO', 'MF', 'BOND', 'INDEX'];
                                if (!commonTypes.includes(tickerTypeUpper)) {
                                    typeMatch = true;
                                }
                            }
                           
                            if (!typeMatch) return false;
                           
                            // Check if symbol or name matches query
                            const queryLower = query.toLowerCase();
                            return ticker.ticker.toLowerCase().includes(queryLower) ||
                                   (ticker.name && ticker.name.toLowerCase().includes(queryLower));
                        });
                       
                        // Add filtered results (limit to 50 for performance)
                        filteredPolygonTickers.slice(0, 50).forEach(ticker => {
                            allResults.push({
                                symbol: ticker.ticker,
                                name: ticker.name || ticker.ticker,
                                provider: 'polygon_direct',
                                source: 'polygon',
                                type: ticker.type,
                                description: getTickerTypeDescription(ticker.type)
                            });
                        });
                    }
                   
                    // Search through each other active data source
                    for (const source of activeSources) {
                        if (source === 'polygon') continue; // Already handled above
                       
                        const config = DATA_SOURCES[source];
                        if (!config) continue;
                       
                        // Filter symbols that match the query
                        const matchingSymbols = config.searchSymbols.filter(symbol =>
                            symbol.toLowerCase().includes(query.toLowerCase()) ||
                            getSymbolDescription(symbol, source).toLowerCase().includes(query.toLowerCase())
                        );
                       
                        matchingSymbols.forEach(symbol => {
                            // Check if already added from index
                            if (!allResults.find(r => r.symbol === symbol)) {
                                allResults.push({
                                    symbol: symbol,
                                    name: getSymbolDescription(symbol, source),
                                    provider: config.provider,
                                    source: source,
                                    description: getDetailedDescription(symbol, source)
                                });
                            }
                        });
                    }
                   
                    displaySearchResults(allResults, query);
                   
                } catch (error) {
                    console.error('Search error:', error);
                    resultsDiv.innerHTML = `
                        <div class="search-item" style="text-align:center; color:#888;">
                            Error searching. Please try again.
                        </div>
                    `;
                }
            }, 300);
        }
       
        // Enhanced symbol descriptions for all providers including liquidity intelligence and ICE BofA
        function getSymbolDescription(symbol, source) {
            const descriptions = {
                polygon: {
                    'AAPL': 'Apple Inc.',
                    'MSFT': 'Microsoft Corporation',
                    'GOOGL': 'Alphabet Inc.',
                    'AMZN': 'Amazon.com Inc.',
                    'TSLA': 'Tesla Inc.',
                    'SPY': 'SPDR S&P 500 ETF',
                    'QQQ': 'Invesco QQQ Trust',
                    'IWM': 'iShares Russell 2000 ETF',
                    'VTI': 'Vanguard Total Stock Market ETF',
                    'VOO': 'Vanguard S&P 500 ETF',
                    'NVDA': 'NVIDIA Corporation',
                    'META': 'Meta Platforms Inc.',
                    'NFLX': 'Netflix Inc.'
                },
                fred: {
                    'FEDFUNDS': 'Federal Funds Rate',
                    'UNRATE': 'Unemployment Rate',
                    'GDP': 'Gross Domestic Product',
                    'CPIAUCSL': 'Consumer Price Index',
                    'DFF': 'Daily Federal Funds Rate',
                    'M2SL': 'M2 Money Supply',
                    'PAYEMS': 'Total Nonfarm Payrolls',
                    'HOUST': 'Housing Starts',
                    'INDPRO': 'Industrial Production Index',
                    'DTWEXBGS': 'Trade Weighted U.S. Dollar Index: Broad, Goods and Services',
                    'DTWEXAFEGS': 'Trade Weighted U.S. Dollar Index: Advanced Foreign Economies, Goods and Services',
                    'DTWEXEMEGS': 'Trade Weighted U.S. Dollar Index: Emerging Market Economies, Goods and Services',
                    'RESPPNTEPNWW': 'Central Bank Assets to GDP for World',
                    'RESPPALGUOXAWXCH52NWW': 'Central Bank Assets for World',
                    'RESPPALGUONNWW': 'Central Bank Assets for World (Narrow)',
                    'SWP1690': 'Central Bank Liquidity Swaps',
                    'OTHL1690': 'Other Liquid Assets',
                    'RMFSL': 'Reserve Bank Credit',
                    'BOGMBASE': 'Monetary Base',
                    'WSHOSHO': 'Wholesale Short-Term Funding',
                    'WRESBAL': 'Reserve Balances',
                    'TOTRESNS': 'Total Reserves',
                    'NONBORRES': 'Non-borrowed Reserves',
                    'NFCINONFINLEVERAGE': 'National Financial Conditions Index: Nonfinancial Leverage Subindex',
                    'FRBKCLMCIM': 'Bank Commercial and Industrial Loans',
                    'AMTMUO': 'Margin Trading Outstanding',
                    'T10YIE': '10-Year Breakeven Inflation Rate',
                    'WLCFLPCL': 'Crude Oil Prices: West Texas Intermediate',
                    'CC4WSA': 'Credit Card Charge-Off Rate',
                    'VIXCLS': 'CBOE Volatility Index: VIX',
                    'ISRATIO': 'Total Business Inventories to Sales Ratio',
                    'MNFCTRIRSA': 'Manufacturers: Inventories to Sales Ratio',
                    // ICE BofA Corporate Bond Series
                    'BAMLC0A1CAAA': 'ICE BofA AAA US Corporate Index Option-Adjusted Spread',
                    'BAMLC4A0C710YEY': 'ICE BofA 7-10 Year US Corporate Index Effective Yield',
                    'BAMLEMCBPIOAS': 'ICE BofA Emerging Markets Corporate Plus Index Option-Adjusted Spread',
                    'BAMLCC0A0CMTRIV': 'ICE BofA US Corporate Index Total Return Index Value',
                    'BAMLEMHBHYCRPIOAS': 'ICE BofA High Yield Emerging Markets Corporate Plus Index Option-Adjusted Spread',
                    'BAMLHE00EHYITRIV': 'ICE BofA Euro High Yield Index Total Return Index Value',
                    'BAMLC1A0C13YEY': 'ICE BofA 1-3 Year US Corporate Index Effective Yield',
                    'BAMLEMHBHYCRPIEY': 'ICE BofA High Yield Emerging Markets Corporate Plus Index Effective Yield',
                    'BAMLC2A0C35YEY': 'ICE BofA 3-5 Year US Corporate Index Effective Yield',
                    'BAMLC8A0C15PYEY': 'ICE BofA 15+ Year US Corporate Index Effective Yield',
                    'BAMLC0A1CAAAOAS': 'ICE BofA AAA US Corporate Index Option-Adjusted Spread',
                    'BAMLC0A2CAAOAS': 'ICE BofA AA US Corporate Index Option-Adjusted Spread',
                    'BAMLC0A3CAOAS': 'ICE BofA A US Corporate Index Option-Adjusted Spread',
                    'BAMLC0A4CBBBOAS': 'ICE BofA BBB US Corporate Index Option-Adjusted Spread',
                    'BAMLH0A0HYM2OAS': 'ICE BofA US High Yield Index Option-Adjusted Spread',
                    'BAMLH0A1HYBBOAS': 'ICE BofA BB US High Yield Index Option-Adjusted Spread',
                    'BAMLH0A2HYBOAS': 'ICE BofA B US High Yield Index Option-Adjusted Spread',
                    'BAMLH0A3HYCOAS': 'ICE BofA CCC & Below US High Yield Index Option-Adjusted Spread',
                    'BAMLHE00EHYIOAS': 'ICE BofA Euro High Yield Index Option-Adjusted Spread',
                    'BAMLEMCBPIEY': 'ICE BofA Emerging Markets Corporate Plus Index Effective Yield',
                    'BAMLEMCBPITRIV': 'ICE BofA Emerging Markets Corporate Plus Index Total Return Index Value',
                    'BAMLEMHBHYCRPITRIV': 'ICE BofA High Yield Emerging Markets Corporate Plus Index Total Return Index Value',
                    'BAMLHE00EHYIEY': 'ICE BofA Euro High Yield Index Effective Yield',
                    'BAMLHYH0A0HYM2EY': 'ICE BofA US High Yield Index Effective Yield',
                    'BAMLC0A0CMEY': 'ICE BofA US Corporate Master Index Effective Yield',
                    'BAMLC0A0CMOAS': 'ICE BofA US Corporate Master Index Option-Adjusted Spread',
                    'BAMLC5A0C510YEY': 'ICE BofA 5-10 Year US Corporate Index Effective Yield',
                    'BAMLC3A0C57YEY': 'ICE BofA 5-7 Year US Corporate Index Effective Yield',
                    'BAMLC6A0C1015YEY': 'ICE BofA 10-15 Year US Corporate Index Effective Yield',
                    'BAMLC7A0C1520YEY': 'ICE BofA 15-20 Year US Corporate Index Effective Yield'
                },
                ny_fed: {
                    'sofr': 'Secured Overnight Financing Rate',
                    'effr': 'Effective Federal Funds Rate',
                    'obfr': 'Overnight Bank Funding Rate',
                    'tgcr': 'Tri-party General Collateral Rate',
                    'bgcr': 'Broad General Collateral Rate'
                },
                ecb: {
                    // Exchange Rates
                    'EXR.D.USD.EUR.SP00.A': 'EUR/USD Exchange Rate',
                    'EXR.D.GBP.EUR.SP00.A': 'EUR/GBP Exchange Rate',
                    'EXR.D.JPY.EUR.SP00.A': 'EUR/JPY Exchange Rate',
                    // CISS - Composite Indicator of Systemic Stress
                    'CISS.D.CN.Z0Z.4F.EC.SS_CIN.IDX': 'China Daily Systemic Stress Index',
                    'CISS.D.U2.Z0Z.4F.EC.SS_CIN.IDX': 'Euro Area Daily Systemic Stress Index',
                    'CISS.D.US.Z0Z.4F.EC.SS_CI.IDX': 'US Daily Systemic Stress Index',
                    // Country-specific Sovereign CISS
                    'CISS.M.SE.Z0Z.4F.EC.SOV_CI.IDX': 'Sweden Monthly Sovereign Stress Index',
                    'CISS.M.FR.Z0Z.4F.EC.SOV_CI.IDX': 'France Monthly Sovereign Stress Index',
                    'CISS.M.FI.Z0Z.4F.EC.SOV_CI.IDX': 'Finland Monthly Sovereign Stress Index',
                    'CISS.M.DK.Z0Z.4F.EC.SOV_CI.IDX': 'Denmark Monthly Sovereign Stress Index',
                    'CISS.M.GB.Z0Z.4F.EC.SOV_CI.IDX': 'UK Monthly Sovereign Stress Index',
                    'CISS.M.BE.Z0Z.4F.EC.SOV_CI.IDX': 'Belgium Monthly Sovereign Stress Index',
                    // CLIFS - Country-Level Index of Financial Stress
                    'CLIFS.M.DE._Z.4F.EC.CLIFS_CI.IDX': 'Germany Country-Level Financial Stress Index',
                    // ILM - Interest Rate and Liquidity Measures
                    'ILM.W.U2.C.A030000.U2.Z06': 'Euro Area Weekly Liquidity Measures',
                    'ILM.W.U2.C.L060000.U4.EUR': 'Euro Area Weekly Interest Rate Measures',
                    // BSI - Balance Sheet Items
                    'BSI.W.U2.N.A.A20.A.1.U2.2240.Z01.E': 'Claims on euro area residents denominated in foreign currency - Eurosystem',
                    'BSI.W.U2.N.A.A30.A.1.U2.2240.Z01.E': 'Claims on euro area residents in foreign currency - Total',
                    'BSI.W.U2.N.C.A20.A.1.U2.2240.Z01.E': 'Claims on euro area residents (Consolidated)',
                    'BSI.W.U2.N.C.A30.A.1.U2.2240.Z01.E': 'Claims on euro area residents (Consolidated Total)'
                },
                ofr: {
                    'NYPD-PD_AFtR_T-A': 'NY Primary Dealer After-Fed Total Amount',
                    'NYPD-PD_AFtD_TOT-A': 'NY Primary Dealer After-Fed Total Daily Amount',
                    'REPO_OV_TOT_P75': 'Repo Market Overall Total 75th Percentile',
                    'REPO_OV_TOT_P25': 'Repo Market Overall Total 25th Percentile',
                    'MMF_OV_TOT': 'Money Market Fund Overall Total',
                    'DEALER_OV_TOT': 'Dealer Overall Total',
                    'BANK_OV_TOT': 'Bank Overall Total',
                    'TGCR_VOL': 'Tri-party General Collateral Rate Volume',
                    'SOFR_VOL': 'SOFR Volume'
                },
                treasury: {
                    'BILLS_4W': '4-Week Treasury Bills',
                    'BILLS_8W': '8-Week Treasury Bills',
                    'BILLS_13W': '13-Week Treasury Bills',
                    'BILLS_17W': '17-Week Treasury Bills',
                    'BILLS_26W': '26-Week Treasury Bills',
                    'BILLS_52W': '52-Week Treasury Bills',
                    'NOTES_2Y': '2-Year Treasury Notes',
                    'NOTES_3Y': '3-Year Treasury Notes',
                    'NOTES_5Y': '5-Year Treasury Notes',
                    'NOTES_7Y': '7-Year Treasury Notes',
                    'NOTES_10Y': '10-Year Treasury Notes',
                    'BONDS_20Y': '20-Year Treasury Bonds',
                    'BONDS_30Y': '30-Year Treasury Bonds',
                    'TIPS_5Y': '5-Year TIPS',
                    'TIPS_10Y': '10-Year TIPS',
                    'TIPS_20Y': '20-Year TIPS',
                    'TIPS_30Y': '30-Year TIPS'
                },
                liquidity: {
                    'OFR_FSI': 'OFR Financial Stress Index',
                    'TREASURY_MONITOR': 'Treasury Auction Monitor (Tail & Record Flags)',
                    'NYFED_FAILS': 'NY Fed Primary Dealer Fails (Deliver/Receive)',
                    'LIQUIDITY_DASHBOARD': 'Unified Liquidity Intelligence Dashboard'
                },
                websocket: {
                    'SPX_LIVE': 'S&P 500 Index (Real-Time)',
                    'VIX_LIVE': 'Volatility Index (Real-Time)',
                    'DXY_LIVE': 'Dollar Index (Real-Time)',
                    'BTC_LIVE': 'Bitcoin USD (Real-Time)'
                }
            };
           
            // Check if it's a Polygon ticker
            if (source === 'polygon' && polygonTickersLoaded) {
                const foundTicker = polygonTickers.find(t => t.ticker === symbol);
                if (foundTicker && foundTicker.name) {
                    return foundTicker.name;
                }
            }
           
            return descriptions[source]?.[symbol] || symbol;
        }
       
        // Enhanced detailed descriptions
        function getDetailedDescription(symbol, source) {
            const details = {
                polygon: 'Stock market data',
                fred: 'Economic indicator',
                ny_fed: 'Reference rate',
                ecb: 'European financial indicator',
                ofr: 'Financial research data',
                treasury: 'Treasury auction data',
                liquidity: 'Liquidity stress intelligence',
                websocket: 'Real-time streaming data'
            };
           
            return details[source] || '';
        }
       
        // Display search results
        function displaySearchResults(results, query) {
            const resultsDiv = document.getElementById('searchResults');
           
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="search-item" style="text-align:center; color:#888; padding: 20px;">
                        No results found for "${query}"
                        <div style="margin-top: 10px; font-size: 12px;">
                            Try: AAPL, FEDFUNDS, sofr, EUR/USD, CISS, OFR FSI, Treasury Monitor, SPX_LIVE, VIX, economic calendar
                        </div>
                    </div>
                `;
                return;
            }
           
            // Sort results by relevance and priority
            results.sort((a, b) => {
                const symbolA = a.symbol.toLowerCase();
                const symbolB = b.symbol.toLowerCase();
                const queryLower = query.toLowerCase();
               
                // Exact matches first
                if (symbolA === queryLower) return -1;
                if (symbolB === queryLower) return 1;
               
                // Then by priority if available
                if (a.priority && b.priority) {
                    return b.priority - a.priority;
                }
               
                // Then starts with
                if (symbolA.startsWith(queryLower)) return -1;
                if (symbolB.startsWith(queryLower)) return 1;
               
                return 0;
            });
           
            const displayResults = results.slice(0, 100);
           
            let html = '';
            displayResults.forEach(result => {
                const highlightMatch = (text) => {
                    if (!text) return '';
                    const regex = new RegExp(`(${query.split(' ').join('|')})`, 'gi');
                    return text.replace(regex, '<span style="color: #00ff88; font-weight: bold;">$1</span>');
                };
               
                const typeTag = result.type ? `<span class="search-item-type">${getTickerTypeDescription(result.type)}</span>` : '';
                
                // Add priority indicator for high priority items
                const priorityTag = result.priority >= 90 ? ' 🔥' : result.priority >= 80 ? ' ⭐' : '';
               
                html += `
                    <div class="search-item" onclick="addToWatchlistFromSearch('${result.symbol}', '${result.provider}', '${(result.name || result.symbol).replace(/'/g, "\\'")}')">
                        <div class="search-item-left">
                            <div class="search-item-symbol">${highlightMatch(result.symbol)}${typeTag}${priorityTag}</div>
                            <div class="search-item-name">${highlightMatch(result.name || result.symbol)}</div>
                            ${result.description && result.description !== getTickerTypeDescription(result.type) ? `<div class="search-item-description">${result.description}</div>` : ''}
                        </div>
                        <div class="search-item-source">${result.source.toUpperCase()}</div>
                    </div>
                `;
            });
           
            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }
       
        // Add to watchlist from search
        function addToWatchlistFromSearch(symbol, provider, name) {
            const currentSymbols = watchlists[currentWatchlist].symbols;
           
            if (!currentSymbols.find(s => s.symbol === symbol)) {
                currentSymbols.push({ symbol, provider });
                watchlistSymbols = [...currentSymbols];
                saveWatchlists();
               
                watchlistData[symbol] = {
                    name: name || symbol,
                    provider: provider,
                    price: 0,
                    changes: { '1d': 0, '1w': 0, '1m': 0, '3m': 0, '1y': 0 },
                    changeUnits: { 'daily': 0, 'yearly': 0 },
                    hasData: false
                };
               
                renderWatchlist();
                loadSingleWatchlistItem(symbol, provider);
               
                const sourceLabel = provider.replace('_direct', '').replace('_intelligence', '').replace('_live', '').toUpperCase();
                showTemporaryMessage(`Added ${symbol} from ${sourceLabel} to ${currentWatchlist} watchlist`, 'info');
            } else {
                showTemporaryMessage(`${symbol} is already in ${currentWatchlist} watchlist`, 'info');
            }
           
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchBox').value = '';
        }
       
        // Enhanced data loading for all providers including liquidity intelligence and websocket
        async function loadSingleWatchlistItem(symbol, provider, retryCount = 0) {
            const maxRetries = 3;
           
            try {
                console.log(`Loading ${symbol} from ${provider} (attempt ${retryCount + 1})`);
               
                let url;
               
                // Build URL based on provider type
                if (provider === 'websocket_live') {
                    // Handle WebSocket live data
                    watchlistData[symbol] = {
                        name: watchlistData[symbol]?.name || symbol,
                        provider: provider,
                        price: 0,
                        changes: { '1d': 0, '1w': 0, '1m': 0, '3m': 0, '1y': 0 },
                        changeUnits: { 'daily': 0, 'yearly': 0 },
                        hasData: false,
                        isLive: true
                    };
                    renderWatchlist();
                    return; // WebSocket data will be updated via polling
                } else if (provider === 'liquidity_intelligence') {
                    // Handle liquidity intelligence endpoints
                    if (symbol === 'OFR_FSI') {
                        url = `${API_BASE}/api/v1/ofr/fsi`;
                    } else if (symbol === 'TREASURY_MONITOR') {
                        url = `${API_BASE}/api/v1/treasury/monitor`;
                    } else if (symbol === 'NYFED_FAILS') {
                        url = `${API_BASE}/api/v1/nyfed/fails`;
                    } else if (symbol === 'LIQUIDITY_DASHBOARD') {
                        url = `${API_BASE}/api/v1/liquidity/dashboard`;
                    }
                } else if (provider === 'polygon_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&data_type=quote`;
                } else if (provider === 'fred_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true`;
                } else if (provider === 'ny_fed_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true`;
                } else if (provider === 'ecb_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true`;
                } else if (provider === 'ofr_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true`;
                } else if (provider === 'treasury_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true`;
                } else {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}`;
                }
               
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });
               
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
               
                const data = await response.json();
                console.log(`Data received for ${symbol}:`, data);
               
                if (provider === 'liquidity_intelligence') {
                    processLiquidityIntelligenceData(symbol, data, provider);
                } else if (data.metrics && data.metrics.latest_value !== undefined) {
                    processWatchlistData(symbol, data, provider);
                } else if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                    processWatchlistDataArray(symbol, data.data, provider);
                } else if (data.value !== undefined || data.price !== undefined) {
                    // Handle simple value response
                    processWatchlistData(symbol, {
                        metrics: {
                            latest_value: data.value || data.price || 0,
                            daily_change: data.daily_change || null,
                            weekly_change: data.weekly_change || null,
                            monthly_change: data.monthly_change || null,
                            yearly_change: data.yearly_change || null
                        }
                    }, provider);
                } else {
                    throw new Error('No data available');
                }
               
            } catch (error) {
                console.error(`Error loading ${symbol} from ${provider}:`, error);
               
                if (retryCount < maxRetries) {
                    console.log(`Retrying ${symbol} after delay...`);
                    await new Promise(resolve => setTimeout(resolve, 2000 * (retryCount + 1)));
                    return loadSingleWatchlistItem(symbol, provider, retryCount + 1);
                }
               
                // Show error state
                watchlistData[symbol] = {
                    name: watchlistData[symbol]?.name || symbol,
                    provider: provider,
                    price: 0,
                    changes: { '1d': null, '1w': null, '1m': null, '3m': null, '1y': null },
                    changeUnits: { 'daily': null, 'yearly': null },
                    hasData: false,
                    error: error.message
                };
                renderWatchlist();
            }
        }
       
        // Process liquidity intelligence data
        function processLiquidityIntelligenceData(symbol, data, provider) {
            let latestValue = 0;
            let changes = { '1d': null, '1w': null, '1m': null, '3m': null, '1y': null };
            let changeUnits = { 'daily': null, 'yearly': null };
           
            if (symbol === 'OFR_FSI' && data.metrics) {
                latestValue = data.metrics.latest_value || 0;
                changes = {
                    '1d': data.metrics.daily_change || null,
                    '1w': data.metrics.weekly_change || null,
                    '1m': data.metrics.monthly_change || null,
                    '3m': null,
                    '1y': data.metrics.yearly_change || null
                };
                changeUnits = {
                    'daily': data.metrics.daily_change_units || null,
                    'yearly': data.metrics.yearly_change_units || null
                };
            } else if (symbol === 'TREASURY_MONITOR') {
                latestValue = data.auction_tail_estimate || 0;
                changes['1d'] = data.record_auction_flag ? 100 : 0; // Flag as 100% if record auction
            } else if (symbol === 'NYFED_FAILS' && data.metrics) {
                latestValue = data.metrics.latest_total_fails || 0;
                changes = {
                    '1d': null,
                    '1w': data.metrics.weekly_change || null,
                    '1m': null,
                    '3m': null,
                    '1y': null
                };
            } else if (symbol === 'LIQUIDITY_DASHBOARD') {
                latestValue = data.overall_stress_score || 0;
                changes['1d'] = latestValue * 100; // Convert to percentage
            }
           
            watchlistData[symbol] = {
                name: watchlistData[symbol]?.name || symbol,
                provider: provider,
                price: latestValue,
                changes: changes,
                changeUnits: changeUnits,
                hasData: true,
                latestDate: new Date().toISOString().split('T')[0],
                actualSymbol: symbol,
                lastUpdateTime: Date.now()
            };
           
            // Check for significant changes and trigger flashing
            checkForSignificantChanges(symbol, changes);
           
            renderWatchlist();
        }
       
        // Process watchlist data from your API response with new unit changes
        function processWatchlistData(symbol, data, provider) {
            const metrics = data.metrics || {};
            const latestValue = metrics.latest_value || 0;
           
            // Extract percentage changes if available
            const changes = {
                '1d': metrics.daily_change || null,
                '1w': metrics.weekly_change || null,
                '1m': metrics.monthly_change || null,
                '3m': metrics.quarterly_change || null,
                '1y': metrics.yearly_change || null
            };
           
            // Extract unit changes
            const changeUnits = {
                'daily': metrics.daily_change_units || null,
                'yearly': metrics.yearly_change_units || null
            };
           
            watchlistData[symbol] = {
                name: watchlistData[symbol]?.name || symbol,
                provider: provider,
                price: latestValue,
                changes: changes,
                changeUnits: changeUnits,
                hasData: true,
                latestDate: data.latest_date || new Date().toISOString().split('T')[0],
                actualSymbol: symbol,
                lastUpdateTime: Date.now()
            };
           
            // Check for significant changes and trigger flashing
            checkForSignificantChanges(symbol, changes);
           
            renderWatchlist();
        }
       
        // Process raw data array with unit changes
        function processWatchlistDataArray(symbol, dataArray, provider) {
            if (!dataArray || dataArray.length === 0) return;
           
            // Sort by date
            dataArray.sort((a, b) => new Date(a.date) - new Date(b.date));
           
            const latestItem = dataArray[dataArray.length - 1];
            const latestValue = latestItem.value || latestItem.close || latestItem.price || 0;
           
            // Calculate percentage changes and unit changes
            const changes = calculatePercentageChanges(dataArray);
            const changeUnits = calculateUnitChanges(dataArray);
           
            watchlistData[symbol] = {
                name: watchlistData[symbol]?.name || symbol,
                provider: provider,
                price: latestValue,
                changes: changes,
                changeUnits: changeUnits,
                hasData: true,
                fullData: dataArray,
                latestDate: latestItem.date,
                actualSymbol: symbol,
                lastUpdateTime: Date.now()
            };
           
            // Check for significant changes and trigger flashing
            checkForSignificantChanges(symbol, changes);
           
            renderWatchlist();
        }
       
        // Calculate unit changes from data array
        function calculateUnitChanges(data) {
            if (!data || data.length < 2) {
                return { 'daily': null, 'yearly': null };
            }
           
            const latestItem = data[data.length - 1];
            const latestValue = latestItem.value || latestItem.close || latestItem.price || 0;
            const latestDate = new Date(latestItem.date);
           
            if (!latestValue || latestValue === 0) {
                return { 'daily': null, 'yearly': null };
            }
           
            const changeUnits = {};
            const periods = {
                'daily': 1,
                'yearly': 365
            };
           
            for (const [period, days] of Object.entries(periods)) {
                const targetDate = new Date(latestDate);
                targetDate.setDate(targetDate.getDate() - days);
               
                // Find closest data point
                let closestItem = null;
                let minDiff = Infinity;
               
                for (const item of data) {
                    const itemDate = new Date(item.date);
                    const diff = Math.abs(itemDate - targetDate);
                   
                    if (diff < minDiff && itemDate <= targetDate) {
                        minDiff = diff;
                        closestItem = item;
                    }
                }
               
                if (closestItem) {
                    const historicalValue = closestItem.value || closestItem.close || closestItem.price || 0;
                    if (historicalValue !== null && !isNaN(historicalValue)) {
                        changeUnits[period] = latestValue - historicalValue;
                    } else {
                        changeUnits[period] = null;
                    }
                } else {
                    changeUnits[period] = null;
                }
            }
           
            return changeUnits;
        }
       
        // Calculate percentage changes from data array
        function calculatePercentageChanges(data) {
            if (!data || data.length < 2) {
                return { '1d': null, '1w': null, '1m': null, '3m': null, '1y': null };
            }
           
            const latestItem = data[data.length - 1];
            const latestValue = latestItem.value || latestItem.close || latestItem.price || 0;
            const latestDate = new Date(latestItem.date);
           
            if (!latestValue || latestValue === 0) {
                return { '1d': null, '1w': null, '1m': null, '3m': null, '1y': null };
            }
           
            const changes = {};
            const periods = {
                '1d': 1,
                '1w': 7,
                '1m': 30,
                '3m': 90,
                '1y': 365
            };
           
            for (const [period, days] of Object.entries(periods)) {
                const targetDate = new Date(latestDate);
                targetDate.setDate(targetDate.getDate() - days);
               
                // Find closest data point
                let closestItem = null;
                let minDiff = Infinity;
               
                for (const item of data) {
                    const itemDate = new Date(item.date);
                    const diff = Math.abs(itemDate - targetDate);
                   
                    if (diff < minDiff && itemDate <= targetDate) {
                        minDiff = diff;
                        closestItem = item;
                    }
                }
               
                if (closestItem) {
                    const historicalValue = closestItem.value || closestItem.close || closestItem.price || 0;
                    if (historicalValue && historicalValue !== 0) {
                        changes[period] = ((latestValue - historicalValue) / historicalValue * 100);
                    } else {
                        changes[period] = null;
                    }
                } else {
                    changes[period] = null;
                }
            }
           
            return changes;
        }
       
        // Enhanced flashing logic - only flash for 15%+ changes for 1 week
        function checkForSignificantChanges(symbol, changes) {
            const significantThreshold = 15; // 15% threshold
            const flashDuration = 7 * 24 * 60 * 60 * 1000; // 1 week in milliseconds
           
            // Check daily and weekly changes
            const dailyChange = changes['1d'];
            const weeklyChange = changes['1w'];
           
            let shouldFlash = false;
            let flashType = null;
           
            // Check if daily or weekly change exceeds 15%
            if (dailyChange !== null && Math.abs(dailyChange) >= significantThreshold) {
                shouldFlash = true;
                flashType = dailyChange > 0 ? 'green' : 'red';
            } else if (weeklyChange !== null && Math.abs(weeklyChange) >= significantThreshold) {
                shouldFlash = true;
                flashType = weeklyChange > 0 ? 'green' : 'red';
            }
           
            if (shouldFlash) {
                const currentTime = Date.now();
               
                // Set flash timer for this symbol
                flashTimers[symbol] = {
                    startTime: currentTime,
                    endTime: currentTime + flashDuration,
                    type: flashType
                };
               
                console.log(`🚨 Significant change detected for ${symbol}: ${dailyChange?.toFixed(2)}% daily, ${weeklyChange?.toFixed(2)}% weekly`);
               
                // Clear flash after 1 week
                setTimeout(() => {
                    if (flashTimers[symbol]) {
                        delete flashTimers[symbol];
                        renderWatchlist(); // Re-render to remove flash
                    }
                }, flashDuration);
            }
        }
       
        // Check if symbol should flash
        function shouldSymbolFlash(symbol) {
            const flashInfo = flashTimers[symbol];
            if (!flashInfo) return { flash: false, type: null };
           
            const currentTime = Date.now();
            if (currentTime <= flashInfo.endTime) {
                return { flash: true, type: flashInfo.type };
            } else {
                // Clean up expired flash timer
                delete flashTimers[symbol];
                return { flash: false, type: null };
            }
        }
       
        // Load watchlists from storage
        function loadWatchlists() {
            const saved = localStorage.getItem('openbbWatchlists');
            if (saved) {
                try {
                    const savedData = JSON.parse(saved);
                    Object.keys(savedData).forEach(name => {
                        if (watchlists[name]) {
                            watchlists[name].symbols = savedData[name].symbols || watchlists[name].symbols;
                        }
                    });
                } catch (e) {
                    console.error('Error loading saved watchlists:', e);
                }
            }
           
            watchlistSymbols = [...watchlists[currentWatchlist].symbols];
        }
       
        // Save watchlists to storage
        function saveWatchlists() {
            const toSave = {};
            Object.keys(watchlists).forEach(name => {
                toSave[name] = { symbols: watchlists[name].symbols };
            });
            localStorage.setItem('openbbWatchlists', JSON.stringify(toSave));
        }
       
        // Switch watchlist
        function switchWatchlist(watchlistName) {
            currentWatchlist = watchlistName;
            watchlistSymbols = [...watchlists[currentWatchlist].symbols];
            watchlistData = {};
            loadWatchlistData();
        }
       
        // Load watchlist data
        async function loadWatchlistData() {
            const tbody = document.getElementById('watchlistBody');
           
            if (watchlistSymbols.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 20px; color: #888;">No symbols in watchlist. Use search to add symbols.</td></tr>';
                return;
            }
           
            tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 20px;"><div class="loading-pulse">Loading watchlist...</div></td></tr>';
           
            // Load all symbols in parallel with batching
            const batchSize = 5;
            for (let i = 0; i < watchlistSymbols.length; i += batchSize) {
                const batch = watchlistSymbols.slice(i, i + batchSize);
                const promises = batch.map(symbolObj => {
                    const symbol = symbolObj.symbol || symbolObj;
                    const provider = symbolObj.provider || 'fred_direct';
                    return loadSingleWatchlistItem(symbol, provider);
                });
                await Promise.allSettled(promises);
            }
        }
       
        // Update clock
        function updateClock() {
            document.getElementById('clock').textContent = new Date().toLocaleTimeString('en-US', { hour12: false });
        }
       
        // Enhanced render watchlist with new columns and flashing logic
        function renderWatchlist() {
            const tbody = document.getElementById('watchlistBody');
           
            if (watchlistSymbols.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 20px; color: #666;">No symbols in this watchlist. Use search to add symbols.</td></tr>';
                return;
            }
           
            let symbolsToRender = watchlistSymbols.map(symbolObj => {
                const symbol = symbolObj.symbol || symbolObj;
                const data = watchlistData[symbol];
                if (!data) return null;
               
                let maxChange = 0;
                if (data.changes) {
                    const changes = Object.values(data.changes).filter(v => v !== null && !isNaN(v));
                    if (changes.length > 0) {
                        maxChange = changes.reduce((max, change) => {
                            return Math.abs(change) > Math.abs(max) ? change : max;
                        }, 0);
                    }
                }
               
                // Check if symbol should flash
                const flashInfo = shouldSymbolFlash(symbol);
               
                return {
                    symbol,
                    data,
                    maxChange,
                    flashInfo
                };
            }).filter(item => item !== null);
           
            // Sort based on current sort order
            if (columnSort.column && columnSort.direction) {
                symbolsToRender.sort((a, b) => {
                    const aValue = a.data.changes[columnSort.column];
                    const bValue = b.data.changes[columnSort.column];
                   
                    if (aValue === null || aValue === undefined) return 1;
                    if (bValue === null || bValue === undefined) return -1;
                   
                    return columnSort.direction === 'asc' ? aValue - bValue : bValue - aValue;
                });
            } else if (sortOrder === 'increase') {
                symbolsToRender.sort((a, b) => b.maxChange - a.maxChange);
            } else if (sortOrder === 'decrease') {
                symbolsToRender.sort((a, b) => a.maxChange - b.maxChange);
            }
           
            const formatPrice = (price) => {
                if (price === 0) return 'Loading...';
                if (price >= 1000) return price.toFixed(0);
                if (price >= 1) return price.toFixed(2);
                return price.toFixed(4);
            };
           
            const formatChange = (change) => {
                if (change === null || change === undefined || isNaN(change)) return '—';
                const val = parseFloat(change);
                return (val >= 0 ? '+' : '') + val.toFixed(2) + '%';
            };
           
            const formatUnits = (change) => {
                if (change === null || change === undefined || isNaN(change)) return '—';
                const val = parseFloat(change);
                return (val >= 0 ? '+' : '') + val.toFixed(4);
            };
           
            const getChangeClass = (change) => {
                if (change === null || change === undefined || isNaN(change)) return 'neutral';
                return parseFloat(change) >= 0 ? 'positive' : 'negative';
            };
           
            const html = symbolsToRender.map(({ symbol, data, flashInfo }) => {
                const flashClass = flashInfo.flash ?
                    (flashInfo.type === 'green' ? 'flash-green' : 'flash-red') : '';
               
                const displayName = data.customName || symbol;
                const colorStyle = data.color ? `background-color: ${data.color};` : 'display: none;';
                const providerLabel = data.provider?.replace('_direct', '').replace('_intelligence', '').replace('_live', '').toUpperCase() || 'API';
               
                // Add live indicator for websocket data
                const liveIndicator = data.isLive ? ' 🔴' : '';
               
                return `
                    <tr ondblclick="openChartForSymbol('${symbol}', '${data.provider || 'fred_direct'}')"
                        class="${flashClass}"
                        style="cursor: pointer;"
                        title="Double-click to view chart">
                        <td>
                            <div class="symbol-cell">
                                <div class="color-tag" style="${colorStyle}" onclick="editSymbol(event, '${symbol}')"></div>
                                <div class="symbol-icon">${symbol.charAt(0)}</div>
                                <div class="symbol-info">
                                    <div class="symbol-name">
                                        ${displayName}${liveIndicator}
                                        <span class="edit-icon" onclick="editSymbol(event, '${symbol}')">✏️</span>
                                    </div>
                                    <div class="symbol-fullname">${data.name} (${providerLabel})</div>
                                </div>
                            </div>
                        </td>
                        <td class="price-cell">${formatPrice(data.price)}</td>
                        <td class="change-cell ${getChangeClass(data.changeUnits?.daily)}">${formatUnits(data.changeUnits?.daily)}</td>
                        <td class="change-cell ${getChangeClass(data.changes['1d'])}">${formatChange(data.changes['1d'])}</td>
                        <td class="change-cell ${getChangeClass(data.changes['1w'])}">${formatChange(data.changes['1w'])}</td>
                        <td class="change-cell ${getChangeClass(data.changes['1m'])}">${formatChange(data.changes['1m'])}</td>
                        <td class="change-cell ${getChangeClass(data.changes['1y'])}">${formatChange(data.changes['1y'])}</td>
                        <td class="change-cell ${getChangeClass(data.changeUnits?.yearly)}">${formatUnits(data.changeUnits?.yearly)}</td>
                        <td style="padding: 5px;">
                            <button class="control-btn" style="padding: 4px 8px; font-size: 11px; background: #f5f5f5; color: #333; border: 1px solid #ddd;"
                                    onclick="removeFromWatchlist(event, '${symbol}')">×</button>
                        </td>
                    </tr>
                `;
            }).join('');
           
            tbody.innerHTML = html || '<tr><td colspan="9" style="text-align: center; padding: 20px; color: #666;">Loading data...</td></tr>';
           
            updateSortIndicators();
        }
       
        // Remove from watchlist
        function removeFromWatchlist(event, symbol) {
            event.stopPropagation();
            const currentSymbols = watchlists[currentWatchlist].symbols;
            const index = currentSymbols.findIndex(s => (s.symbol || s) === symbol);
            if (index > -1) {
                currentSymbols.splice(index, 1);
                watchlistSymbols = [...currentSymbols];
                delete watchlistData[symbol];
               
                // Clear flash timer if exists
                if (flashTimers[symbol]) {
                    delete flashTimers[symbol];
                }
               
                saveWatchlists();
                renderWatchlist();
                showTemporaryMessage(`Removed ${symbol} from ${currentWatchlist} watchlist`, 'info');
            }
        }
       
        // Sort by column
        function sortByColumn(period) {
            if (columnSort.column === period) {
                columnSort.direction = columnSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                columnSort.column = period;
                columnSort.direction = 'desc';
            }
           
            sortOrder = 'default';
            updateSortButtons();
            renderWatchlist();
        }
       
        // Update sort indicators
        function updateSortIndicators() {
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.className = 'sort-indicator';
            });
           
            if (columnSort.column && columnSort.direction) {
                const indicator = document.getElementById(`sort-${columnSort.column}`);
                if (indicator) {
                    indicator.className = `sort-indicator ${columnSort.direction}`;
                }
            }
        }
       
        // Change sort order
        function changeSortOrder(order) {
            sortOrder = order;
            columnSort = { column: null, direction: null };
            updateSortButtons();
            renderWatchlist();
        }
       
        // Update sort buttons
        function updateSortButtons() {
            document.getElementById('sortDefault').classList.toggle('active', sortOrder === 'default');
            document.getElementById('sortIncrease').classList.toggle('active', sortOrder === 'increase');
            document.getElementById('sortDecrease').classList.toggle('active', sortOrder === 'decrease');
        }

        // ===========================================
        // ENHANCED CHART FUNCTIONS FROM SECOND CODE
        // ===========================================

        // Enhanced chart functions with new data display options including technical indicators
        function addNewChart() {
            const chartId = `chart_${chartIdCounter++}`;
           
            const chartHtml = `
                <div class="chart-window" id="${chartId}" onclick="setActiveChart('${chartId}')">
                    <div class="chart-header">
                        <div class="chart-title-section">
                            <div class="chart-title" id="${chartId}_title">Chart ${chartIdCounter}</div>
                            <div class="chart-symbols" id="${chartId}_symbols"></div>
                            <div class="chart-display-controls">
                                <button class="display-toggle active" onclick="toggleChartDisplay(event, '${chartId}', 'raw')" data-display="raw">Raw Data</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'pct_change')" data-display="pct_change">% Change</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'unit_change')" data-display="unit_change">Unit Change</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'year_pct')" data-display="year_pct">Year % Change</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'year_units')" data-display="year_units">Year Unit Change</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'slope')" data-display="slope">Slope (30)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'macd')" data-display="macd">MACD</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'zscore')" data-display="zscore">Z-Score (30)</button>
                                <button class="display-toggle" onclick="toggleChartDisplay(event, '${chartId}', 'signals')" data-display="signals">Buy/Sell Signals</button>
                            </div>
                        </div>
                        <div class="chart-controls">
                            <div class="timeframe-buttons" id="${chartId}_timeframe_buttons">
                                ${['1D','1W','1M','3M','6M','1Y','2Y','5Y','10Y','MAX'].map(tf =>
                                    `<button class="timeframe-btn ${tf === '1Y' ? 'active' : ''}"
                                             onclick="changeTimeframe(event, '${chartId}', '${tf}')">${tf}</button>`
                                ).join('')}
                            </div>
                            <button class="close-btn" onclick="removeChart(event, '${chartId}')">×</button>
                        </div>
                    </div>
                    <div class="chart-canvas" id="${chartId}_canvas">
                        <div class="chart-message">Search for a financial indicator to add to this chart</div>
                    </div>
                </div>`;
           
            document.getElementById('chartGrid').insertAdjacentHTML('beforeend', chartHtml);
            charts[chartId] = {
                symbols: [],
                data: {},
                timeframe: '1Y',
                chartInstance: null,
                displayMode: 'raw'
            };
            setActiveChart(chartId);
           
            const chartsArea = document.getElementById('chartsArea');
            const watchlistSection = document.querySelector('.watchlist-section');
            const chartViewBtn = document.getElementById('chartViewBtn');
           
            chartsArea.style.display = 'block';
            watchlistSection.style.flex = '0 0 300px';
            chartViewBtn.style.display = 'block';
        }
       
        // Toggle chart display mode with enhanced options
        function toggleChartDisplay(event, chartId, displayMode) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
           
            chart.displayMode = displayMode;
           
            // Update button states
            const controlsDiv = event.target.parentElement;
            controlsDiv.querySelectorAll('.display-toggle').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
           
            updateChartRender(chartId);
        }

        function setActiveChart(chartId) {
            if (activeChartId === chartId) return;
            activeChartId = chartId;
            document.querySelectorAll('.chart-window').forEach(c => c.classList.remove('active-chart'));
            const chartElement = document.getElementById(chartId);
            if (chartElement) {
                chartElement.classList.add('active-chart');
            }
        }

        function removeChart(event, chartIdToRemove) {
            event.stopPropagation();
            if (charts[chartIdToRemove] && charts[chartIdToRemove].chartInstance) {
                Plotly.purge(`${chartIdToRemove}_canvas`);
            }
            delete charts[chartIdToRemove];
            document.getElementById(chartIdToRemove)?.remove();
           
            if (activeChartId === chartIdToRemove) {
                const chartKeys = Object.keys(charts);
                activeChartId = chartKeys.length > 0 ? chartKeys[chartKeys.length - 1] : null;
                if(activeChartId) setActiveChart(activeChartId);
            }
           
            if (Object.keys(charts).length === 0) {
                const chartsArea = document.getElementById('chartsArea');
                const watchlistSection = document.querySelector('.watchlist-section');
                const chartViewBtn = document.getElementById('chartViewBtn');
               
                chartsArea.style.display = 'none';
                watchlistSection.style.flex = '1';
                chartViewBtn.style.display = 'none';
            }
        }

        function openChartForSymbol(symbol, provider) {
            const chartsArea = document.getElementById('chartsArea');
            const watchlistSection = document.querySelector('.watchlist-section');
            const chartViewBtn = document.getElementById('chartViewBtn');
           
            chartsArea.style.display = 'block';
            watchlistSection.style.flex = '0 0 300px';
            chartViewBtn.style.display = 'block';
           
            if (Object.keys(charts).length === 0) {
                addNewChart();
            }
           
            if (activeChartId) {
                const data = watchlistData[symbol];
                addToChart(activeChartId, symbol, provider, data?.name || symbol);
            }
        }

        function addToChart(chartId, symbol, provider, name) {
            const chart = charts[chartId];
            if (!chart) return;
           
            if (!chart.symbols.find(s => s.symbol === symbol)) {
                chart.symbols.push({ symbol, provider, name });
                loadChartData(chartId, symbol, provider);
            }
            setActiveChart(chartId);
        }

        // Enhanced chart data loading with technical indicators support
        async function loadChartData(chartId, symbol, provider) {
            const chart = charts[chartId];
            if (!chart) return;
           
            const canvasDiv = document.getElementById(`${chartId}_canvas`);
            if (canvasDiv) canvasDiv.innerHTML = `<div class="chart-message loading-pulse">Loading ${symbol} from ${provider}...</div>`;
           
            try {
                let url;
               
                // Enhanced data loading for extended historical periods
                const endDate = new Date().toISOString().split('T')[0];
                let startDate = new Date();
               
                // Set appropriate historical period based on provider
                if (provider === 'polygon_direct') {
                    startDate.setFullYear(startDate.getFullYear() - 10); // 10 years for stocks
                } else if (['fred_direct', 'ecb_direct', 'ny_fed_direct', 'ofr_direct'].includes(provider)) {
                    startDate.setFullYear(startDate.getFullYear() - 20); // 20 years for economic data
                } else {
                    startDate.setFullYear(startDate.getFullYear() - 5); // 5 years default
                }
               
                const startDateStr = startDate.toISOString().split('T')[0];
               
                if (provider === 'websocket_live') {
                    // WebSocket data doesn't support historical charts
                    throw new Error('Real-time data does not support historical charts');
                } else if (provider === 'liquidity_intelligence') {
                    // Handle liquidity intelligence endpoints for charts
                    if (symbol === 'OFR_FSI') {
                        url = `${API_BASE}/api/v1/ofr/fsi`;
                    } else if (symbol === 'NYFED_FAILS') {
                        url = `${API_BASE}/api/v1/nyfed/fails`;
                    } else {
                        throw new Error('Chart not available for this liquidity intelligence indicator');
                    }
                } else if (provider === 'polygon_direct') {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&data_type=historical&start_date=${startDateStr}&end_date=${endDate}`;
                } else if (provider === 'fred_direct') {
                    // Use FRED series observations endpoint for maximum data
                    url = `${API_BASE}/api/v1/fred/series/observations?series_id=${symbol}&limit=10000&sort_order=asc&include_pandas=false`;
                } else {
                    url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true&start_date=${startDateStr}&end_date=${endDate}`;
                }
               
                console.log(`Chart data URL for ${symbol}: ${url}`);
                const response = await fetch(url);
               
                if (!response.ok) {
                    throw new Error(`Failed to load data: ${response.status}`);
                }
               
                const result = await response.json();
                console.log(`Chart data received for ${symbol}:`, result);
               
                let processedData = [];
               
                if (result.data && Array.isArray(result.data)) {
                    processedData = result.data
                        .map(item => {
                            let value = item.value || item.close || item.price || item.rate || null;
                            if (typeof value === 'string') {
                                value = parseFloat(value);
                            }
                           
                            return {
                                date: item.date || item.time || item.period,
                                value: value
                            };
                        })
                        .filter(item => item.value !== null && !isNaN(item.value) && item.date)
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                } else if (result.observations && Array.isArray(result.observations)) {
                    // FRED observations format
                    processedData = result.observations
                        .map(obs => ({
                            date: obs.date,
                            value: obs.value !== '.' ? parseFloat(obs.value) : null
                        }))
                        .filter(item => item.value !== null && !isNaN(item.value))
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                }
               
                if (processedData.length === 0) {
                    throw new Error('No valid data points found');
                }
               
                console.log(`Processed ${processedData.length} data points for ${symbol}`);
               
                // Calculate chart changes and technical indicators
                processedData = calculateChartChanges(processedData);
                processedData = calculateTechnicalIndicators(processedData);
               
                chart.data[symbol] = processedData;
                updateChartRender(chartId);
                updateChartSymbols(chartId);
               
            } catch (error) {
                console.error(`Error loading chart data for ${symbol}:`, error);
                if (canvasDiv) {
                    canvasDiv.innerHTML = `<div class="chart-message" style="color: #ff4444;">Error loading ${symbol}<br><small>${error.message}</small></div>`;
                }
                chart.symbols = chart.symbols.filter(s => s.symbol !== symbol);
                updateChartSymbols(chartId);
            }
        }
       
        // Calculate additional changes for chart data
        function calculateChartChanges(data) {
            if (!data || data.length === 0) return data;
           
            return data.map((item, index, arr) => {
                const newItem = { ...item };
                const currentDate = new Date(item.date);
               
                // Helper function to find previous value by days
                const findPreviousValue = (daysAgo) => {
                    const targetDate = new Date(currentDate);
                    targetDate.setDate(currentDate.getDate() - daysAgo);
                   
                    for (let i = index - 1; i >= 0; i--) {
                        if (new Date(arr[i].date) <= targetDate) {
                            return arr[i].value;
                        }
                    }
                    return null;
                };
               
                // Calculate various period changes
                const prevDayValue = (index > 0) ? arr[index-1].value : null;
                const prevWeekValue = findPreviousValue(7);
                const prevYearValue = findPreviousValue(365);
               
                if (prevDayValue !== null && prevDayValue !== 0) {
                    newItem.daily_pct_change = ((item.value - prevDayValue) / prevDayValue) * 100;
                    newItem.daily_change_units = item.value - prevDayValue;
                }
               
                if (prevWeekValue !== null && prevWeekValue !== 0) {
                    newItem.weekly_pct_change = ((item.value - prevWeekValue) / prevWeekValue) * 100;
                    newItem.weekly_change_units = item.value - prevWeekValue;
                }
               
                if (prevYearValue !== null && prevYearValue !== 0) {
                    newItem.yearly_pct_change = ((item.value - prevYearValue) / prevYearValue) * 100;
                    newItem.yearly_change_units = item.value - prevYearValue;
                }
               
                return newItem;
            });
        }
       
        // Calculate technical indicators including MACD, slope, z-score, and signals
        function calculateTechnicalIndicators(data) {
            if (!data || data.length === 0) return data;
           
            const values = data.map(d => d.value);
           
            // Calculate EMA helper function
            const calculateEMA = (period, dataArray) => {
                if (dataArray.length < period) return dataArray.map(() => null);
               
                const k = 2 / (period + 1);
                const emaArray = [];
               
                // Initialize with SMA
                let ema = dataArray.slice(0, period).reduce((sum, val) => sum + val, 0) / period;
                emaArray.push(...Array(period - 1).fill(null), ema);
               
                // Calculate EMA for remaining values
                for (let i = period; i < dataArray.length; i++) {
                    ema = (dataArray[i] - ema) * k + ema;
                    emaArray.push(ema);
                }
               
                return emaArray;
            };
           
            // Calculate MACD components
            const ema12Values = calculateEMA(12, values);
            const ema26Values = calculateEMA(26, values);
            const macdLine = ema12Values.map((e12, i) =>
                ema26Values[i] !== null && e12 !== null ? e12 - ema26Values[i] : null
            );
           
            // Calculate MACD signal line (9-period EMA of MACD line)
            const validMacdValues = macdLine.filter(val => val !== null);
            const signalLineValues = validMacdValues.length >= 9 ?
                calculateEMA(9, validMacdValues) : validMacdValues.map(() => null);
           
            let signalLineIndex = 0;
           
            return data.map((item, index) => {
                let slope30 = null;
                let zscore30 = null;
                let signal = null;
                let currentMacd = macdLine[index];
                let currentSignal = null;
               
                // Get MACD signal value
                if (macdLine[index] !== null) {
                    if (signalLineIndex < signalLineValues.length) {
                        currentSignal = signalLineValues[signalLineIndex++];
                    }
                }
               
                // Calculate 30-period slope and z-score
                if (index >= 29) {
                    const window = values.slice(index - 29, index + 1);
                    const n = window.length;
                    const x = Array.from({length: n}, (_, i) => i);
                   
                    // Linear regression for slope
                    const sumX = x.reduce((a, b) => a + b, 0);
                    const sumY = window.reduce((a, b) => a + b, 0);
                    const sumXY = x.reduce((sum, xi, i) => sum + xi * window[i], 0);
                    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                   
                    if ((n * sumX2 - sumX * sumX) !== 0) {
                        slope30 = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    }
                   
                    // Z-score calculation
                    const mean = sumY / n;
                    const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
                    const stdDev = Math.sqrt(variance);
                   
                    if (stdDev > 0) {
                        zscore30 = (item.value - mean) / stdDev;
                    }
                }
               
                // Generate buy/sell signals based on multiple indicators
                if (currentMacd !== null && currentSignal !== null && slope30 !== null && zscore30 !== null) {
                    // Buy signal: MACD above signal, positive slope, oversold (z-score < -1.5)
                    if (currentMacd > currentSignal && slope30 > 0 && zscore30 < -1.5) {
                        signal = 1; // Buy
                    }
                    // Sell signal: MACD below signal, negative slope, overbought (z-score > 1.5)
                    else if (currentMacd < currentSignal && slope30 < 0 && zscore30 > 1.5) {
                        signal = -1; // Sell
                    }
                    else {
                        signal = 0; // Hold
                    }
                }
               
                return {
                    ...item,
                    slope_30: slope30,
                    ema12: ema12Values[index],
                    ema26: ema26Values[index],
                    macd: currentMacd,
                    macd_signal: currentSignal,
                    zscore_30: zscore30,
                    signal: signal
                };
            });
        }

        function updateChartSymbols(chartId) {
            const chart = charts[chartId];
            if (!chart) return;
            const symbolsDiv = document.getElementById(`${chartId}_symbols`);
            if (!symbolsDiv) return;
           
            symbolsDiv.innerHTML = chart.symbols.map((s, i) => `
                <div class="chart-symbol-tag">
                    <span class="symbol-color-dot" style="background-color: ${colorPalette[i % colorPalette.length]};"></span>
                    ${s.symbol}
                    <span class="remove-symbol" onclick="removeSymbolFromChart(event, '${chartId}', '${s.symbol}')">×</span>
                </div>`).join('');
        }

        function removeSymbolFromChart(event, chartId, symbolToRemove) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;

            chart.symbols = chart.symbols.filter(s => s.symbol !== symbolToRemove);
            delete chart.data[symbolToRemove];
           
            updateChartRender(chartId);
            updateChartSymbols(chartId);
           
            if (chart.symbols.length === 0) {
                document.getElementById(`${chartId}_canvas`).innerHTML = '<div class="chart-message">Search for a financial indicator to add to this chart</div>';
            }
        }

        function changeTimeframe(event, chartId, timeframe) {
            event.stopPropagation();
            const chart = charts[chartId];
            if (!chart) return;
            chart.timeframe = timeframe;
           
            const buttonContainer = document.getElementById(`${chartId}_timeframe_buttons`);
            if (buttonContainer) {
                buttonContainer.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
                if(event.target.tagName === 'BUTTON') event.target.classList.add('active');
            }
            updateChartRender(chartId);
        }

        function filterDataByTimeframe(data, timeframe) {
            if (!data || data.length === 0) return data;
           
            const now = new Date();
            let cutoffDate = new Date();
           
            switch(timeframe) {
                case '1D':
                    cutoffDate.setDate(now.getDate() - 1);
                    break;
                case '1W':
                    cutoffDate.setDate(now.getDate() - 7);
                    break;
                case '1M':
                    cutoffDate.setMonth(now.getMonth() - 1);
                    break;
                case '3M':
                    cutoffDate.setMonth(now.getMonth() - 3);
                    break;
                case '6M':
                    cutoffDate.setMonth(now.getMonth() - 6);
                    break;
                case '1Y':
                    cutoffDate.setFullYear(now.getFullYear() - 1);
                    break;
                case '2Y':
                    cutoffDate.setFullYear(now.getFullYear() - 2);
                    break;
                case '5Y':
                    cutoffDate.setFullYear(now.getFullYear() - 5);
                    break;
                case '10Y':
                    cutoffDate.setFullYear(now.getFullYear() - 10);
                    break;
                case 'MAX':
                    return data;
            }
           
            return data.filter(item => new Date(item.date) >= cutoffDate);
        }

        // Enhanced chart rendering with all display modes and technical indicators
        function updateChartRender(chartId) {
            const chart = charts[chartId];
            const canvasElement = document.getElementById(`${chartId}_canvas`);
            if (!canvasElement || !chart) return;
           
            if (chart.symbols.length === 0) {
                canvasElement.innerHTML = '<div class="chart-message">Search for a financial indicator to add to this chart</div>';
                if (chart.chartInstance) Plotly.purge(canvasElement);
                return;
            }
           
            const traces = [];
            const displayMode = chart.displayMode || 'raw';
            let yLabel = 'Value';
           
            chart.symbols.forEach((s, index) => {
                const symbolData = chart.data[s.symbol];
                if (!symbolData || symbolData.length === 0) return;
               
                const filteredData = filterDataByTimeframe(symbolData, chart.timeframe);
                if (filteredData.length === 0) return;
               
                const lineColor = colorPalette[index % colorPalette.length];
               
                let yData, hoverTemplate;
               
                // Determine what data to display based on mode
                switch (displayMode) {
                    case 'pct_change':
                        yData = filteredData.map(d => d.daily_pct_change || 0);
                        yLabel = '% Change';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>% Change: %{y:.2f}%<extra></extra>`;
                        break;
                    case 'unit_change':
                        yData = filteredData.map(d => d.daily_change_units || 0);
                        yLabel = 'Unit Change';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Unit Change: %{y:.4f}<extra></extra>`;
                        break;
                    case 'year_pct':
                        yData = filteredData.map(d => d.yearly_pct_change || 0);
                        yLabel = 'Yearly % Change';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Yearly % Change: %{y:.2f}%<extra></extra>`;
                        break;
                    case 'year_units':
                        yData = filteredData.map(d => d.yearly_change_units || 0);
                        yLabel = 'Yearly Unit Change';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Yearly Unit Change: %{y:.4f}<extra></extra>`;
                        break;
                    case 'slope':
                        yData = filteredData.map(d => d.slope_30 || 0);
                        yLabel = 'Slope (30-period)';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Slope: %{y:.6f}<extra></extra>`;
                        break;
                    case 'macd':
                        yData = filteredData.map(d => d.macd || 0);
                        yLabel = 'MACD';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>MACD: %{y:.4f}<extra></extra>`;
                        break;
                    case 'zscore':
                        yData = filteredData.map(d => d.zscore_30 || 0);
                        yLabel = 'Z-Score (30-period)';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Z-Score: %{y:.2f}<extra></extra>`;
                        break;
                    case 'signals':
                        yData = filteredData.map(d => d.signal || 0);
                        yLabel = 'Buy/Sell Signals';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Signal: %{y}<extra></extra>`;
                        break;
                    default: // 'raw'
                        yData = filteredData.map(d => d.value);
                        yLabel = 'Value';
                        hoverTemplate = `<b>${s.symbol}</b><br>Date: %{x}<br>Value: %{y:.4f}<extra></extra>`;
                }
               
                const trace = {
                    x: filteredData.map(d => d.date),
                    y: yData,
                    type: 'scatter',
                    mode: displayMode === 'signals' ? 'markers' : 'lines',
                    name: s.symbol,
                    hovertemplate: hoverTemplate
                };
               
                if (displayMode === 'signals') {
                    trace.marker = {
                        color: yData.map(v => v === 1 ? '#00ff88' : v === -1 ? '#ff4444' : '#888888'),
                        size: yData.map(v => v !== 0 ? 12 : 6),
                        symbol: yData.map(v => v === 1 ? 'triangle-up' : v === -1 ? 'triangle-down' : 'circle')
                    };
                } else {
                    trace.line = { color: lineColor, width: 2 };
                }
               
                traces.push(trace);
               
                // Add MACD signal line if in MACD mode
                if (displayMode === 'macd') {
                    const signalData = filteredData.map(d => d.macd_signal || null);
                    if (signalData.some(v => v !== null)) {
                        traces.push({
                            x: filteredData.map(d => d.date),
                            y: signalData,
                            type: 'scatter',
                            mode: 'lines',
                            name: `${s.symbol} Signal`,
                            line: { color: lineColor, width: 1, dash: 'dash' },
                            hovertemplate: `<b>${s.symbol} Signal</b><br>Date: %{x}<br>Signal: %{y:.4f}<extra></extra>`
                        });
                    }
                }
            });
           
            if (traces.length === 0) {
                canvasElement.innerHTML = '<div class="chart-message">No data to display for selected timeframe</div>';
                return;
            }
           
            const layout = {
                title: {
                    text: `${displayMode.replace('_', ' ').toUpperCase()} VIEW`,
                    font: { color: '#fff', size: 14 },
                    x: 0.5
                },
                paper_bgcolor: '#0a0a0a',
                plot_bgcolor: '#0a0a0a',
                font: { color: '#aaa', size: 12 },
                margin: { t: 60, r: 80, b: 60, l: 80 },
                xaxis: {
                    type: 'date',
                    gridcolor: '#22222250',
                    tickfont: { color: '#888' },
                    rangeslider: { visible: false }
                },
                yaxis: {
                    title: { text: yLabel, font: { color: '#aaa' } },
                    gridcolor: '#22222250',
                    tickfont: { color: '#888' },
                    zeroline: true,
                    zerolinecolor: '#444',
                    zerolinewidth: 1
                },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1,
                    bgcolor: 'rgba(10,10,10,0.8)',
                    bordercolor: '#333',
                    borderwidth: 1,
                    font: { size: 11 }
                },
                height: 500,
                autosize: true
            };
           
            const config = {
                responsive: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['select2d', 'lasso2d', 'toImage'],
                displayModeBar: true
            };
           
            if(canvasElement.querySelector('.chart-message')) canvasElement.innerHTML = '';
           
            Plotly.react(canvasElement, traces, layout, config)
                .then(gd => {
                    charts[chartId].chartInstance = gd;
                })
                .catch(err => {
                    console.error("Plotly error:", err);
                    canvasElement.innerHTML = `<div class="chart-message" style="color: #ff4444;">Chart error: ${err.message}</div>`;
                });
        }

        function showChartView() {
            const chartsArea = document.getElementById('chartsArea');
            const watchlistSection = document.querySelector('.watchlist-section');
           
            if (chartsArea.style.display === 'none') {
                chartsArea.style.display = 'block';
                watchlistSection.style.flex = '0 0 300px';
            } else {
                chartsArea.style.display = 'none';
                watchlistSection.style.flex = '1';
            }
        }

        // ===========================================
        // END OF ENHANCED CHART FUNCTIONS
        // ===========================================

        // ===========================================
        // RISK DASHBOARD FUNCTIONS
        // ===========================================
       
        function initializeRiskDashboard() {
            setupRiskConfiguration();
            loadRiskDashboardData();
            setInterval(loadRiskDashboardData, 120000); // Every 2 minutes
        }
       
        function setupRiskConfiguration() {
            const categories = ['risk', 'liquidity', 'economic', 'global'];
            const containers = {
                risk: 'riskSymbols',
                liquidity: 'liquiditySymbols',
                economic: 'economicSymbols',
                global: 'globalSymbols'
            };
           
            categories.forEach(catKey => {
                const container = document.getElementById(containers[catKey]);
                if (!container) return;
               
                container.innerHTML = '';
                const category = riskCategories[catKey];
               
                category.symbols.forEach(symbol => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'symbol-checkbox';
                    checkboxDiv.innerHTML = `
                        <input type="checkbox" id="${catKey}_${symbol}" checked onchange="updateCategoryConfig('${catKey}', '${symbol}', this.checked)">
                        <label for="${catKey}_${symbol}">${getSymbolDescription(symbol, getProviderForSymbol(symbol))}</label>
                    `;
                    container.appendChild(checkboxDiv);
                });
            });
        }
       
        function getProviderForSymbol(symbol) {
            // Map symbols to their providers
            if (symbol.includes('CISS.') || symbol.includes('EXR.') || symbol.includes('ILM.')) return 'ecb';
            if (['tgcr', 'bgcr', 'sofr', 'effr', 'obfr'].includes(symbol.toLowerCase())) return 'ny_fed';
            return 'fred'; // Default to FRED for most economic indicators
        }
       
        function updateCategoryConfig(category, symbol, enabled) {
            if (!riskCategories[category]) return;
           
            if (!enabled) {
                riskCategories[category].symbols = riskCategories[category].symbols.filter(s => s !== symbol);
            } else if (!riskCategories[category].symbols.includes(symbol)) {
                riskCategories[category].symbols.push(symbol);
            }
        }
       
        function toggleRiskDashboard() {
            const dashboard = document.getElementById('riskDashboard');
            const chartsArea = document.getElementById('chartsArea');
            const watchlistSection = document.querySelector('.watchlist-section');
           
            if (dashboard.classList.contains('active')) {
                dashboard.classList.remove('active');
                watchlistSection.style.flex = '1';
            } else {
                dashboard.classList.add('active');
                chartsArea.style.display = 'none';
                watchlistSection.style.flex = '0 0 300px';
                loadRiskDashboardData();
            }
        }
       
        function toggleConfig() {
            const configPanel = document.getElementById('watchlistConfig');
            configPanel.style.display = configPanel.style.display === 'none' ? 'block' : 'none';
        }
       
        async function loadRiskDashboardData() {
            // Collect all unique symbols from risk categories
            const allSymbols = new Set();
            Object.values(riskCategories).forEach(category => {
                category.symbols.forEach(symbol => allSymbols.add(symbol));
            });
           
            // Load data for all symbols
            const promises = Array.from(allSymbols).map(symbol => {
                const provider = getProviderForSymbol(symbol) + '_direct';
                return loadRiskSymbolData(symbol, provider);
            });
           
            await Promise.all(promises);
           
            // Calculate risk scores and update display
            calculateRiskScores();
            updateRiskGauges();
            updateAlertIndicators();
        }
       
        async function loadRiskSymbolData(symbol, provider, retryCount = 0) {
            try {
                const url = `${API_BASE}/api/v1/universal/data?symbol=${symbol}&provider=${provider}&include_changes=true`;
                const response = await fetch(url);
               
                if (!response.ok) {
                    throw new Error(`API returned ${response.status} for ${symbol}`);
                }
               
                const data = await response.json();
               
                if (data.metrics && data.metrics.latest_value !== undefined) {
                    riskDashboardData[symbol] = {
                        value: data.metrics.latest_value,
                        daily_change: data.metrics.daily_change || 0,
                        weekly_change: data.metrics.weekly_change || 0,
                        monthly_change: data.metrics.monthly_change || 0,
                        provider: provider,
                        timestamp: Date.now()
                    };
                } else {
                    console.warn(`Risk data format issue for ${symbol}:`, data);
                    riskDashboardData[symbol] = {
                        value: 0,
                        daily_change: 0,
                        weekly_change: 0,
                        monthly_change: 0,
                        error: true
                    };
                }
            } catch (error) {
                if (retryCount < 2) {
                    await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
                    return loadRiskSymbolData(symbol, provider, retryCount + 1);
                }
               
                console.error(`Failed to load risk data for ${symbol}:`, error);
                riskDashboardData[symbol] = {
                    value: 0,
                    daily_change: 0,
                    weekly_change: 0,
                    monthly_change: 0,
                    error: true
                };
            }
        }
       
        function calculateRiskScores() {
            Object.keys(riskCategories).forEach(catKey => {
                const category = riskCategories[catKey];
                const scores = [];
               
                category.symbols.forEach(symbol => {
                    if (riskDashboardData[symbol] && !riskDashboardData[symbol].error) {
                        const data = riskDashboardData[symbol];
                       
                        // Calculate volatility-based risk score
                        const changes = [
                            Math.abs(data.daily_change),
                            Math.abs(data.weekly_change),
                            Math.abs(data.monthly_change)
                        ].filter(x => x !== null && !isNaN(x) && x !== 0);
                       
                        if (changes.length > 0) {
                            const mean = changes.reduce((a, b) => a + b, 0) / changes.length;
                            const variance = changes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / changes.length;
                            const stdDev = Math.sqrt(variance);
                           
                            // Calculate z-score for current daily change
                            let zScore = 0;
                            if (stdDev > 0.0001) {
                                zScore = Math.abs(data.daily_change || 0) / stdDev;
                            } else if (Math.abs(data.daily_change || 0) > 0) {
                                zScore = 3; // High volatility if no historical variation
                            }
                           
                            // Convert z-score to 0-100 scale
                            const riskScore = Math.min(100, Math.max(0, (zScore / 3) * 100));
                            scores.push(riskScore);
                        } else {
                            scores.push(0);
                        }
                    } else {
                        scores.push(0);
                    }
                });
               
                // Calculate average risk score for category
                const avgScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
                category.currentScore = Math.round(avgScore);
               
                // Determine alert level
                if (avgScore >= category.thresholds.extreme) {
                    category.alertLevel = 'extreme';
                } else if (avgScore >= category.thresholds.critical) {
                    category.alertLevel = 'high';
                } else if (avgScore >= category.thresholds.warning) {
                    category.alertLevel = 'moderate';
                } else {
                    category.alertLevel = 'low';
                }
            });
        }
       
        function updateRiskGauges() {
            const gaugeGrid = document.getElementById('gaugeGrid');
            if (!gaugeGrid) return;
           
            gaugeGrid.innerHTML = '';
           
            Object.keys(riskCategories).forEach(catKey => {
                const category = riskCategories[catKey];
                const gaugeContainer = document.createElement('div');
                gaugeContainer.className = 'gauge-container';
               
                const gaugeId = `gauge_${catKey}`;
                gaugeContainer.innerHTML = `
                    <div class="gauge-title">${category.name}</div>
                    <div class="gauge-chart" id="${gaugeId}"></div>
                `;
                gaugeGrid.appendChild(gaugeContainer);
               
                // Create Plotly gauge
                const plotlyData = [{
                    type: "indicator",
                    mode: "gauge+number",
                    value: category.currentScore,
                    domain: { x: [0, 1], y: [0, 1] },
                    title: { text: "Risk Score (%)", font: { size: 14 } },
                    gauge: {
                        axis: { range: [null, 100], tickwidth: 1, tickcolor: "darkblue" },
                        bar: { color: category.color, thickness: 0.3 },
                        bgcolor: "white",
                        borderwidth: 2,
                        bordercolor: "gray",
                        steps: [
                            { range: [0, category.thresholds.warning], color: "#2ca02c40" },
                            { range: [category.thresholds.warning, category.thresholds.critical], color: "#ffdd0040" },
                            { range: [category.thresholds.critical, category.thresholds.extreme], color: "#ff7f0e40" },
                            { range: [category.thresholds.extreme, 100], color: "#d6272840" }
                        ],
                        threshold: {
                            line: { color: "black", width: 4 },
                            thickness: 0.75,
                            value: category.currentScore
                        }
                    }
                }];
               
                const layout = {
                    width: Math.min(400, gaugeContainer.offsetWidth > 0 ? gaugeContainer.offsetWidth - 30 : 370),
                    height: 250,
                    margin: { t: 25, r: 25, l: 25, b: 25 },
                    paper_bgcolor: "#0a0a0a",
                    plot_bgcolor: "#0a0a0a",
                    font: { color: "#fff", family: "Arial" }
                };
               
                Plotly.newPlot(gaugeId, plotlyData, layout, { displayModeBar: false });
            });
        }
       
        function updateAlertIndicators() {
            const alertContainer = document.getElementById('alertIndicators');
            if (!alertContainer) return;
           
            alertContainer.innerHTML = '';
           
            Object.keys(riskCategories).forEach(catKey => {
                const category = riskCategories[catKey];
                const badge = document.createElement('div');
                badge.className = `alert-badge ${category.alertLevel}`;
               
                const labelText = `${category.name.split(' ')[1]}: ${category.currentScore}% (${category.alertLevel.toUpperCase()})`;
                badge.textContent = labelText;
               
                alertContainer.appendChild(badge);
            });
        }
       
        function updateRiskDashboard() {
            const warningThreshold = parseInt(document.getElementById('warningThreshold').value);
            const criticalThreshold = parseInt(document.getElementById('criticalThreshold').value);
            const extremeThreshold = parseInt(document.getElementById('extremeThreshold').value);
           
            // Update thresholds for all categories
            Object.keys(riskCategories).forEach(catKey => {
                riskCategories[catKey].thresholds = {
                    warning: warningThreshold,
                    critical: criticalThreshold,
                    extreme: extremeThreshold
                };
            });
           
            // Recalculate and update display
            calculateRiskScores();
            updateRiskGauges();
            updateAlertIndicators();
           
            showTemporaryMessage('Risk Dashboard Updated!', 'info');
        }

        // ===========================================
        // END OF RISK DASHBOARD FUNCTIONS
        // ===========================================
       
        // Edit symbol function (placeholder)
        function editSymbol(event, symbol) {
            event.stopPropagation();
            showTemporaryMessage(`Edit functionality for ${symbol} - implement as needed`, 'info');
        }
       
        // Utility functions
        function showTemporaryMessage(text, type = 'info') {
            const popup = document.createElement('div');
            popup.className = `message-popup ${type}`;
            popup.textContent = text;
            document.body.appendChild(popup);
           
            setTimeout(() => popup.remove(), 3000);
        }
       
        // Hide search results when clicking outside
        document.addEventListener('click', function(event) {
            const searchBox = document.getElementById('searchBox');
            const searchResults = document.getElementById('searchResults');
           
            if (!searchBox.contains(event.target) && !searchResults.contains(event.target)) {
                searchResults.style.display = 'none';
            }
        });
       
        // Initialize on page load
        window.onload = init;
    </script>
</body>
</html>