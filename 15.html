<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Financial Data Dashboard - Multi-API Integration</title>
    
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        
        /* Header */
        .header {
            background: #121212;
            padding: 15px 20px;
            border-bottom: 1px solid #282828;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo {
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* API Status Grid */
        .api-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .api-status-item {
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #333;
            text-align: center;
            font-size: 11px;
        }
        .api-status-item.connected { border-color: #00ff88; }
        .api-status-item.error { border-color: #ff4444; }
        .api-name { font-weight: bold; color: #00ccff; }
        .api-count { color: #888; font-size: 10px; }
        
        /* Search Section */
        .search-section {
            background: #121212;
            padding: 20px;
            border-bottom: 1px solid #282828;
        }
        .search-container {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
        }
        .search-box {
            width: 100%;
            padding: 15px 50px 15px 20px;
            background: #222;
            border: 2px solid #333;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
        }
        .search-box:focus {
            outline: none;
            border-color: #00ff88;
        }
        
        /* Search Results */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            margin-top: 5px;
            max-height: 600px;
            overflow-y: auto;
            background: #181818;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .search-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-item:hover { background: #252525; }
        .search-item-symbol {
            font-weight: bold;
            color: #00dd77;
            font-size: 14px;
        }
        .search-item-name {
            font-size: 12px;
            color: #ddd;
            margin-top: 4px;
        }
        .search-item-source {
            font-size: 11px;
            color: #888;
            background: #2a2a2a;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }
        
        /* Charts Area */
        .charts-area {
            padding: 20px;
            min-height: calc(100vh - 200px);
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
        }
        .chart-window {
            background: #131313;
            border: 1px solid #282828;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            min-height: 500px;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .chart-title {
            font-size: 16px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chart-title-input {
            background: #252525;
            border: 1px solid #383838;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            width: 300px;
        }
        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
        }
        .control-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        .control-btn.active {
            background: #00dd77;
            color: #000;
            border-color: #00dd77;
        }
        .close-btn {
            background: #dd4444;
            border-color: #dd4444;
            color: #fff;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }
        .close-btn:hover { background: #ff5555; }
        
        /* Change Display Controls */
        .change-display-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .change-btn {
            background: #252525;
            border: 1px solid #383838;
            color: #ccc;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .change-btn:hover {
            background: #333;
            border-color: #555;
        }
        .change-btn.active {
            background: #0066cc;
            color: #fff;
            border-color: #0066cc;
        }
        
        /* Chart Canvas */
        .chart-canvas {
            background: #0a0a0a;
            border-radius: 6px;
            height: 400px;
            min-height: 400px;
        }
        
        /* Info Panel */
        .info-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #282828;
        }
        .info-row:last-child { border-bottom: none; }
        .info-label {
            color: #888;
            font-size: 12px;
        }
        .info-value {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
        }
        .info-value.positive { color: #00ff88; }
        .info-value.negative { color: #ff4444; }
        
        /* Loading and Messages */
        .loading-message {
            text-align: center;
            padding: 20px;
            color: #00ff88;
        }
        .error-message {
            text-align: center;
            padding: 20px;
            color: #ff4444;
        }
        
        /* Auto-update indicator */
        .auto-update-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background: #252525;
            border-radius: 4px;
            font-size: 11px;
            color: #00ff88;
        }
        .update-dot {
            width: 6px;
            height: 6px;
            background: #00ff88;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f0f0f; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">ðŸ“Š MULTI-API FINANCIAL DASHBOARD</div>
        <div style="display: flex; gap: 20px; align-items: center;">
            <div class="auto-update-indicator">
                <span class="update-dot"></span>
                Auto-updating every 5 min
            </div>
            <button class="control-btn" onclick="addNewChart()">+ New Chart</button>
            <button class="control-btn" onclick="refreshAllData()">ðŸ”„ Refresh All</button>
        </div>
    </div>
    
    <div class="api-status-grid" id="apiStatusGrid">
        <div class="api-status-item" id="fred-status">
            <div class="api-name">FRED</div>
            <div class="api-count">Loading...</div>
        </div>
        <div class="api-status-item" id="ecb-status">
            <div class="api-name">ECB</div>
            <div class="api-count">Loading...</div>
        </div>
        <div class="api-status-item" id="bls-status">
            <div class="api-name">BLS</div>
            <div class="api-count">Loading...</div>
        </div>
        <div class="api-status-item" id="treasury-status">
            <div class="api-name">Treasury</div>
            <div class="api-count">Loading...</div>
        </div>
        <div class="api-status-item" id="nyfed-status">
            <div class="api-name">NY Fed</div>
            <div class="api-count">Loading...</div>
        </div>
        <div class="api-status-item" id="ofr-status">
            <div class="api-name">OFR</div>
            <div class="api-count">Loading...</div>
        </div>
    </div>

    <div class="search-section">
        <div class="search-container">
            <input type="text" class="search-box" id="searchBox"
                   placeholder="ðŸ” Search across all APIs (e.g., UNRATE, GDP, CPI, M2, DGS10, EFFR, etc.)"
                   onkeyup="performSearch(this.value)">
            <div class="search-results" id="searchResults" style="display: none;"></div>
        </div>
    </div>

    <div class="charts-area">
        <div class="chart-grid" id="chartGrid"></div>
    </div>

    <script>
        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        
        const API_CONFIG = {
            FRED: {
                key: '2f057499936072679d8843d7fce99989',
                baseUrl: 'https://api.stlouisfed.org/fred',
                corsProxy: 'https://corsproxy.io/?'
            },
            ECB: {
                baseUrl: 'https://data-api.ecb.europa.eu/service/data',
                corsProxy: 'https://corsproxy.io/?'
            },
            BLS: {
                key: 'a759447531f04f1f861f29a381aab863',
                baseUrl: 'https://api.bls.gov/publicAPI/v2',
                corsProxy: 'https://corsproxy.io/?'
            },
            Treasury: {
                baseUrl: 'https://api.fiscaldata.treasury.gov/services/api/fiscal_service',
                corsProxy: 'https://corsproxy.io/?'
            },
            NYFed: {
                baseUrl: 'https://markets.newyorkfed.org/api',
                corsProxy: 'https://corsproxy.io/?'
            },
            OFR: {
                baseUrl: 'https://data.financialresearch.gov/v1/series/timeseries',
                corsProxy: 'https://corsproxy.io/?'
            }
        };
        
        // Global state
        let charts = {};
        let chartIdCounter = 0;
        let searchCache = new Map();
        let dataCache = new Map();
        let autoUpdateInterval = null;
        
        // Common indicators by API
        const API_INDICATORS = {
            FRED: [
                { symbol: 'UNRATE', name: 'Unemployment Rate', frequency: 'Monthly' },
                { symbol: 'GDP', name: 'Gross Domestic Product', frequency: 'Quarterly' },
                { symbol: 'CPIAUCSL', name: 'Consumer Price Index', frequency: 'Monthly' },
                { symbol: 'FEDFUNDS', name: 'Federal Funds Rate', frequency: 'Monthly' },
                { symbol: 'DGS10', name: '10-Year Treasury Rate', frequency: 'Daily' },
                { symbol: 'DGS2', name: '2-Year Treasury Rate', frequency: 'Daily' },
                { symbol: 'M2SL', name: 'M2 Money Supply', frequency: 'Monthly' },
                { symbol: 'HOUST', name: 'Housing Starts', frequency: 'Monthly' },
                { symbol: 'INDPRO', name: 'Industrial Production Index', frequency: 'Monthly' },
                { symbol: 'PAYEMS', name: 'Nonfarm Payrolls', frequency: 'Monthly' }
            ],
            ECB: [
                { symbol: 'ECB.ILM.M.U2.C.L022100.U2.EUR', name: 'ECB Main Refinancing Rate', frequency: 'Monthly' },
                { symbol: 'ECB.BSI.M.U2.N.C.A20.A.1.U2.2250.Z01.E', name: 'ECB Total Assets', frequency: 'Monthly' },
                { symbol: 'ECB.FM.M.U2.EUR.4F.KR.MRR_FR.LEV', name: 'ECB Refinancing Operations', frequency: 'Monthly' }
            ],
            BLS: [
                { symbol: 'CUSR0000SA0', name: 'CPI All Items', frequency: 'Monthly' },
                { symbol: 'LNS14000000', name: 'Unemployment Rate (BLS)', frequency: 'Monthly' },
                { symbol: 'CES0000000001', name: 'Total Nonfarm Employment', frequency: 'Monthly' }
            ],
            Treasury: [
                { symbol: 'DEBT_TO_PENNY', name: 'US National Debt', frequency: 'Daily' },
                { symbol: 'TREASURY_BALANCE', name: 'Treasury General Account Balance', frequency: 'Daily' }
            ],
            NYFed: [
                { symbol: 'EFFR', name: 'Effective Federal Funds Rate', frequency: 'Daily' },
                { symbol: 'SOFR', name: 'SOFR Rate', frequency: 'Daily' },
                { symbol: 'OBFR', name: 'Overnight Bank Funding Rate', frequency: 'Daily' }
            ],
            OFR: [
                { symbol: 'OFR_FSI', name: 'Financial Stress Index', frequency: 'Daily' }
            ]
        };
        
        // ============================================================================
        // API DATA FETCHERS
        // ============================================================================
        
        class DataFetcher {
            constructor() {
                this.retryCount = 3;
                this.retryDelay = 1000;
            }
            
            async fetchWithRetry(url, options = {}, retries = this.retryCount) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok && retries > 0) {
                        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
                        return this.fetchWithRetry(url, options, retries - 1);
                    }
                    return response;
                } catch (error) {
                    if (retries > 0) {
                        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
                        return this.fetchWithRetry(url, options, retries - 1);
                    }
                    throw error;
                }
            }
            
            // FRED API
            async fetchFREDData(symbol, startDate = '1990-01-01') {
                const cacheKey = `FRED_${symbol}_${startDate}`;
                if (dataCache.has(cacheKey)) {
                    const cached = dataCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < 300000) { // 5 minutes cache
                        return cached.data;
                    }
                }
                
                try {
                    const url = `${API_CONFIG.FRED.baseUrl}/series/observations?series_id=${symbol}&api_key=${API_CONFIG.FRED.key}&file_type=json&observation_start=${startDate}&sort_order=asc`;
                    const proxyUrl = API_CONFIG.FRED.corsProxy + encodeURIComponent(url);
                    
                    const response = await this.fetchWithRetry(proxyUrl);
                    const data = await response.json();
                    
                    if (data.observations) {
                        const processedData = data.observations
                            .filter(obs => obs.value !== '.')
                            .map(obs => ({
                                date: obs.date,
                                value: parseFloat(obs.value)
                            }));
                        
                        dataCache.set(cacheKey, {
                            data: processedData,
                            timestamp: Date.now()
                        });
                        
                        return processedData;
                    }
                } catch (error) {
                    console.error(`FRED fetch error for ${symbol}:`, error);
                }
                return [];
            }
            
            // ECB API
            async fetchECBData(symbol, startDate = '1990-01-01') {
                const cacheKey = `ECB_${symbol}_${startDate}`;
                if (dataCache.has(cacheKey)) {
                    const cached = dataCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < 300000) {
                        return cached.data;
                    }
                }
                
                try {
                    // Parse ECB series key
                    const parts = symbol.split('.');
                    const flowRef = parts.slice(0, 2).join('.');
                    const key = parts.slice(2).join('.');
                    
                    const url = `${API_CONFIG.ECB.baseUrl}/${flowRef}/${key}?startPeriod=${startDate}&format=jsondata`;
                    const proxyUrl = API_CONFIG.ECB.corsProxy + encodeURIComponent(url);
                    
                    const response = await this.fetchWithRetry(proxyUrl);
                    const data = await response.json();
                    
                    if (data.dataSets && data.dataSets[0]) {
                        const series = data.dataSets[0].series;
                        const seriesKey = Object.keys(series)[0];
                        const observations = series[seriesKey].observations;
                        
                        const processedData = Object.entries(observations).map(([index, obs]) => {
                            const periodIndex = parseInt(index);
                            const period = data.structure.dimensions.observation[0].values[periodIndex];
                            return {
                                date: period.id,
                                value: obs[0]
                            };
                        });
                        
                        dataCache.set(cacheKey, {
                            data: processedData,
                            timestamp: Date.now()
                        });
                        
                        return processedData;
                    }
                } catch (error) {
                    console.error(`ECB fetch error for ${symbol}:`, error);
                }
                return [];
            }
            
            // BLS API
            async fetchBLSData(symbol, startYear = 1990) {
                const cacheKey = `BLS_${symbol}_${startYear}`;
                if (dataCache.has(cacheKey)) {
                    const cached = dataCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < 300000) {
                        return cached.data;
                    }
                }
                
                try {
                    const currentYear = new Date().getFullYear();
                    const url = `${API_CONFIG.BLS.baseUrl}/timeseries/data/`;
                    const proxyUrl = API_CONFIG.BLS.corsProxy + encodeURIComponent(url);
                    
                    const payload = {
                        seriesid: [symbol],
                        startyear: startYear,
                        endyear: currentYear,
                        registrationkey: API_CONFIG.BLS.key
                    };
                    
                    const response = await this.fetchWithRetry(proxyUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    const data = await response.json();
                    
                    if (data.Results && data.Results.series) {
                        const series = data.Results.series[0];
                        const processedData = series.data.map(obs => ({
                            date: `${obs.year}-${obs.period.replace('M', '')}-01`,
                            value: parseFloat(obs.value)
                        })).reverse();
                        
                        dataCache.set(cacheKey, {
                            data: processedData,
                            timestamp: Date.now()
                        });
                        
                        return processedData;
                    }
                } catch (error) {
                    console.error(`BLS fetch error for ${symbol}:`, error);
                }
                return [];
            }
            
            // Treasury API
            async fetchTreasuryData(symbol, startDate = '1990-01-01') {
                const cacheKey = `Treasury_${symbol}_${startDate}`;
                if (dataCache.has(cacheKey)) {
                    const cached = dataCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < 300000) {
                        return cached.data;
                    }
                }
                
                try {
                    let endpoint = '';
                    let field = '';
                    
                    if (symbol === 'DEBT_TO_PENNY') {
                        endpoint = 'v1/accounting/od/debt_to_penny';
                        field = 'tot_pub_debt_out_amt';
                    } else if (symbol === 'TREASURY_BALANCE') {
                        endpoint = 'v1/accounting/dts/dts_table_1';
                        field = 'open_today_bal';
                    }
                    
                    const url = `${API_CONFIG.Treasury.baseUrl}/${endpoint}?filter=record_date:gte:${startDate}&sort=-record_date&page[size]=10000`;
                    const proxyUrl = API_CONFIG.Treasury.corsProxy + encodeURIComponent(url);
                    
                    const response = await this.fetchWithRetry(proxyUrl);
                    const data = await response.json();
                    
                    if (data.data) {
                        const processedData = data.data.map(obs => ({
                            date: obs.record_date,
                            value: parseFloat(obs[field])
                        })).reverse();
                        
                        dataCache.set(cacheKey, {
                            data: processedData,
                            timestamp: Date.now()
                        });
                        
                        return processedData;
                    }
                } catch (error) {
                    console.error(`Treasury fetch error for ${symbol}:`, error);
                }
                return [];
            }
            
            // NY Fed API
            async fetchNYFedData(symbol, startDate = '1990-01-01') {
                const cacheKey = `NYFed_${symbol}_${startDate}`;
                if (dataCache.has(cacheKey)) {
                    const cached = dataCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < 300000) {
                        return cached.data;
                    }
                }
                
                try {
                    let endpoint = '';
                    
                    if (symbol === 'EFFR') {
                        endpoint = 'rates/effr/search';
                    } else if (symbol === 'SOFR') {
                        endpoint = 'rates/sofr/search';
                    } else if (symbol === 'OBFR') {
                        endpoint = 'rates/obfr/search';
                    }
                    
                    const url = `${API_CONFIG.NYFed.baseUrl}/${endpoint}?startDate=${startDate}`;
                    const proxyUrl = API_CONFIG.NYFed.corsProxy + encodeURIComponent(url);
                    
                    const response = await this.fetchWithRetry(proxyUrl);
                    const data = await response.json();
                    
                    if (data.refRates) {
                        const processedData = data.refRates.map(obs => ({
                            date: obs.effectiveDate,
                            value: parseFloat(obs.percentRate)
                        }));
                        
                        dataCache.set(cacheKey, {
                            data: processedData,
                            timestamp: Date.now()
                        });
                        
                        return processedData;
                    }
                } catch (error) {
                    console.error(`NY Fed fetch error for ${symbol}:`, error);
                }
                return [];
            }
            
            // OFR API
            async fetchOFRData(symbol, startDate = '1990-01-01') {
                const cacheKey = `OFR_${symbol}_${startDate}`;
                if (dataCache.has(cacheKey)) {
                    const cached = dataCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < 300000) {
                        return cached.data;
                    }
                }
                
                try {
                    const url = `${API_CONFIG.OFR.baseUrl}?mnemonic=${symbol}&start_date=${startDate}`;
                    const proxyUrl = API_CONFIG.OFR.corsProxy + encodeURIComponent(url);
                    
                    const response = await this.fetchWithRetry(proxyUrl);
                    const data = await response.json();
                    
                    if (data && Array.isArray(data)) {
                        const processedData = data.map(obs => ({
                            date: obs.date,
                            value: parseFloat(obs.value)
                        }));
                        
                        dataCache.set(cacheKey, {
                            data: processedData,
                            timestamp: Date.now()
                        });
                        
                        return processedData;
                    }
                } catch (error) {
                    console.error(`OFR fetch error for ${symbol}:`, error);
                }
                return [];
            }
            
            // Unified fetch method
            async fetchData(symbol, source, startDate = '1990-01-01') {
                switch (source) {
                    case 'FRED':
                        return await this.fetchFREDData(symbol, startDate);
                    case 'ECB':
                        return await this.fetchECBData(symbol, startDate);
                    case 'BLS':
                        return await this.fetchBLSData(symbol, parseInt(startDate.split('-')[0]));
                    case 'Treasury':
                        return await this.fetchTreasuryData(symbol, startDate);
                    case 'NYFed':
                        return await this.fetchNYFedData(symbol, startDate);
                    case 'OFR':
                        return await this.fetchOFRData(symbol, startDate);
                    default:
                        console.error(`Unknown data source: ${source}`);
                        return [];
                }
            }
        }
        
        const dataFetcher = new DataFetcher();
        
        // ============================================================================
        // CALCULATION FUNCTIONS
        // ============================================================================
        
        function calculateChanges(data) {
            if (!data || data.length === 0) return data;
            
            return data.map((item, index, arr) => {
                const newItem = { ...item };
                
                // Daily change
                if (index > 0) {
                    const prevValue = arr[index - 1].value;
                    newItem.daily_change = item.value - prevValue;
                    newItem.daily_pct_change = ((item.value - prevValue) / Math.abs(prevValue)) * 100;
                }
                
                // Month-over-Month (MoM) - approximately 21 trading days
                if (index >= 21) {
                    const monthAgoValue = arr[index - 21].value;
                    newItem.mom_change = ((item.value - monthAgoValue) / Math.abs(monthAgoValue)) * 100;
                }
                
                // Quarter-over-Quarter (QoQ) - approximately 63 trading days
                if (index >= 63) {
                    const quarterAgoValue = arr[index - 63].value;
                    newItem.qoq_change = ((item.value - quarterAgoValue) / Math.abs(quarterAgoValue)) * 100;
                }
                
                // Year-over-Year (YoY) - approximately 252 trading days
                if (index >= 252) {
                    const yearAgoValue = arr[index - 252].value;
                    newItem.yoy_change = ((item.value - yearAgoValue) / Math.abs(yearAgoValue)) * 100;
                }
                
                return newItem;
            });
        }
        
        // ============================================================================
        // SEARCH FUNCTIONALITY
        // ============================================================================
        
        let searchTimeout = null;
        
        async function performSearch(query) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (!query || query.trim().length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }
            
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                resultsDiv.innerHTML = '<div class="loading-message">Searching...</div>';
                resultsDiv.style.display = 'block';
                
                const results = [];
                const queryLower = query.toLowerCase();
                
                // Search through all API indicators
                for (const [api, indicators] of Object.entries(API_INDICATORS)) {
                    for (const indicator of indicators) {
                        if (indicator.symbol.toLowerCase().includes(queryLower) ||
                            indicator.name.toLowerCase().includes(queryLower)) {
                            results.push({
                                ...indicator,
                                source: api
                            });
                        }
                    }
                }
                
                displaySearchResults(results);
            }, 300);
        }
        
        function displaySearchResults(results) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<div class="error-message">No results found</div>';
                return;
            }
            
            let html = '';
            results.forEach(result => {
                html += `
                    <div class="search-item" onclick="addToChart('${result.symbol}', '${result.name}', '${result.source}')">
                        <div>
                            <div class="search-item-symbol">${result.symbol}</div>
                            <div class="search-item-name">${result.name}</div>
                        </div>
                        <div class="search-item-source">${result.source}</div>
                    </div>
                `;
            });
            
            resultsDiv.innerHTML = html;
        }
        
        // ============================================================================
        // CHART MANAGEMENT
        // ============================================================================
        
        function addNewChart() {
            const chartId = `chart_${chartIdCounter++}`;
            
            const chartHtml = `
                <div class="chart-window" id="${chartId}">
                    <div class="chart-header">
                        <div>
                            <div class="chart-title">
                                <input type="text" class="chart-title-input" 
                                       id="${chartId}_title_input"
                                       value="Chart ${chartIdCounter}"
                                       placeholder="Enter chart name...">
                            </div>
                            <div class="change-display-controls">
                                <button class="change-btn active" onclick="changeDisplayMode('${chartId}', 'value')" data-mode="value">Value</button>
                                <button class="change-btn" onclick="changeDisplayMode('${chartId}', 'mom')" data-mode="mom">MoM %</button>
                                <button class="change-btn" onclick="changeDisplayMode('${chartId}', 'qoq')" data-mode="qoq">QoQ %</button>
                                <button class="change-btn" onclick="changeDisplayMode('${chartId}', 'yoy')" data-mode="yoy">YoY %</button>
                            </div>
                        </div>
                        <div class="chart-controls">
                            <button class="control-btn" onclick="refreshChart('${chartId}')">ðŸ”„ Refresh</button>
                            <button class="close-btn" onclick="removeChart('${chartId}')">Ã—</button>
                        </div>
                    </div>
                    <div class="chart-canvas" id="${chartId}_canvas">
                        <div class="loading-message">Search for an indicator to add to this chart</div>
                    </div>
                    <div class="info-panel" id="${chartId}_info" style="display: none;">
                        <div class="info-row">
                            <span class="info-label">Latest Value:</span>
                            <span class="info-value" id="${chartId}_latest">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">MoM Change:</span>
                            <span class="info-value" id="${chartId}_mom">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">QoQ Change:</span>
                            <span class="info-value" id="${chartId}_qoq">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">YoY Change:</span>
                            <span class="info-value" id="${chartId}_yoy">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Data Points:</span>
                            <span class="info-value" id="${chartId}_points">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Last Updated:</span>
                            <span class="info-value" id="${chartId}_updated">-</span>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('chartGrid').insertAdjacentHTML('beforeend', chartHtml);
            
            charts[chartId] = {
                symbol: null,
                name: null,
                source: null,
                data: [],
                displayMode: 'value',
                lastUpdate: null
            };
        }
        
        function removeChart(chartId) {
            delete charts[chartId];
            document.getElementById(chartId)?.remove();
            
            if (Object.keys(charts).length === 0) {
                addNewChart();
            }
        }
        
        async function addToChart(symbol, name, source) {
            // Find the first empty chart or create a new one
            let targetChartId = null;
            
            for (const [chartId, chart] of Object.entries(charts)) {
                if (!chart.symbol) {
                    targetChartId = chartId;
                    break;
                }
            }
            
            if (!targetChartId) {
                addNewChart();
                targetChartId = `chart_${chartIdCounter - 1}`;
            }
            
            // Update chart title with indicator name
            const titleInput = document.getElementById(`${targetChartId}_title_input`);
            if (titleInput) {
                titleInput.value = name;
            }
            
            // Load data
            await loadChartData(targetChartId, symbol, name, source);
            
            // Hide search results
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchBox').value = '';
        }
        
        async function loadChartData(chartId, symbol, name, source) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.symbol = symbol;
            chart.name = name;
            chart.source = source;
            
            const canvasDiv = document.getElementById(`${chartId}_canvas`);
            if (canvasDiv) {
                canvasDiv.innerHTML = '<div class="loading-message">Loading data...</div>';
            }
            
            try {
                // Fetch data from appropriate API
                const rawData = await dataFetcher.fetchData(symbol, source, '1990-01-01');
                
                if (rawData && rawData.length > 0) {
                    // Calculate changes
                    chart.data = calculateChanges(rawData);
                    chart.lastUpdate = new Date().toISOString();
                    
                    // Update chart display
                    updateChartDisplay(chartId);
                    
                    // Update info panel
                    updateInfoPanel(chartId);
                    
                    // Show info panel
                    const infoPanel = document.getElementById(`${chartId}_info`);
                    if (infoPanel) {
                        infoPanel.style.display = 'block';
                    }
                } else {
                    canvasDiv.innerHTML = '<div class="error-message">No data available</div>';
                }
            } catch (error) {
                console.error(`Error loading data for ${symbol}:`, error);
                canvasDiv.innerHTML = '<div class="error-message">Failed to load data</div>';
            }
        }
        
        function updateChartDisplay(chartId) {
            const chart = charts[chartId];
            if (!chart || !chart.data || chart.data.length === 0) return;
            
            const canvasElement = document.getElementById(`${chartId}_canvas`);
            if (!canvasElement) return;
            
            let yData;
            let yTitle;
            
            switch (chart.displayMode) {
                case 'mom':
                    yData = chart.data.map(d => d.mom_change);
                    yTitle = 'MoM % Change';
                    break;
                case 'qoq':
                    yData = chart.data.map(d => d.qoq_change);
                    yTitle = 'QoQ % Change';
                    break;
                case 'yoy':
                    yData = chart.data.map(d => d.yoy_change);
                    yTitle = 'YoY % Change';
                    break;
                default:
                    yData = chart.data.map(d => d.value);
                    yTitle = 'Value';
            }
            
            const trace = {
                x: chart.data.map(d => d.date),
                y: yData,
                type: 'scatter',
                mode: 'lines',
                name: chart.symbol,
                line: {
                    color: '#00ff88',
                    width: 2
                },
                hovertemplate: `<b>${chart.symbol}</b><br>Date: %{x}<br>${yTitle}: %{y:.2f}<extra></extra>`
            };
            
            const layout = {
                title: {
                    text: `${chart.name} - ${yTitle}`,
                    font: { color: '#fff', size: 14 }
                },
                paper_bgcolor: '#0a0a0a',
                plot_bgcolor: '#0a0a0a',
                font: { color: '#aaa' },
                xaxis: {
                    gridcolor: '#333',
                    tickfont: { color: '#888' },
                    type: 'date'
                },
                yaxis: {
                    title: yTitle,
                    gridcolor: '#333',
                    tickfont: { color: '#888' },
                    zeroline: true,
                    zerolinecolor: '#444'
                },
                margin: { t: 40, r: 40, b: 40, l: 60 },
                hovermode: 'x unified'
            };
            
            const config = {
                responsive: true,
                displaylogo: false,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };
            
            Plotly.newPlot(canvasElement, [trace], layout, config);
        }
        
        function updateInfoPanel(chartId) {
            const chart = charts[chartId];
            if (!chart || !chart.data || chart.data.length === 0) return;
            
            const latest = chart.data[chart.data.length - 1];
            
            // Update latest value
            const latestEl = document.getElementById(`${chartId}_latest`);
            if (latestEl) {
                latestEl.textContent = latest.value.toFixed(2);
            }
            
            // Update MoM
            const momEl = document.getElementById(`${chartId}_mom`);
            if (momEl && latest.mom_change !== undefined) {
                momEl.textContent = `${latest.mom_change.toFixed(2)}%`;
                momEl.className = latest.mom_change >= 0 ? 'info-value positive' : 'info-value negative';
            }
            
            // Update QoQ
            const qoqEl = document.getElementById(`${chartId}_qoq`);
            if (qoqEl && latest.qoq_change !== undefined) {
                qoqEl.textContent = `${latest.qoq_change.toFixed(2)}%`;
                qoqEl.className = latest.qoq_change >= 0 ? 'info-value positive' : 'info-value negative';
            }
            
            // Update YoY
            const yoyEl = document.getElementById(`${chartId}_yoy`);
            if (yoyEl && latest.yoy_change !== undefined) {
                yoyEl.textContent = `${latest.yoy_change.toFixed(2)}%`;
                yoyEl.className = latest.yoy_change >= 0 ? 'info-value positive' : 'info-value negative';
            }
            
            // Update data points
            const pointsEl = document.getElementById(`${chartId}_points`);
            if (pointsEl) {
                pointsEl.textContent = chart.data.length.toLocaleString();
            }
            
            // Update last updated
            const updatedEl = document.getElementById(`${chartId}_updated`);
            if (updatedEl) {
                updatedEl.textContent = new Date(chart.lastUpdate).toLocaleString();
            }
        }
        
        function changeDisplayMode(chartId, mode) {
            const chart = charts[chartId];
            if (!chart) return;
            
            chart.displayMode = mode;
            
            // Update button states
            const chartWindow = document.getElementById(chartId);
            chartWindow.querySelectorAll('.change-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            
            updateChartDisplay(chartId);
        }
        
        async function refreshChart(chartId) {
            const chart = charts[chartId];
            if (!chart || !chart.symbol) return;
            
            await loadChartData(chartId, chart.symbol, chart.name, chart.source);
        }
        
        async function refreshAllData() {
            for (const chartId of Object.keys(charts)) {
                await refreshChart(chartId);
            }
        }
        
        // ============================================================================
        // API STATUS CHECKING
        // ============================================================================
        
        async function checkAPIStatus() {
            const apis = ['FRED', 'ECB', 'BLS', 'Treasury', 'NYFed', 'OFR'];
            
            for (const api of apis) {
                const statusEl = document.getElementById(`${api.toLowerCase()}-status`);
                const countEl = statusEl?.querySelector('.api-count');
                
                try {
                    // Try to fetch a sample indicator
                    const testIndicator = API_INDICATORS[api]?.[0];
                    if (testIndicator) {
                        const data = await dataFetcher.fetchData(
                            testIndicator.symbol,
                            api,
                            '2024-01-01'
                        );
                        
                        if (data && data.length > 0) {
                            statusEl?.classList.add('connected');
                            statusEl?.classList.remove('error');
                            if (countEl) {
                                countEl.textContent = `${API_INDICATORS[api].length} indicators`;
                            }
                        } else {
                            throw new Error('No data');
                        }
                    }
                } catch (error) {
                    statusEl?.classList.add('error');
                    statusEl?.classList.remove('connected');
                    if (countEl) {
                        countEl.textContent = 'Offline';
                    }
                }
            }
        }
        
        // ============================================================================
        // AUTO-UPDATE FUNCTIONALITY
        // ============================================================================
        
        function startAutoUpdate() {
            // Update every 5 minutes
            autoUpdateInterval = setInterval(async () => {
                await refreshAllData();
                await checkAPIStatus();
            }, 300000); // 5 minutes
        }
        
        function stopAutoUpdate() {
            if (autoUpdateInterval) {
                clearInterval(autoUpdateInterval);
                autoUpdateInterval = null;
            }
        }
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        async function init() {
            console.log('Initializing Multi-API Financial Dashboard...');
            
            // Check API status
            await checkAPIStatus();
            
            // Add first chart
            addNewChart();
            
            // Start auto-update
            startAutoUpdate();
            
            // Set up event listeners
            document.addEventListener('click', (e) => {
                const searchBox = document.getElementById('searchBox');
                const searchResults = document.getElementById('searchResults');
                
                if (!searchBox.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.style.display = 'none';
                }
            });
            
            // Handle page unload
            window.addEventListener('beforeunload', () => {
                stopAutoUpdate();
            });
        }
        
        // Start the application
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
